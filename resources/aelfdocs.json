[
    {
      "title": "Class Structure | AELF Docs",
      "url": "https://docs.aelf.com/learn/smart-contract/requirements-and-restrictions/structure-restrictions-and-requirements/",
      "html": "Skip to main content\nQuick Start\nLearn\nDocs\nTools\nResources\nBlog\nSearch\nUnderstanding aelf\nCore\nCross Chain\nConsensus\nNetwork\nBoot Sequence\nAddresses\nTransactions\nSmart Contract\nArchitecture\nService\nEvents\nMessages\nRestrictions\nProject Requirements\nClass Structure\nType and Namespace\nOther Restrictions\nACS\nTutorials\nNode Operator\nUnderstanding aelfSmart ContractRestrictionsClass Structure\nContract Class Structure\nRestrictions for Simplified Code Checks​\nInheritance Rules​\nOnly one inheritance is allowed from ContractBase, generated by the contract plugin as a nested type in ContractContainer.\nOnly one inheritance is allowed from CSharpSmartContract.\nOnly one inheritance is allowed from ContractState.\nThe type inherited from ContractState should be the element type of the CSharpSmartContract generic instance type.\n\nIf these rules are not followed, code deployment will fail.\n\nField Usage Limitations​\nIn Contract Implementation Class​\nInitial values for non-readonly, non-constant fields are not allowed (for both static and non-static fields). This is because their value will reset to 0 or null after the first execution, losing the initial value.\nAllowed:​\nclass MyContract : MyContractBase\n{\n  int test;\n  static const int test = 2;\n}\n\nNot Allowed:​\nclass MyContract : MyContractBase\n{\n!  int test = 2;\n}\n\nclass MyContract : MyContractBase\n{\n  int test;\n\n  public MyContract\n  {\n!    test = 2;\n  }\n}\n\nOnly primitive types or the following types are allowed for readonly/constant fields:\nMarshaller<T>\nMethod<T, T>\nMessageParser<T>\nFieldCodec<T>\nMapField<T, T>\nReadonlyCollection<T>\nReadonlyDictionary<T, T> Note: T can only be a primitive type.\nIn Non-Contract Classes (Classes not inheriting from ContractBase<T>)​\nInitial values for non-readonly, non-constant static fields are not allowed. They reset to 0 or null after the first execution, losing the initial value.\nAllowed:​\nclass AnyClass\n{\n  static int test;\n}\n\nNot Allowed:​\nclass AnyClass\n{\n!  static int test = 2;\n}\n\nclass AnyClass\n{\n  static int test;\n\n  public AnyClass\n  {\n!    test = 2;\n  }\n}\n\nException: Fields with FileDescriptor types are allowed due to protobuf-generated code. These fields don’t have a readonly modifier and write access to them is allowed only from the constructor of the declaring type.\nAllowed:​\npublic class TestType\n{\n  private static FileDescriptor test;\n\n  public class TestType\n  {\n    test = ...\n  }\n}\n\nNot Allowed:​\npublic class TestType\n{\n  private static FileDescriptor test;\n\n  public TestType\n  {\n    test = ...\n  }\n\n!  public void SetFromSomeWhereElse(FileDescriptor input)\n!  {\n!    test = input;\n!  }\n}\n\n\nAccessing test fields is restricted to the declaring type’s constructor only.\n\nOnly the following types are allowed for readonly/constant static fields:\n\nMarshaller<T>\nMethod<T, T>\nMessageParser<T>\nFieldCodec<T>\nMapField<T, T>\nReadonlyCollection<T>\nReadonlyDictionary<T, T>\n\nNote: T can only be a primitive type.\n\nException: If a type has a readonly field of the same type as itself, it is only allowed if the type has no instance fields (to support LINQ-related generated types).\nAllowed:​\npublic class TestType\n{\n  private static readonly TestType test;\n\n  private static int i;\n}\n\nNot Allowed:​\npublic class TestType\n{\n  private static readonly TestType test;\n\n!  private int i;\n}\n\nIn Contract State​\n\nIn contract state, only the following types are allowed:\n\nPrimitive Types​\nBoolState\nInt32State\nUInt32State\nInt64State\nUInt64State\nStringState\nBytesState\nComplex Types\nComplex Types​\nSingletonState<T>\nReadonlyState<T>\nMappedState<T, T>\nMappedState<T, T, T>\nMappedState<T, T, T, T>\nMappedState<T, T, T, T, T>\nMethodReference<T, T>\nProtobufState<T>\nContractReferenceState\nPrevious\nProject Requirements\nNext\nType and Namespace\nRestrictions for Simplified Code Checks\nInheritance Rules\nField Usage Limitations\nIn Contract Implementation Class\nIn Non-Contract Classes (Classes not inheriting from ContractBase<T>)\nIn Contract State\nPlatform\nTechnology\nAudit Report\nPrivacy\nTerms of Use\nCookie Policy\nDeveloper Resources\nQuick Start\nLearn\nDocs\nTools\nResources\nEcosystem\nOverview\ndApps\naelf Ventures\nBlog\nConnect\nContact Us\nCopyright © 2024 aelf"
    },
    {
      "title": "Type and Namespace | AELF Docs",
      "url": "https://docs.aelf.com/learn/smart-contract/requirements-and-restrictions/namespace-and-type-restrictions/",
      "html": "Skip to main content\nQuick Start\nLearn\nDocs\nTools\nResources\nBlog\nSearch\nUnderstanding aelf\nCore\nCross Chain\nConsensus\nNetwork\nBoot Sequence\nAddresses\nTransactions\nSmart Contract\nArchitecture\nService\nEvents\nMessages\nRestrictions\nProject Requirements\nClass Structure\nType and Namespace\nOther Restrictions\nACS\nTutorials\nNode Operator\nUnderstanding aelfSmart ContractRestrictionsType and Namespace\nType and Namespace Restrictions\n\nWhen deploying new contract code, Nodes perform checks against a whitelist. If any type used in the code is not listed in the whitelist, or if the method access or type name is denied, the deployment will fail. This ensures that only approved types and namespaces can be utilized within the contract code.\n\nAssembly Dependencies​\nAssembly\tTrust\nnetstandard.dll\tPartial\nSystem.Runtime.dll\tPartial\nSystem.Runtime.Extensions.dll\tPartial\nSystem.Private.CoreLib.dll\tPartial\nSystem.ObjectModel.dll\tPartial\nSystem.Linq.dll\tFull\nSystem.Collections\tFull\nGoogle.Protobuf.dll\tFull\nAElf.Sdk.CSharp.dll\tFull\nAElf.Types.dll\tFull\nAElf.CSharp.Core.dll\tFull\nAElf.Cryptography.dll\tFull\nTypes and Members Whitelist in System Namespace​\nType\tMember (Field / Method)\tAllowed\nArray\tAsReadOnly\tAllowed\nFunc<T>\tALL\tAllowed\nFunc<T,T>\tALL\tAllowed\nFunc<T,T,T>\tALL\tAllowed\nNullable<T>\tALL\tAllowed\nEnvironment\tCurrentManagedThreadId\tAllowed\nBitConverter\tGetBytes\tAllowed\nNotImplementedException\tALL\tAllowed\nNotSupportedException\tALL\tAllowed\nArgumentOutOfRangeException\tALL\tAllowed\nDateTime\tPartially\tAllowed\nDateTime\tNow, UtcNow, Today\tDenied\nUri\tTryCreate\tAllowed\nUri\tScheme\tAllowed\nUri\tUriSchemeHttp\tAllowed\nUri\tUriSchemeHttps\tAllowed\nvoid\tALL\tAllowed\nobject\tALL\tAllowed\nType\tALL\tAllowed\nIDisposable\tALL\tAllowed\nConvert\tALL\tAllowed\nMath\tALL\tAllowed\nbool\tALL\tAllowed\nbyte\tALL\tAllowed\nsbyte\tALL\tAllowed\nchar\tALL\tAllowed\nint\tALL\tAllowed\nuint\tALL\tAllowed\nlong\tALL\tAllowed\nulong\tALL\tAllowed\ndecimal\tALL\tAllowed\nstring\tALL\tAllowed\nstring\tConstructor\tDenied\nByte[]\tALL\tAllowed\nTypes and Members Whitelist in System.Reflection Namespace​\nType\tMember (Field / Method)\tAllowed\nAssemblyCompanyAttribute\tALL\tAllowed\nAssemblyConfigurationAttribute\tALL\tAllowed\nAssemblyFileVersionAttribute\tALL\tAllowed\nAssemblyInformationalVersionAttribute\tALL\tAllowed\nAssemblyProductAttribute\tALL\tAllowed\nAssemblyTitleAttribute\tALL\tAllowed\nOther Whitelisted Namespaces​\nNamespace\tType\tMember\tAllowed\nSystem.Linq\tALL\tALL\tAllowed\nSystem.Collections\tALL\tALL\tAllowed\nSystem.Collections.Generic\tALL\tALL\tAllowed\nSystem.Collections.ObjectModel\tALL\tALL\tAllowed\nSystem.Globalization\tCultureInfo\tInvariantCulture\tAllowed\nSystem.Runtime.CompilerServices\tRuntimeHelpers\tInitializeArray\tAllowed\nSystem.Text\tEncoding\tUTF8, GetByteCount\tAllowed\nAllowed Types for Arrays​\nType\tArray Size Limit\nbyte\t40960\nshort\t20480\nint\t10240\nlong\t5120\nushort\t20480\nuint\t10240\nulong\t5120\ndecimal\t2560\nchar\t20480\nstring\t320\nType\t5\nObject\t5\nFileDescriptor\t10\nGeneratedClrTypeInfo\t100\nPrevious\nClass Structure\nNext\nOther Restrictions\nAssembly Dependencies\nTypes and Members Whitelist in System Namespace\nTypes and Members Whitelist in System.Reflection Namespace\nOther Whitelisted Namespaces\nAllowed Types for Arrays\nPlatform\nTechnology\nAudit Report\nPrivacy\nTerms of Use\nCookie Policy\nDeveloper Resources\nQuick Start\nLearn\nDocs\nTools\nResources\nEcosystem\nOverview\ndApps\naelf Ventures\nBlog\nConnect\nContact Us\nCopyright © 2024 aelf"
    },
    {
      "title": "AELF Docs",
      "url": "https://docs.aelf.com/learn/smart-contract/requirements-and-restrictions/project-requirements/",
      "html": "Skip to main content\nQuick Start\nLearn\nDocs\nTools\nResources\nBlog\nSearch\nUnderstanding aelf\nCore\nCross Chain\nConsensus\nNetwork\nBoot Sequence\nAddresses\nTransactions\nSmart Contract\nArchitecture\nService\nEvents\nMessages\nRestrictions\nProject Requirements\nClass Structure\nType and Namespace\nOther Restrictions\nACS\nTutorials\nNode Operator\nUnderstanding aelfSmart ContractRestrictionsProject Requirements\nContract Project Requirements\nProject Properties​\nAdd Contract Proto File​\n\nEnsure to add a contract proto file in the contract directory of your project. This allows aelf’s contract patcher to process the DLL, enabling necessary injections for code checks during deployment. Without this, deployment will fail.\n\nsrc\n├── Protobuf \n│ └── contract\n│ └── hello_world_contract.proto\n\nEnable Overflow Checks​\n\nEnable CheckForOverflowUnderflow for both Release and Debug modes. This ensures arithmetic operations that overflow will throw an OverflowException, preventing unpredictable results.\n\n<PropertyGroup Condition=\" '$(Configuration)' == 'Debug' \">\n  <CheckForOverflowUnderflow>true</CheckForOverflowUnderflow>\n</PropertyGroup>\n\n<PropertyGroup Condition=\" '$(Configuration)' == 'Release' \">\n  <CheckForOverflowUnderflow>true</CheckForOverflowUnderflow>\n</PropertyGroup>\n\n\nIf your contract has unchecked arithmetic operations, deployment will fail.\n\nPrevious\nRestrictions\nNext\nClass Structure\nProject Properties\nAdd Contract Proto File\nEnable Overflow Checks\nPlatform\nTechnology\nAudit Report\nPrivacy\nTerms of Use\nCookie Policy\nDeveloper Resources\nQuick Start\nLearn\nDocs\nTools\nResources\nEcosystem\nOverview\ndApps\naelf Ventures\nBlog\nConnect\nContact Us\nCopyright © 2024 aelf"
    },
    {
      "title": "Net API | AELF Docs",
      "url": "https://docs.aelf.com/docs/web-api/net-api/",
      "html": "Skip to main content\nQuick Start\nLearn\nDocs\nTools\nResources\nBlog\nSearch\nDocs Reference\nSmart Contract API\nWeb API\nChain API\nNet API\nDocs ReferenceWeb APINet API\nNet API\nGet Network Information​\nGET /api/net/networkInfo\n\nResponses​\nHTTP Code\tDescription\tSchema\n200\tSuccess\tGetNetworkInfoOutput\nProduces​\ntext/plain; v=1.0\napplication/json; v=1.0\ntext/json; v=1.0\napplication/x-protobuf; v=1.0\nTags​\nNet\nAdd Peer​\nPOST /api/net/peer\n\nParameters​\nType\tName\tSchema\nBody\tinput\tAddPeerInput\nResponses​\nHTTP Code\tDescription\tSchema\n200\tSuccess\tboolean\n401\tUnauthorized\t\nSecurity​\nBasic Authentication\nConsumes​\napplication/json-patch+json; v=1.0\napplication/json; v=1.0\ntext/json; v=1.0\napplication/*+json; v=1.0\napplication/x-protobuf; v=1.0\nProduces​\ntext/plain; v=1.0\napplication/json; v=1.0\ntext/json; v=1.0\napplication/x-protobuf; v=1.0\nTags​\nNet\nRemove Peer​\n\nDELETE /api/net/peer\n\nParameters​\nType\tName\tDescription\tSchema\nQuery\taddress\tip address\tstring\nResponses​\nHTTP Code\tDescription\tSchema\n200\tSuccess\tboolean\n401\tUnauthorized\t\nSecurity​\nBasic Authentication\nProduces​\ntext/plain; v=1.0\napplication/json; v=1.0\ntext/json; v=1.0\napplication/x-protobuf; v=1.0\nTags​\nNet\nGet Peers Info​\n\nGET /api/net/peers\n\nParameters​\nType\tName\tDescription\tSchema\tDefault\nQuery\twithMetrics\tboolean\t\t\"false\"\nResponses​\nHTTP Code\tDescription\tSchema\n200\tSuccess\tPeerDto array\nProduces​\ntext/plain; v=1.0\napplication/json; v=1.0\ntext/json; v=1.0\napplication/x-protobuf; v=1.0\nTags​\nBlockChain\nGet the Current Status of a Transaction​\n\nGET /api/blockChain/transactionResult\n\nParameters​\nType\tName\tSchema\tDescription\tRequired\nQuery\ttransactionId\tstring\tTransaction ID\tNo\nResponses​\nHTTP Code\tDescription\tSchema\n200\tSuccess\tTransactionResultDto\nProduces​\ntext/plain; v=1.0\napplication/json; v=1.0\ntext/json; v=1.0\napplication/x-protobuf; v=1.0\nTags​\nBlockChain\nDefinitions​\nAddPeerInput​\nName\tSchema\tDescription\nAddress\tstring\tip address (optional)\nBlockBodyDto​\nName\tSchema\tDescription\nTransactions\tstring[]\tarray of strings (optional)\nTransactionsCount\tinteger (int32)\tinteger (optional)\nBlockDto​\nName\tSchema\tDescription\nBlockHash\tstring\tstring (optional)\nBody\tBlockBodyDto\tblock body (optional)\nHeader\tBlockHeaderDto\tblock header (optional)\nBlockSize\tinteger (int32)\tinteger (optional)\nBlockHeaderDto​\nName\tSchema\tDescription\nBloom\tstring\tstring (optional)\nChainId\tstring\tstring (optional)\nExtra\tstring\tstring (optional)\nHeight\tinteger (int64)\tinteger (optional)\nMerkleTreeRootOfTransactions\tstring\tstring (optional)\nMerkleTreeRootOfWorldState\tstring\tstring (optional)\nMerkleTreeRootOfTransactionState\tstring\tstring (optional)\nPreviousBlockHash\tstring\tstring (optional)\nSignerPubkey\tstring\tstring (optional)\nTime\tstring (date-time)\tstring (optional)\nBlockStateDto​\nName\tSchema\tDescription\nBlockHash\tstring\tstring (optional)\nBlockHeight\tinteger (int64)\tinteger (optional)\nChanges\tmap of strings\tmap (optional)\nDeletes\tstring[]\tarray of strings (optional)\nPreviousHash\tstring\tstring (optional)\nChainStatusDto​\nName\tSchema\tDescription\nBestChainHash\tstring\tstring (optional)\nBestChainHeight\tinteger (int64)\tinteger (optional)\nBranches\tmap of strings and integers (int64)\tmap (optional)\nChainId\tstring\tstring (optional)\nGenesisBlockHash\tstring\tstring (optional)\nGenesisContractAddress\tstring\tstring (optional)\nLastIrreversibleBlockHash\tstring\tstring (optional)\nLastIrreversibleBlockHeight\tinteger (int64)\tinteger (optional)\nLongestChainHash\tstring\tstring (optional)\nLongestChainHeight\tinteger (int64)\tinteger (optional)\nNotLinkedBlocks\tmap of strings\tmap (optional)\nCreateRawTransactionInput​\nName\tSchema\tDescription\nFrom\tstring\tfrom address (required)\nMethodName\tstring\tcontract method name (required)\nParams\tstring\tcontract method parameters (required)\nRefBlockHash\tstring\trefer block hash (required)\nRefBlockNumber\tinteger (int64)\trefer block height (required)\nTo\tstring\tto address (required)\nCreateRawTransactionOutput​\nName\tSchema\tDescription\nRawTransaction\tstring\tstring (optional)\nExecuteRawTransactionDto​\nName\tSchema\tDescription\nRawTransaction\tstring\traw transaction string (optional)\nSignature\tstring\tsignature string (optional)\nExecuteTransactionDto​\nName\tSchema\tDescription\nRawTransaction\tstring\traw transaction string (optional)\nGetNetworkInfoOutput​\nName\tSchema\tDescription\nConnections\tinteger (int32)\tinteger (optional)\nProtocolVersion\tinteger (int32)\tinteger (optional)\nVersion\tstring\tstring (optional)\nGetTransactionPoolStatusOutput​\nName\tSchema\tDescription\nQueued\tinteger (int32)\tinteger (optional)\nValidated\tinteger (int32)\tinteger (optional)\nLogEventDto​\nName\tSchema\tDescription\nAddress\tstring\tstring (optional)\nIndexed\tstring[]\tarray of strings (optional)\nName\tstring\tstring (optional)\nNonIndexed\tstring\tstring (optional)\nMerklePathDto​\nName\tSchema\tDescription\nMerklePathNodes\tMerklePathNodeDto[]\tarray of MerklePathNodeDto (optional)\nMerklePathNodeDto​\nName\tSchema\tDescription\nHash\tstring\tstring (optional)\nIsLeftChildNode\tboolean\tboolean (optional)\nMinerInRoundDto​\nName\tSchema\tDescription\nActualMiningTimes\tstring[]\tarray of strings (date-time) (optional)\nExpectedMiningTime\tstring (date-time)\tstring (date-time) (optional)\nImpliedIrreversibleBlockHeight\tinteger (int64)\tinteger (int64) (optional)\nInValue\tstring\tstring (optional)\nMissedBlocks\tinteger (int64)\tinteger (int64) (optional)\nOrder\tinteger (int32)\tinteger (int32) (optional)\nOutValue\tstring\tstring (optional)\nPreviousInValue\tstring\tstring (optional)\nProducedBlocks\tinteger (int64)\tinteger (int64) (optional)\nProducedTinyBlocks\tinteger (int32)\tinteger (int32) (optional)\nPeerDto​\nName\tSchema\tDescription\nBufferedAnnouncementsCount\tinteger (int32)\tinteger (int32) (optional)\nBufferedBlocksCount\tinteger (int32)\tinteger (int32) (optional)\nBufferedTransactionsCount\tinteger (int32)\tinteger (int32) (optional)\nConnectionTime\tinteger (int64)\tinteger (int64) (optional)\nInbound\tboolean\tboolean (optional)\nIpAddress\tstring\tstring (optional)\nProtocolVersion\tinteger (int32)\tinteger (int32) (optional)\nRequestMetrics\tRequestMetric[]\tarray of RequestMetric (optional)\nConnectionStatus\tstring\tstring (optional)\nNodeVersion\tstring\tstring (optional)\n\nThis structure should provide a clear overview of each variable's name, schema, and description. Let me know if you need any further adjustments!\n\nRequestMetric​\n\nName: RequestMetric\n\nName\tSchema\tDescription\nInfo\tstring\toptional\nMethodName\tstring\toptional\nRequestTime\tTimestamp\toptional\nRoundTripTime\tinteger (int64)\toptional\nRoundDto​\n\nName: RoundDto\n\nName\tSchema\tDescription\nConfirmedIrreversibleBlockHeight\tinteger (int64)\toptional\nConfirmedIrreversibleBlockRoundNumber\tinteger (int64)\toptional\nExtraBlockProducerOfPreviousRound\tstring\toptional\nIsMinerListJustChanged\tboolean\toptional\nRealTimeMinerInformation\t< string, MinerInRoundDto >\toptional\nRoundId\tinteger (int64)\toptional\nRoundNumber\tinteger (int64)\toptional\nTermNumber\tinteger (int64)\toptional\nSendRawTransactionInput​\n\nName: SendRawTransactionInput\n\nName\tSchema\tDescription\nReturnTransaction\tboolean\treturn transaction detail optional\nSignature\tstring\toptional\nTransaction\tstring\traw transaction\nSendRawTransactionOutput​\n\nName: SendRawTransactionOutput\n\nName\tSchema\tDescription\nTransaction\tTransactionDto\toptional\nTransactionId\tstring\toptional\nSendTransactionInput​\n\nName: SendTransactionInput\n\nName\tSchema\tDescription\nRawTransaction\tstring\traw transaction\nSendTransactionOutput​\n\nName: SendTransactionOutput\n\nName\tSchema\tDescription\nTransactionId\tstring\toptional\nSendTransactionsInput​\n\nName: SendTransactionsInput\n\nName\tSchema\tDescription\nRawTransactions\tstring\traw transactions\nTaskQueueInfoDto​\n\nName: TaskQueueInfoDto\n\nName\tSchema\tDescription\nName\tstring\toptional\nSize\tinteger (int32)\toptional\nTimestamp​\n\nName: Timestamp\n\nName\tSchema\tDescription\nNanos\tinteger (int32)\toptional\nSeconds\tinteger (int64)\toptional\nTransactionDto​\n\nName: TransactionDto\n\nName\tSchema\tDescription\nFrom\tstring\toptional\nMethodName\tstring\toptional\nParams\tstring\toptional\nRefBlockNumber\tinteger (int64)\toptional\nRefBlockPrefix\tstring\toptional\nSignature\tstring\toptional\nTo\tstring\toptional\nTransactionResultDto​\n\nName: TransactionResultDto\n\nName\tSchema\tDescription\nBlockHash\tstring\toptional\nBlockNumber\tinteger (int64)\toptional\nBloom\tstring\toptional\nError\tstring\toptional\nLogs\t< LogEventDto >\toptional\nReturnValue\tstring\toptional\nStatus\tstring\toptional\nTransaction\tTransactionDto\toptional\nTransactionId\tstring\toptional\nTransactionSize\tinteger (int32)\toptional\nCalculateTransactionFeeInput​\n\nName: CalculateTransactionFeeInput\n\nName\tSchema\tDescription\nRawTransaction\tstring\toptional\nCalculateTransactionFeeOutput​\n\nName: CalculateTransactionFeeOutput\n\nName\tSchema\tDescription\nSuccess\tbool\toptional\nTransactionFee\tDictionary<string, long>\toptional\nResourceFee\tDictionary<string, long>\toptional\nPrevious\nChain API\nGet Network Information\nResponses\nProduces\nTags\nAdd Peer\nResponses\nSecurity\nConsumes\nProduces\nTags\nRemove Peer\nParameters\nResponses\nSecurity\nProduces\nTags\nGet Peers Info\nParameters\nResponses\nProduces\nTags\nGet the Current Status of a Transaction\nParameters\nResponses\nProduces\nTags\nDefinitions\nPlatform\nTechnology\nAudit Report\nPrivacy\nTerms of Use\nCookie Policy\nDeveloper Resources\nQuick Start\nLearn\nDocs\nTools\nResources\nEcosystem\nOverview\ndApps\naelf Ventures\nBlog\nConnect\nContact Us\nCopyright © 2024 aelf"
    },
    {
      "title": "AELF Docs",
      "url": "https://docs.aelf.com/docs/web-api/chain-api/",
      "html": "Skip to main content\nQuick Start\nLearn\nDocs\nTools\nResources\nBlog\nSearch\nDocs Reference\nSmart Contract API\nWeb API\nChain API\nNet API\nDocs ReferenceWeb APIChain API\nChain API\nGet information about a given block by block hash. Optionally with the list of its transactions.​\nGET /api/blockChain/block\n\nParameter\tType\tDescription\tDefault\nblockHash\tstring\tBlock hash (optional)\t\nincludeTransactions\tboolean\tInclude transactions (optional)\t\"false\"\nResponses​\n200: Success (BlockDto)\nProduces​\ntext/plain; v=1.0\napplication/json; v=1.0\ntext/json; v=1.0\napplication/x-protobuf; v=1.0\nTags​\nBlockChain\nGet information about a given block by block height. Optionally with the list of its transactions.​\nGET /api/blockChain/blockByHeight\n\nParameter\tType\tDescription\tDefault\nblockHeight\tinteger\tBlock height (optional)\t\nincludeTransactions\tboolean\tInclude transactions (optional)\t\"false\"\nResponses​\n200: Success (BlockDto)\nProduces​\ntext/plain; v=1.0\napplication/json; v=1.0\ntext/json; v=1.0\napplication/x-protobuf; v=1.0\nTags​\nBlockChain\nGet the height of the current chain.​\nGET /api/blockChain/blockHeight\n\nResponses​\n200: Success (integer, int64)\nProduces​\ntext/plain; v=1.0\napplication/json; v=1.0\ntext/json; v=1.0\napplication/x-protobuf; v=1.0\nTags​\nBlockChain\nGet the current state about a given block.​\nGET /api/blockChain/blockState\n\nParameter\tType\tDescription\nblockHash\tstring\tBlock hash (optional)\nResponses​\n200: Success (BlockStateDto)\nProduces​\ntext/plain; v=1.0\napplication/json; v=1.0\ntext/json; v=1.0\napplication/x-protobuf; v=1.0\nTags​\nBlockChain\nGet the current status of the block chain.​\nGET /api/blockChain/chainStatus\n\nResponses​\n200: Success (ChainStatusDto)\nProduces​\ntext/plain; v=1.0\napplication/json; v=1.0\ntext/json; v=1.0\napplication/x-protobuf; v=1.0\nTags​\nBlockChain\nGet the protobuf definitions related to a contract.​\nGET /api/blockChain/contractFileDescriptorSet\n\nParameter\tType\tDescription\naddress\tstring\tContract address (optional)\nResponses​\n200: Success (string, byte)\nProduces​\ntext/plain; v=1.0\napplication/json; v=1.0\ntext/json; v=1.0\napplication/x-protobuf; v=1.0\nTags​\nBlockChain\nExecute a raw transaction.​\nPOST /api/blockChain/executeRawTransaction\n\nParameters​\nType\tName\tSchema\nBody\tinput\tExecuteRawTransactionDto (optional)\nResponses​\nHTTP Code\tDescription\tSchema\n200\tSuccess\tstring\nConsumes​\napplication/json-patch+json; v=1.0\napplication/json; v=1.0\ntext/json; v=1.0\napplication/*+json; v=1.0\napplication/x-protobuf; v=1.0\nProduces​\ntext/plain; v=1.0\napplication/json; v=1.0\ntext/json; v=1.0\napplication/x-protobuf; v=1.0\nTags​\nBlockChain\nCall a read-only method on a contract.​\nPOST /api/blockChain/executeTransaction\n\nParameters​\nType\tName\tSchema\nBody\tinput\tExecuteTransactionDto (optional)\nResponses​\nHTTP Code\tDescription\tSchema\n200\tSuccess\tstring\nConsumes​\napplication/json-patch+json; v=1.0\napplication/json; v=1.0\ntext/json; v=1.0\napplication/*+json; v=1.0\napplication/x-protobuf; v=1.0\nProduces​\ntext/plain; v=1.0\napplication/json; v=1.0\ntext/json; v=1.0\napplication/x-protobuf; v=1.0\nTags​\nBlockChain\nGet the merkle path of a transaction.​\nGET /api/blockChain/merklePathByTransactionId\n\nParameters​\nType\tName\tSchema\nQuery\ttransactionId\tstring (optional)\nResponses​\nHTTP Code\tDescription\tSchema\n200\tSuccess\tMerklePathDto\nProduces​\ntext/plain; v=1.0\napplication/json; v=1.0\ntext/json; v=1.0\napplication/x-protobuf; v=1.0\nTags​\nBlockChain\nCreates an unsigned serialized transaction.​\nPOST /api/blockChain/rawTransaction\n\nParameters​\nType\tName\tSchema\nBody\tinput\tCreateRawTransactionInput (optional)\nResponses​\nHTTP Code\tDescription\tSchema\n200\tSuccess\tCreateRawTransactionOutput\nConsumes​\napplication/json-patch+json; v=1.0\napplication/json; v=1.0\ntext/json; v=1.0\napplication/*+json; v=1.0\napplication/x-protobuf; v=1.0\nProduces​\ntext/plain; v=1.0\napplication/json; v=1.0\ntext/json; v=1.0\napplication/x-protobuf; v=1.0\nTags​\nBlockChain\nSend a transaction.​\nPOST /api/blockChain/sendRawTransaction\n\nParameters​\nType\tName\tSchema\nBody\tinput\tSendRawTransactionInput (optional)\nResponses​\nHTTP Code\tDescription\tSchema\n200\tSuccess\tSendRawTransactionOutput\nConsumes​\napplication/json-patch+json; v=1.0\napplication/json; v=1.0\ntext/json; v=1.0\napplication/*+json; v=1.0\napplication/x-protobuf; v=1.0\nProduces​\ntext/plain; v=1.0\napplication/json; v=1.0\ntext/json; v=1.0\napplication/x-protobuf; v=1.0\nTags​\nBlockChain\nBroadcast a Transaction​\nPOST /api/blockChain/sendTransaction\n\nParameters​\nType\tName\tSchema\tDescription\tRequired\nBody\tinput\tSendTransactionInput\t-\tNo\nResponses​\nHTTP Code\tDescription\tSchema\n200\tSuccess\tSendTransactionOutput\nConsumes​\napplication/json-patch+json; v=1.0\napplication/json; v=1.0\ntext/json; v=1.0\napplication/*+json; v=1.0\napplication/x-protobuf; v=1.0\nProduces​\ntext/plain; v=1.0\napplication/json; v=1.0\ntext/json; v=1.0\napplication/x-protobuf; v=1.0\n\n**Tags\n\nBlockChain\nBroadcast Multiple Transactions​\nPOST /api/blockChain/sendTransactions\n\nParameters​\nType\tName\tSchema\tDescription\tRequired\nBody\tinput\tSendTransactionsInput\t-\tNo\nResponses​\nHTTP Code\tDescription\tSchema\n200\tSuccess\t<string[]>\nConsumes​\napplication/json-patch+json; v=1.0\napplication/json; v=1.0\ntext/json; v=1.0\napplication/*+json; v=1.0\napplication/x-protobuf; v=1.0\nProduces​\ntext/plain; v=1.0\napplication/json; v=1.0\ntext/json; v=1.0\napplication/x-protobuf; v=1.0\nTags​\nBlockChain\nEstimate Transaction Fee​\nPOST /api/blockChain/calculateTransactionFee\n\nParameters​\nType\tName\tSchema\tDescription\tRequired\nBody\tinput\tCalculateTransactionFeeInput\t-\tNo\nResponses​\nHTTP Code\tDescription\tSchema\n200\tSuccess\tCalculateTransactionFeeOutput\nConsumes​\napplication/json-patch+json; v=1.0\napplication/json; v=1.0\ntext/json; v=1.0\napplication/*+json; v=1.0\napplication/x-protobuf; v=1.0\nProduces​\ntext/plain; v=1.0\napplication/json; v=1.0\ntext/json; v=1.0\napplication/x-protobuf; v=1.0\nTags​\nBlockChain\nGet the Current Status of a Transaction​\nGET /api/blockChain/transactionResult\n\nParameters​\nType\tName\tSchema\tDescription\tRequired\nQuery\ttransactionId\tstring\tTransaction ID\tNo\nResponses​\nHTTP Code\tDescription\tSchema\n200\tSuccess\tTransactionResultDto\nProduces​\ntext/plain; v=1.0\napplication/json; v=1.0\ntext/json; v=1.0\napplication/x-protobuf; v=1.0\nTags​\nBlockChain\nGet the Transaction Pool Status​\nGET /api/blockChain/transactionPoolStatus\n\nResponses​\nHTTP Code\tDescription\tSchema\n200\tSuccess\tGetTransactionPoolStatusOutput\nProduces​\ntext/plain; v=1.0\napplication/json; v=1.0\ntext/json; v=1.0\napplication/x-protobuf; v=1.0\nTags​\nBlockChain\nGet the Current Status of a Transaction​\nGET /api/blockChain/transactionResult\n\n\nParameters\n\nType\tName\tDescription\tSchema\nQuery\ttransactionId\tOptional. Transaction ID\tstring\nResponses​\nHTTP Code\tDescription\tSchema\n200\tSuccess\tTransactionResultDto\nProduces​\ntext/plain; v=1.0\napplication/json; v=1.0\ntext/json; v=1.0\napplication/x-protobuf; v=1.0\nTags​\nBlockChain\nGet Multiple Transaction Results​\nGET /api/blockChain/transactionResults\n\nParameters​\nType\tName\tDescription\tSchema\tDefault\nQuery\tblockHash\tOptional. Block hash\tstring\t\nQuery\tlimit\tOptional. Limit results\tinteger (int32)\t10\nQuery\toffset\tOptional. Offset for pagination\tinteger (int32)\t0\nResponses​\nHTTP Code\tDescription\tSchema\n200\tSuccess\tTransactionResultDto[]\nProduces​\ntext/plain; v=1.0\napplication/json; v=1.0\ntext/json; v=1.0\napplication/x-protobuf; v=1.0\nTags​\nBlockChain\nPrevious\nWeb API\nNext\nNet API\nGet information about a given block by block hash. Optionally with the list of its transactions.\nResponses\nProduces\nTags\nGet information about a given block by block height. Optionally with the list of its transactions.\nResponses\nProduces\nTags\nGet the height of the current chain.\nResponses\nProduces\nTags\nGet the current state about a given block.\nResponses\nProduces\nTags\nGet the current status of the block chain.\nResponses\nProduces\nTags\nGet the protobuf definitions related to a contract.\nResponses\nProduces\nTags\nExecute a raw transaction.\nParameters\nResponses\nConsumes\nProduces\nTags\nCall a read-only method on a contract.\nParameters\nResponses\nConsumes\nProduces\nTags\nGet the merkle path of a transaction.\nParameters\nResponses\nProduces\nTags\nCreates an unsigned serialized transaction.\nParameters\nResponses\nConsumes\nProduces\nTags\nSend a transaction.\nParameters\nResponses\nConsumes\nProduces\nTags\nBroadcast a Transaction\nParameters\nResponses\nConsumes\nProduces\nBroadcast Multiple Transactions\nParameters\nResponses\nConsumes\nProduces\nTags\nEstimate Transaction Fee\nParameters\nResponses\nConsumes\nProduces\nTags\nGet the Current Status of a Transaction\nParameters\nResponses\nProduces\nTags\nGet the Transaction Pool Status\nResponses\nProduces\nTags\nGet the Current Status of a Transaction\nResponses\nProduces\nTags\nGet Multiple Transaction Results\nParameters\nResponses\nProduces\nTags\nPlatform\nTechnology\nAudit Report\nPrivacy\nTerms of Use\nCookie Policy\nDeveloper Resources\nQuick Start\nLearn\nDocs\nTools\nResources\nEcosystem\nOverview\ndApps\naelf Ventures\nBlog\nConnect\nContact Us\nCopyright © 2024 aelf"
    },
    {
      "title": "Configuration Contract | AELF Docs",
      "url": "https://docs.aelf.com/docs/smart-contract-api/configuration-contract/",
      "html": "Skip to main content\nQuick Start\nLearn\nDocs\nTools\nResources\nBlog\nSearch\nK\nDocs Reference\nSmart Contract API\nAssociation Contract\nReferendum Contract\nParliament Contract\nConsensus Contract\nElection Contract\nGenesis Contract\nMulti Token Contract\nProfit Contract\nCross Chain Contract\nTreasury Contract\nVote Contract\nToken Holder Contract\nEconomic Contract\nToken Converter Contract\nConfiguration Contract\nWeb API\nDocs ReferenceSmart Contract APIConfiguration Contract\nConfiguration Contract\n\nUsed to manage the configuration on the blockchain. Implements aelf Standards ACS1.\n\nContract Methods​\nMethod Name\tRequest Type\tResponse Type\tDescription\nSetConfiguration\tConfiguration.SetConfigurationInput\tgoogle.protobuf.Empty\tAdd or update configuration.\nChangeConfigurationController\tAuthorityInfo\tgoogle.protobuf.Empty\tChange the method fee controller, the default is Parliament.\nGetConfiguration\tgoogle.protobuf.StringValue\tgoogle.protobuf.BytesValue\tQuery the configuration by configuration’s key.\nGetConfigurationController\tgoogle.protobuf.Empty\tAuthorityInfo\tQuery the controller information.\nAElf.Standards.ACS1​\nMethod Name\tRequest Type\tResponse Type\tDescription\nSetMethodFee\tacs1.MethodFees\tgoogle.protobuf.Empty\tSet the method fees for the specified method. Note that this will override all fees of the method.\nChangeMethodFeeController\tAuthorityInfo\tgoogle.protobuf.Empty\tChange the method fee controller, the default is parliament and default organization.\nGetMethodFee\tgoogle.protobuf.StringValue\tacs1.MethodFees\tQuery method fee information by method name.\nGetMethodFeeController\tgoogle.protobuf.Empty\tAuthorityInfo\tQuery the method fee controller.\n\nContract Types\n\nAElf.Contracts.Configuration​\nConfiguration.ConfigurationSet​\nField\tType\tDescription\tLabel\nkey\tstring\tThe configuration’s key.\t\nvalue\tbytes\tThe configuration’s value (binary data).\t\nConfiguration.SetConfigurationInput​\nField\tType\tDescription\tLabel\nkey\tstring\tThe configuration’s key.\t\nvalue\tbytes\tThe configuration’s value (binary data).\t\nAElf.Standards.ACS1​\nacs1.MethodFee​\nField\tType\tDescription\tLabel\nsymbol\tstring\tThe token symbol of the method fee.\t\nbasic_fee\tint64\tThe amount of fees to be charged.\t\nacs1.MethodFees​\nField\tType\tDescription\tLabel\nmethod_name\tstring\tThe name of the method to be charged.\t\nfees\tMethodFee\tList of fees to be charged.\trepeated\nis_size_fee_free\tbool\tOptional based on the implementation of SetMethodFee method.\t\nAElf.Types​\naelf.Address​\nField\tType\tDescription\tLabel\nvalue\tbytes\t\t\naelf.BinaryMerkleTree​\nField\tType\tDescription\tLabel\nnodes\tHash\tThe leaf nodes.\trepeated\nroot\tHash\tThe root node hash.\t\nleaf_count\tint32\tThe count of leaf node.\t\naelf.Hash​\nField\tType\tDescription\tLabel\nvalue\tbytes\t\t\naelf.LogEvent​\nField\tType\tDescription\tLabel\naddress\tAddress\tThe contract address.\t\nname\tstring\tThe name of the log event.\t\nindexed\tbytes\tThe indexed data, used to calculate bloom.\trepeated\nnon_indexed\tbytes\tThe non indexed data.\t\naelf.MerklePath​\nField\tType\tDescription\tLabel\nmerkle_path_nodes\tMerklePathNode\tThe merkle path nodes.\trepeated\naelf.MerklePathNode​\nField\tType\tDescription\tLabel\nhash\tHash\tThe node hash.\t\nis_left_child_node\tbool\tWhether it is a left child node.\t\naelf.SInt32Value​\nField\tType\tDescription\tLabel\nvalue\tsint32\t\t\naelf.SInt64Value​\nField\tType\tDescription\tLabel\nvalue\tsint64\t\t\naelf.ScopedStatePath​\nField\tType\tDescription\tLabel\naddress\tAddress\tThe scope address, which will be the contract address.\t\npath\tStatePath\tThe path of contract state.\t\naelf.SmartContractRegistration​\nField\tType\tDescription\tLabel\ncategory\tsint32\tThe category of contract code(0: C#).\t\ncode\tbytes\tThe byte array of the contract code.\t\ncode_hash\tHash\tThe hash of the contract code.\t\nis_system_contract\tbool\tWhether it is a system contract.\t\nversion\tint32\tThe version of the current contract.\t\naelf.StatePath​\nField\tType\tDescription\tLabel\nparts\tstring\tThe partial path of the state path.\trepeated\naelf.Transaction​\nField\tType\tDescription\tLabel\nfrom\tAddress\tThe address of the sender of the transaction.\t\nto\tAddress\tThe address of the contract when calling a contract.\t\nref_block_number\t[int64]\tThe height of the referenced block hash.\t\nref_block_prefix\tbytes\tThe first four bytes of the referenced block hash.\t\nmethod_name\tstring\tThe name of a method in the smart contract at the To address.\t\nparams\tbytes\tThe parameters to pass to the smart contract method.\t\nsignature\tbytes\tWhen signing a transaction it’s actually a subset of the fields: from/to and the target method as well as the parameter that were given. It also contains the reference block number and prefix.\t\naelf.TransactionExecutingStateSet​\nField\tType\tDescription\tLabel\nwrites\tTransactionExecutingStateSet.WritesEntry\tThe changed states.\trepeated\nreads\tTransactionExecutingStateSet.ReadsEntry\tThe read states.\trepeated\ndeletes\tTransactionExecutingStateSet.DeletesEntry\tThe deleted states.\trepeated\naelf.TransactionExecutingStateSet.DeletesEntry​\nField\tType\tDescription\tLabel\nkey\tstring\t\t\nvalue\tbool\t\t\naelf.TransactionExecutingStateSet.ReadsEntry​\nField\tType\tDescription\tLabel\nkey\tstring\t\t\nvalue\tbool\t\t\naelf.TransactionExecutingStateSet.WritesEntry​\nField\tType\tDescription\tLabel\nkey\tstring\t\t\nvalue\tbytes\t\t\naelf.TransactionResult​\nField\tType\tDescription\tLabel\ntransaction_id\tHash\tThe transaction id.\t\nstatus\t`TransactionResultStatus\tThe transaction result status.\t\nlogs\tLogEvent\tThe log events.\trepeated\nbloom\tbytes\tBloom filter for transaction logs. A transaction log event can be defined in the contract and stored in the bloom filter after the transaction is executed. Through this filter, we can quickly search for and determine whether a log exists in the transaction result.\t\nreturn_value\tbytes\tThe return value of the transaction execution.\t\nblock_number\tint64\tThe height of the block that packages the transaction.\t\nblock_hash\tHash\tThe hash of the block that packages the transaction.\t\nerror\tstring\tFailed execution error message.\t\naelf.TransactionResultStatus​\nName\tNumber\tDescription\nNOT_EXISTED\t0\tThe execution result of the transaction does not exist.\nPENDING\t1\tThe transaction is in the transaction pool waiting to be packaged.\nFAILED\t2\tTransaction execution failed.\nMINED\t3\tThe transaction was successfully executed and successfully packaged into a block.\nCONFLICT\t4\tWhen executed in parallel, there are conflicts with other transactions.\nPENDING_VALIDATION\t5\tThe transaction is waiting for validation.\nNODE_VALIDATION_FAILED\t6\tTransaction validation failed.\nAuthorityInfo​\nField\tType\tDescription\tLabel\ncontract_address\taelf.Address\tThe contract address of the controller.\t\nowner_address\taelf.Address\tThe address of the owner of the contract.\t\nPrevious\nToken Converter Contract\nNext\nWeb API\nContract Methods\nAElf.Standards.ACS1\nAElf.Contracts.Configuration\nConfiguration.ConfigurationSet\nConfiguration.SetConfigurationInput\nAElf.Standards.ACS1\nacs1.MethodFee\nacs1.MethodFees\nAElf.Types\naelf.Address\naelf.BinaryMerkleTree\naelf.Hash\naelf.LogEvent\naelf.MerklePath\naelf.MerklePathNode\naelf.SInt32Value\naelf.SInt64Value\naelf.ScopedStatePath\naelf.SmartContractRegistration\naelf.StatePath\naelf.Transaction\naelf.TransactionExecutingStateSet\naelf.TransactionExecutingStateSet.DeletesEntry\naelf.TransactionExecutingStateSet.ReadsEntry\naelf.TransactionExecutingStateSet.WritesEntry\naelf.TransactionResult\naelf.TransactionResultStatus\nAuthorityInfo\nPlatform\nTechnology\nAudit Report\nPrivacy\nTerms of Use\nCookie Policy\nDeveloper Resources\nQuick Start\nLearn\nDocs\nTools\nResources\nEcosystem\nOverview\ndApps\naelf Ventures\nBlog\nConnect\nContact Us\nCopyright © 2024 aelf"
    },
    {
      "title": "Token Converter Contract | AELF Docs",
      "url": "https://docs.aelf.com/docs/smart-contract-api/token-convert-contract/",
      "html": "Skip to main content\nQuick Start\nLearn\nDocs\nTools\nResources\nBlog\nSearch\nDocs Reference\nSmart Contract API\nAssociation Contract\nReferendum Contract\nParliament Contract\nConsensus Contract\nElection Contract\nGenesis Contract\nMulti Token Contract\nProfit Contract\nCross Chain Contract\nTreasury Contract\nVote Contract\nToken Holder Contract\nEconomic Contract\nToken Converter Contract\nConfiguration Contract\nWeb API\nDocs ReferenceSmart Contract APIToken Converter Contract\nToken Converter Contract\n\nUsing this contract can build a connection between the base token and other tokens created on the chain. After building the connection, users can trade tokens with the Bancor model. You can find detailed information about Bancor in the AElf Economic System White Paper. Implement aelf Standards ACS1.\n\nContract Methods​\nMethod Name\tRequest Type\tResponse Type\tDescription\nInitialize\tTokenConverter.InitializeInput\tgoogle.protobuf.Empty\tInitialize TokenConvert contract.\nSetConnector\tTokenConverter.Connector\tgoogle.protobuf.Empty\t\nBuy\tTokenConverter.BuyInput\tgoogle.protobuf.Empty\tAfter establishing Bancor model of token and base token, you can buy token through this method.\nSell\tTokenConverter.SellInput\tgoogle.protobuf.Empty\tAfter establishing Bancor model of token and base token, you can sell token through this method.\nSetFeeRate\tgoogle.protobuf.StringValue\tgoogle.protobuf.Empty\tSet the fee rate for buy/sell (fee amount = cost * feeRate).\nUpdateConnector\tTokenConverter.Connector\tgoogle.protobuf.Empty\tBefore calling the EnableConnector, the connector controller can update the pair connector through this method.\nAddPairConnector\tTokenConverter.PairConnectorParam\tgoogle.protobuf.Empty\tAdd a pair connector for new token and the base token.\nEnableConnector\tTokenConverter.ToBeConnectedTokenInfo\tgoogle.protobuf.Empty\tAfter adding a pair, you need to call this method to enable it before buying and selling tokens.\nChangeConnectorController\tAuthorityInfo\tgoogle.protobuf.Empty\tSet the governance authority information for TokenConvert contract.\nGetPairConnector\tTokenConverter.TokenSymbol\tTokenConverter.PairConnector\tQuery the pair connector according to token symbol.\nGetFeeRate\tgoogle.protobuf.Empty\tgoogle.protobuf.StringValue\tQuery the fee rate for buy/sell.\nGetBaseTokenSymbol\tgoogle.protobuf.Empty\tTokenConverter.TokenSymbol\tQuery the symbol of base token.\nGetNeededDeposit\tTokenConverter.ToBeConnectedTokenInfo\tTokenConverter.DepositInfo\tQuery how much the base token needs to be deposited before enabling the connector.\nGetDepositConnectorBalance\tgoogle.protobuf.StringValue\tgoogle.protobuf.Int64Value\tQuery how much the base token has been deposited.\nGetControllerForManageConnector\tgoogle.protobuf.Empty\tAuthorityInfo\tQuery the governance authority information for TokenConvert contract.\nIsSymbolAbleToSell\tgoogle.protobuf.StringValue\tgoogle.protobuf.BoolValue\tQuery whether the token can be sold.\nAElf.Standards.ACS1​\nMethod Name\tRequest Type\tResponse Type\tDescription\nSetMethodFee\tacs1.MethodFees\tgoogle.protobuf.Empty\tSet the method fees for the specified method. Note that this will override all fees of the method.\nChangeMethodFeeController\tAuthorityInfo\tgoogle.protobuf.Empty\tChange the method fee controller, the default is parliament and default organization.\nGetMethodFee\tgoogle.protobuf.StringValue\tacs1.MethodFees\tQuery method fee information by method name.\nGetMethodFeeController\tgoogle.protobuf.Empty\tAuthorityInfo\tQuery the method fee controller.\nContract Types\nAElf.Contracts.TokenConverter​\nTokenConverter.BuyInput​\nField\tType\tDescription\tLabel\nsymbol\tstring\tThe token symbol you want to buy.\t\namount\tint64\tThe amount you want to buy.\t\npay_limit\tint64\tLimit of cost. If the token required for buy exceeds this value, the buy will be abandoned. And 0 is no limit.\t\nTokenConverter.Connector​\nField\tType\tDescription\tLabel\nsymbol\tstring\tThe token symbol.\t\nvirtual_balance\tint64\tThe virtual balance for base token.\t\nweight\tstring\tThe calculated weight value for this Connector.\t\nis_virtual_balance_enabled\tbool\tWhether to use Virtual Balance.\t\nis_purchase_enabled\tbool\tWhether the connector is enabled.\t\nrelated_symbol\tstring\tIndicates its related connector, the pair connector includes a new created token connector and the base token connector.\t\nis_deposit_account\tbool\tIndicates if the connector is base token connector.\t\nTokenConverter.DepositInfo​\nField\tType\tDescription\tLabel\nneed_amount\tint64\tHow much more base Token is needed as the deposit.\t\namount_out_of_token_convert\tint64\tHow many tokens are not on the TokenConvert address.\t\nTokenConverter.InitializeInput​\nField\tType\tDescription\tLabel\nbase_token_symbol\tstring\tBase token symbol, default is the native token symbol.\t\nfee_rate\tstring\tThe fee rate for buy/sell.\t\nconnectors\tConnector\tThe default added connectors.\trepeated\nTokenConverter.PairConnector​\nField\tType\tDescription\tLabel\nresource_connector\tConnector\tThe connector of the specified token.\t\ndeposit_connector\tConnector\tThe related connector.\t\nTokenConverter.PairConnectorParam​\nField\tType\tDescription\tLabel\nresource_connector_symbol\tstring\tThe token symbol.\t\nresource_weight\tstring\tThe weight value of this token in the Bancor model.\t\nnative_virtual_balance\tint64\tThis token corresponds to the value of base token.\t\nnative_weight\tstring\tThe weight value of base token in Bancor model.\t\nTokenConverter.SellInput​\nField\tType\tDescription\tLabel\nsymbol\tstring\tThe token symbol you want to sell.\t\namount\tint64\tThe amount you want to sell.\t\nreceive_limit\tint64\tLimits on tokens obtained by selling. If the token obtained is less than this value, the sale will be abandoned. And 0 is no limit.\t\nTokenConverter.ToBeConnectedTokenInfo​\nField\tType\tDescription\tLabel\ntoken_symbol\tstring\tThe token symbol.\t\namount_to_token_convert\tint64\tSpecifies the number of tokens to convert to the TokenConvert contract.\t\nTokenConverter.TokenBought​\nField\tType\tDescription\tLabel\nsymbol\tstring\tThe token symbol bought.\t\nbought_amount\tint64\tThe amount bought.\t\nbase_amount\tint64\tThe total cost of the base token.\t\nfee_amount\tint64\tThe fee amount.\t\nTokenConverter.TokenSold​\nField\tType\tDescription\tLabel\nsymbol\tstring\tThe token symbol sold.\t\nsold_amount\tint64\tThe amount sold.\t\nbase_amount\tint64\tThe total received of the base token.\t\nfee_amount\tint64\tThe fee amount.\t\nTokenConverter.TokenSymbol​\nField\tType\tDescription\tLabel\nsymbol\tstring\tThe token symbol.\t\nAElf.Standards.ACS1​\nacs1.MethodFee​\nField\tType\tDescription\tLabel\nsymbol\tstring\tThe token symbol of the method fee.\t\nbasic_fee\tint64\tThe amount of fees to be charged.\t\nacs1.MethodFees​\nField\tType\tDescription\tLabel\nmethod_name\tstring\tThe name of the method to be charged.\t\nfees\tMethodFee\tList of fees to be charged.\trepeated\nis_size_fee_free\tbool\tOptional based on the implementation of SetMethodFee method.\t\nAElf.Types​\naelf.Address​\nField\tType\tDescription\tLabel\nvalue\tbytes\t\t\naelf.BinaryMerkleTree​\nField\tType\tDescription\tLabel\nnodes\tHash\tThe leaf nodes.\trepeated\nroot\tHash\tThe root node hash.\t\nleaf_count\tint32\tThe count of leaf node.\t\naelf.Hash​\nField\tType\tDescription\tLabel\nvalue\tbytes\t\t\naelf.LogEvent​\nField\tType\tDescription\tLabel\naddress\tAddress\tThe contract address.\t\nname\tstring\tThe name of the log event.\t\nindexed\tbytes\tThe indexed data, used to calculate bloom.\trepeated\nnon_indexed\tbytes\tThe non indexed data.\t\naelf.MerklePath​\nField\tType\tDescription\tLabel\nmerkle_path_nodes\tMerklePathNode\tThe merkle path nodes.\trepeated\naelf.MerklePathNode​\nField\tType\tDescription\tLabel\nhash\tHash\tThe node hash.\t\nis_left_child_node\tbool\tWhether it is a left child node.\t\naelf.SInt32Value​\nField\tType\tDescription\tLabel\nvalue\tsint32\t\t\naelf.SInt64Value​\nField\tType\tDescription\tLabel\nvalue\tsint64\t\t\naelf.ScopedStatePath​\nField\tType\tDescription\tLabel\naddress\tAddress\tThe scope address, which will be the contract address.\t\npath\tStatePath\tThe path of contract state.\t\naelf.SmartContractRegistration​\nField\tType\tDescription\tLabel\ncategory\tsint32\tThe category of contract code (0: C#).\t\ncode\tbytes\tThe byte array of the contract code.\t\ncode_hash\tHash\tThe hash of the contract code.\t\nis_system_contract\tbool\tWhether it is a system contract.\t\nversion\tint32\tThe version of the current contract.\t\naelf.StatePath​\nField\tType\tDescription\tLabel\nparts\tstring\tThe partial path of the state path.\trepeated\naelf.Transaction​\nField\tType\tDescription\tLabel\nfrom\tAddress\tThe address of the sender of the transaction.\t\nto\tAddress\tThe address of the contract when calling a contract.\t\nref_block_number\tint64\tThe height of the referenced block hash.\t\nref_block_prefix\tbytes\tThe first four bytes of the referenced block hash.\t\nmethod_name\tstring\tThe name of a method in the smart contract at the To address.\t\nparams\tbytes\tThe parameters to pass to the smart contract method.\t\nsignature\tbytes\tWhen signing a transaction it’s actually a subset of the fields: from/to and the target method as well as the parameter that were given. It also contains the reference block number and prefix.\t\naelf.TransactionExecutingStateSet​\nField\tType\tDescription\tLabel\nwrites\tTransactionExecutingStateSet.WritesEntry\tThe changed states.\trepeated\nreads\tTransactionExecutingStateSet.ReadsEntry\tThe read states.\trepeated\ndeletes\tTransactionExecutingStateSet.DeletesEntry\tThe deleted states.\trepeated\naelf.TransactionExecutingStateSet.DeletesEntry​\nField\tType\tDescription\tLabel\nkey\tstring\t\t\nvalue\tbool\t\t\naelf.TransactionExecutingStateSet.ReadsEntry​\nField\tType\tDescription\tLabel\nkey\tstring\t\t\nvalue\tbool\t\t\naelf.TransactionExecutingStateSet.WritesEntry​\nField\tType\tDescription\tLabel\nkey\tstring\t\t\nvalue\tbytes\t\t\naelf.TransactionResult​\nField\tType\tDescription\tLabel\ntransaction_id\tHash\tThe transaction id.\t\nstatus\tTransactionResultStatus\tThe transaction result status.\t\nlogs\tLogEvent\tThe log events.\trepeated\nbloom\tbytes\tBloom filter for transaction logs. A transaction log event can be defined in the contract and stored in the bloom filter after the transaction is executed. Through this filter, we can quickly search for and determine whether a log exists in the transaction result.\t\nreturn_value\tbytes\tThe return value of the transaction execution.\t\nblock_number\tint64\tThe height of the block hat packages the transaction.\t\nblock_hash\tHash\tThe hash of the block hat packages the transaction.\t\nerror\tstring\tFailed execution error message.\t\naelf.TransactionResultStatus​\nName\tNumber\tDescription\nNOT_EXISTED\t0\tThe execution result of the transaction does not exist.\nPENDING\t1\tThe transaction is in the transaction pool waiting to be packaged.\nFAILED\t2\tTransaction execution failed.\nMINED\t3\tThe transaction was successfully executed and successfully packaged into a block.\nCONFLICT\t4\tWhen executed in parallel, there are conflicts with other transactions.\nPENDING_VALIDATION\t5\tThe transaction is waiting for validation.\nNODE_VALIDATION_FAILED\t6\tTransaction validation failed.\nAuthorityInfo​\nField\tType\tDescription\tLabel\ncontract_address\taelf.Address\tThe contract address of the controller.\t\nowner_address\taelf.Address\tThe address of the owner of the contract.\t\nPrevious\nEconomic Contract\nNext\nConfiguration Contract\nContract Methods\nAElf.Standards.ACS1\nAElf.Contracts.TokenConverter\nTokenConverter.BuyInput\nTokenConverter.Connector\nTokenConverter.DepositInfo\nTokenConverter.InitializeInput\nTokenConverter.PairConnector\nTokenConverter.PairConnectorParam\nTokenConverter.SellInput\nTokenConverter.ToBeConnectedTokenInfo\nTokenConverter.TokenBought\nTokenConverter.TokenSold\nTokenConverter.TokenSymbol\nAElf.Standards.ACS1\nacs1.MethodFee\nacs1.MethodFees\nAElf.Types\naelf.Address\naelf.BinaryMerkleTree\naelf.Hash\naelf.LogEvent\naelf.MerklePath\naelf.MerklePathNode\naelf.SInt32Value\naelf.SInt64Value\naelf.ScopedStatePath\naelf.SmartContractRegistration\naelf.StatePath\naelf.Transaction\naelf.TransactionExecutingStateSet\naelf.TransactionExecutingStateSet.DeletesEntry\naelf.TransactionExecutingStateSet.ReadsEntry\naelf.TransactionExecutingStateSet.WritesEntry\naelf.TransactionResult\naelf.TransactionResultStatus\nAuthorityInfo\nPlatform\nTechnology\nAudit Report\nPrivacy\nTerms of Use\nCookie Policy\nDeveloper Resources\nQuick Start\nLearn\nDocs\nTools\nResources\nEcosystem\nOverview\ndApps\naelf Ventures\nBlog\nConnect\nContact Us\nCopyright © 2024 aelf"
    },
    {
      "title": "Economic Contract | AELF Docs",
      "url": "https://docs.aelf.com/docs/smart-contract-api/economic-contract/",
      "html": "Skip to main content\nQuick Start\nLearn\nDocs\nTools\nResources\nBlog\nSearch\nDocs Reference\nSmart Contract API\nAssociation Contract\nReferendum Contract\nParliament Contract\nConsensus Contract\nElection Contract\nGenesis Contract\nMulti Token Contract\nProfit Contract\nCross Chain Contract\nTreasury Contract\nVote Contract\nToken Holder Contract\nEconomic Contract\nToken Converter Contract\nConfiguration Contract\nWeb API\nDocs ReferenceSmart Contract APIEconomic Contract\nEconomic Contract\n\nThe Economic contract establishes the economic system of the aelf. When the blockchain starts to work, this contract will initialize other contracts related to economic activities. Implements aelf Standards ACS1.\n\nContract Methods​\nMethod Name\tRequest Type\tResponse Type\tDescription\nIssueNativeToken\tEconomic.IssueNativeTokenInput\tgoogle.protobuf.Empty\tOnly ZeroContract is able to issue the native token.\nInitialEconomicSystem\tEconomic.InitialEconomicSystemInput\tgoogle.protobuf.Empty\tIt will initialize other contracts related to economic activities (For instance, create the native token). This transaction only can be sent once because after the first sending, its state will be set to initialized.\nAElf.Standards.ACS1​\nMethod Name\tRequest Type\tResponse Type\tDescription\nSetMethodFee\tacs1.MethodFees\tgoogle.protobuf.Empty\tSet the method fees for the specified method. Note that this will override all fees of the method.\nChangeMethodFeeController\tAuthorityInfo\tgoogle.protobuf.Empty\tChange the method fee controller, the default is parliament and default organization.\nGetMethodFee\tgoogle.protobuf.StringValue\tacs1.MethodFees\tQuery method fee information by method name.\nGetMethodFeeController\tgoogle.protobuf.Empty\tAuthorityInfo\tQuery the method fee controller.\n\nContract Types\n\nAElf.Contracts.Economic​\nEconomic.InitialEconomicSystemInput​\nField\tType\tDescription\tLabel\nnative_token_symbol\tstring\tThe native token symbol.\t\nnative_token_name\tstring\tThe native token name.\t\nnative_token_total_supply\tint64\tThe native token total supply.\t\nnative_token_decimals\tint32\tThe accuracy of the native token.\t\nis_native_token_burnable\tbool\tIt indicates if the token is burnable.\t\nmining_reward_total_amount\tint64\tIt determines how much native token is used to reward the miners.\t\ntransaction_size_fee_unit_price\tint64\ttodo: remove unused fields\t\nEconomic.IssueNativeTokenInput​\nField\tType\tDescription\tLabel\namount\tint64\tThe amount of token.\t\nmemo\tstring\tThe memo.\t\nto\taelf.Address\tThe recipient of the token.\t\nEconomic.IssueResourceTokenInput​\nField\tType\tDescription\tLabel\nsymbol\tstring\tThe symbol of resource token.\t\namount\tint64\tThe amount of resource token.\t\nmemo\tstring\tThe memo.\t\nto\taelf.Address\tThe recipient of the token.\t\nAElf.Standards.ACS1​\nacs1.MethodFee​\nField\tType\tDescription\tLabel\nsymbol\tstring\tThe token symbol of the method fee.\t\nbasic_fee\tint64\tThe amount of fees to be charged.\t\nacs1.MethodFees​\nField\tType\tDescription\tLabel\nmethod_name\tstring\tThe name of the method to be charged.\t\nfees\tMethodFee\tList of fees to be charged.\trepeated\nis_size_fee_free\tbool\tOptional based on the implementation of SetMethodFee method.\t\nAElf.Types​\naelf.Address​\nField\tType\tDescription\tLabel\nvalue\tbytes\t\t\naelf.BinaryMerkleTree​\nField\tType\tDescription\tLabel\nnodes\tHash\tThe leaf nodes.\trepeated\nroot\tHash\tThe root node hash.\t\nleaf_count\tint32\tThe count of leaf node.\t\naelf.Hash​\nField\tType\tDescription\tLabel\nvalue\tbytes\t\t\naelf.LogEvent​\nField\tType\tDescription\tLabel\naddress\tAddress\tThe contract address.\t\nname\tstring\tThe name of the log event.\t\nindexed\tbytes\tThe indexed data, used to calculate bloom.\trepeated\nnon_indexed\tbytes\tThe non indexed data.\t\naelf.MerklePath​\nField\tType\tDescription\tLabel\nmerkle_path_nodes\tMerklePathNode\tThe merkle path nodes.\trepeated\naelf.MerklePathNode​\nField\tType\tDescription\tLabel\nhash\tHash\tThe node hash.\t\nis_left_child_node\tbool\tWhether it is a left child node.\t\naelf.SInt32Value​\nField\tType\tDescription\tLabel\nvalue\tsint32\t\t\naelf.SInt64Value​\nField\tType\tDescription\tLabel\nvalue\tsint64\t\t\naelf.ScopedStatePath​\nField\tType\tDescription\tLabel\naddress\tAddress\tThe scope address, which will be the contract address.\t\npath\tStatePath\tThe path of contract state.\t\naelf.SmartContractRegistration​\nField\tType\tDescription\tLabel\ncategory\tsint32\tThe category of contract code(0: C#).\t\ncode\tbytes\tThe byte array of the contract code.\t\ncode_hash\tHash\tThe hash of the contract code.\t\nis_system_contract\tbool\tWhether it is a system contract.\t\nversion\tint32\tThe version of the current contract.\t\naelf.StatePath​\nField\tType\tDescription\tLabel\nparts\tstring\tThe partial path of the state path.\trepeated\naelf.Transaction​\nField\tType\tDescription\tLabel\nfrom\tAddress\tThe address of the sender of the transaction.\t\nto\tAddress\tThe address of the contract when calling a contract.\t\nref_block_number\tint64\tThe height of the referenced block hash.\t\nref_block_prefix\tbytes\tThe first four bytes of the referenced block hash.\t\nmethod_name\tstring\tThe name of a method in the smart contract at the To address.\t\nparams\tbytes\tThe parameters to pass to the smart contract method.\t\nsignature\tbytes\tWhen signing a transaction it’s actually a subset of the fields: from/to and the target method as well as the parameter that were given. It also contains the reference block number and prefix.\t\naelf.TransactionExecutingStateSet​\nField\tType\tDescription\tLabel\nwrites\tTransactionExecutingStateSet.WritesEntry\tThe changed states.\trepeated\nreads\tTransactionExecutingStateSet.ReadsEntry\tThe read states.\trepeated\ndeletes\tTransactionExecutingStateSet.DeletesEntry\tThe deleted states.\trepeated\naelf.TransactionExecutingStateSet.DeletesEntry​\nField\tType\tDescription\tLabel\nkey\tstring\t\t\nvalue\tbool\t\t\naelf.TransactionExecutingStateSet.ReadsEntry​\nField\tType\tDescription\tLabel\nkey\tstring\t\t\nvalue\tbool\t\t\naelf.TransactionExecutingStateSet.WritesEntry​\nField\tType\tDescription\tLabel\nkey\tstring\t\t\nvalue\tbytes\t\t\naelf.TransactionResult​\nField\tType\tDescription\tLabel\ntransaction_id\tHash\tThe transaction id.\t\nstatus\tTransactionResultStatus\tThe transaction result status.\t\nlogs\tLogEvent\tThe log events.\trepeated\nbloom\tbytes\tBloom filter for transaction logs. A transaction log event can be defined in the contract and stored in the bloom filter after the transaction is executed. Through this filter, we can quickly search for and determine whether a log exists in the transaction result.\t\nreturn_value\tbytes\tThe return value of the transaction execution.\t\nblock_number\tint64\tThe height of the block hat packages the transaction.\t\nblock_hash\tHash\tThe hash of the block hat packages the transaction.\t\nerror\tstring\tFailed execution error message.\t\naelf.TransactionResultStatus​\nName\tNumber\tDescription\nNOT_EXISTED\t0\tThe execution result of the transaction does not exist.\nPENDING\t1\tThe transaction is in the transaction pool waiting to be packaged.\nFAILED\t2\tTransaction execution failed.\nMINED\t3\tThe transaction was successfully executed and successfully packaged into a block.\nCONFLICT\t4\tWhen executed in parallel, there are conflicts with other transactions.\nPENDING_VALIDATION\t5\tThe transaction is waiting for validation.\nNODE_VALIDATION_FAILED\t6\tTransaction validation failed.\nAuthorityInfo​\nField\tType\tDescription\tLabel\ncontract_address\taelf.Address\tThe contract address of the controller.\t\nowner_address\taelf.Address\tThe address of the owner of the contract.\t\nPrevious\nToken Holder Contract\nNext\nToken Converter Contract\nContract Methods\nAElf.Standards.ACS1\nAElf.Contracts.Economic\nEconomic.InitialEconomicSystemInput\nEconomic.IssueNativeTokenInput\nEconomic.IssueResourceTokenInput\nAElf.Standards.ACS1\nacs1.MethodFee\nacs1.MethodFees\nAElf.Types\naelf.Address\naelf.BinaryMerkleTree\naelf.Hash\naelf.LogEvent\naelf.MerklePath\naelf.MerklePathNode\naelf.SInt32Value\naelf.SInt64Value\naelf.ScopedStatePath\naelf.SmartContractRegistration\naelf.StatePath\naelf.Transaction\naelf.TransactionExecutingStateSet\naelf.TransactionExecutingStateSet.DeletesEntry\naelf.TransactionExecutingStateSet.ReadsEntry\naelf.TransactionExecutingStateSet.WritesEntry\naelf.TransactionResult\naelf.TransactionResultStatus\nAuthorityInfo\nPlatform\nTechnology\nAudit Report\nPrivacy\nTerms of Use\nCookie Policy\nDeveloper Resources\nQuick Start\nLearn\nDocs\nTools\nResources\nEcosystem\nOverview\ndApps\naelf Ventures\nBlog\nConnect\nContact Us\nCopyright © 2024 aelf"
    },
    {
      "title": "Token Holder Contract | AELF Docs",
      "url": "https://docs.aelf.com/docs/smart-contract-api/token-holder-contract/",
      "html": "Skip to main content\nQuick Start\nLearn\nDocs\nTools\nResources\nBlog\nSearch\nDocs Reference\nSmart Contract API\nAssociation Contract\nReferendum Contract\nParliament Contract\nConsensus Contract\nElection Contract\nGenesis Contract\nMulti Token Contract\nProfit Contract\nCross Chain Contract\nTreasury Contract\nVote Contract\nToken Holder Contract\nEconomic Contract\nToken Converter Contract\nConfiguration Contract\nWeb API\nDocs ReferenceSmart Contract APIToken Holder Contract\nTokenHolder Contract\n\nUsed to build a bonus model for distributing bonuses to those who hold the token. Implement aelf Standards ACS1.\n\nContract Methods​\nMethod Name\tRequest Type\tResponse Type\tDescription\nCreateScheme\tTokenHolder.CreateTokenHolderProfitSchemeInput\tgoogle.protobuf.Empty <#google.protobuf.Empty>\tCreate a scheme for distributing bonuses.\nAddBeneficiary\tTokenHolder.AddTokenHolderBeneficiaryInput\tgoogle.protobuf.Empty <#google.protobuf.Empty>\tAdd a beneficiary to a scheme.\nRemoveBeneficiary\tTokenHolder.RemoveTokenHolderBeneficiaryInput\tgoogle.protobuf.Empty <#google.protobuf.Empty>\tRemoves a beneficiary from a scheme. Note: amount > 0: update the weight of the beneficiary, amount = 0: remove the beneficiary.\nContributeProfits\tTokenHolder.ContributeProfitsInput\tgoogle.protobuf.Empty <#google.protobuf.Empty>\tContribute profit to a scheme.\nDistributeProfits\tTokenHolder.DistributeProfitsInput\tgoogle.protobuf.Empty <#google.protobuf.Empty>\tTo distribute the profits of the scheme, the stakeholders of the project may go to receive dividends.\nRegisterForProfits\tTokenHolder.RegisterForProfitsInput\tgoogle.protobuf.Empty <#google.protobuf.Empty>\tThe user registers a bonus project.\nWithdraw\taelf.Address\tgoogle.protobuf.Empty <#google.protobuf.Empty>\tAfter the lockup time expires, the user can withdraw tokens.\nClaimProfits\tTokenHolder.ClaimProfitsInput\tgoogle.protobuf.Empty <#google.protobuf.Empty>\tAfter DistributeProfits, the holder can get his dividend.\nGetScheme\taelf.Address\tTokenHolder.TokenHolderProfitScheme\tQuery the details of the specified scheme.\nGetProfitsMap\tTokenHolder.ClaimProfitsInput\tTokenHolder.ReceivedProfitsMap\tQuery the dividends available to the holder.\nAElf.Standards.ACS1​\nMethod Name\tRequest Type\tResponse Type\tDescription\nSetMethodFee\tacs1.MethodFees\tgoogle.protobuf.Empty <#google.protobuf.Empty>\tSet the method fees for the specified method. Note that this will override all fees of the method.\nChangeMethodFeeController\tAuthorityInfo <#AuthorityInfo>\tgoogle.protobuf.Empty <#google.protobuf.Empty>\tChange the method fee controller, the default is parliament and default organization.\nGetMethodFee\tgoogle.protobuf.StringValue <#google.protobuf.StringValue>\tacs1.MethodFees <#acs1.MethodFees>\tQuery method fee information by method name.\nGetMethodFeeController\tgoogle.protobuf.Empty <#google.protobuf.Empty>\tAuthorityInfo <#AuthorityInfo>\tQuery the method fee controller.\n\nContract Types\n\nAElf.Contracts.TokenHolder​\nTokenHolder.AddTokenHolderBeneficiaryInput​\nField\tType\tDescription\tLabel\nbeneficiary\taelf.Address\tBeneficiary's address.\t\nshares\tint64\tThe weight of the beneficiary's dividends in the scheme.\t\nTokenHolder.ClaimProfitsInput​\nField\tType\tDescription\tLabel\nscheme_manager\taelf.Address\tThe manager of the scheme.\t\nbeneficiary\taelf.Address\t\t\nTokenHolder.ContributeProfitsInput​\nField\tType\tDescription\tLabel\nscheme_manager\taelf.Address\tThe manager of the scheme.\t\namount\tint64\tThe amount of token to contribute.\t\nsymbol\tstring\tThe symbol of token to contribute.\t\nTokenHolder.CreateTokenHolderProfitSchemeInput​\nField\tType\tDescription\tLabel\nsymbol\tstring\tThe token symbol.\t\nminimum_lock_minutes\tint64\tMinimum lock time for holding token.\t\nauto_distribute_threshold\tCreateTokenHolderProfitSchemeInput.AutoDistributeThresholdEntry\tThreshold setting for releasing dividends.\trepeated\nTokenHolder.CreateTokenHolderProfitSchemeInput.AutoDistributeThresholdEntry​\nField\tType\tDescription\tLabel\nkey\tstring\t\t\nvalue\tint64\t\t\nTokenHolder.DistributeProfitsInput​\nField\tType\tDescription\tLabel\nscheme_manager\taelf.Address\tThe manager of the scheme.\t\namounts_map\tDistributeProfitsInput.AmountsMapEntry\tThe token to distribute, symbol -> amount.\trepeated\nTokenHolder.DistributeProfitsInput.AmountsMapEntry​\nField\tType\tDescription\tLabel\nkey\tstring\t\t\nvalue\tint64\t\t\nTokenHolder.ReceivedProfitsMap​\nField\tType\tDescription\tLabel\nvalue\tReceivedProfitsMap.ValueEntry\tThe amount of token the beneficiary can get, symbol -> amount.\trepeated\nTokenHolder.ReceivedProfitsMap.ValueEntry​\nField\tType\tDescription\tLabel\nkey\tstring\t\t\nvalue\tint64\t\t\nTokenHolder.RegisterForProfitsInput​\nField\tType\tDescription\tLabel\nscheme_manager\taelf.Address\tThe manager of the scheme.\t\namount\tint64\tThe amount of token holding.\t\nTokenHolder.RemoveTokenHolderBeneficiaryInput​\nField\tType\tDescription\tLabel\nbeneficiary\taelf.Address\tBeneficiary's address.\t\namount\tint64\tThe amount of weights to remove.\t\nTokenHolder.TokenHolderProfitScheme​\nField\tType\tDescription\tLabel\nsymbol\tstring\tThe token symbol.\t\nscheme_id\taelf.Hash\tThe scheme id.\t\nperiod\tint64\tThe current dividend period.\t\nminimum_lock_minutes\tint64\tMinimum lock time for holding token.\t\nauto_distribute_threshold\tTokenHolderProfitScheme.AutoDistributeThresholdEntry\tThreshold setting for releasing dividends.\trepeated\nTokenHolder.TokenHolderProfitScheme.AutoDistributeThresholdEntry​\nField\tType\tDescription\tLabel\nkey\tstring\t\t\nvalue\tint64\t\t\nAElf.Standards.ACS1​\nacs1.MethodFee​\nField\tType\tDescription\tLabel\nsymbol\tstring\tThe token symbol of the method fee.\t\nbasic_fee\tint64\tThe amount of fees to be charged.\t\nacs1.MethodFees​\nField\tType\tDescription\tLabel\nmethod_name\tstring\tThe name of the method to be charged.\t\nfees\tMethodFee\tList of fees to be charged.\trepeated\nis_size_fee_free\tbool\tOptional based on the implementation of SetMethodFee method.\t\nAElf.Types​\naelf.Address​\nField\tType\tDescription\tLabel\nvalue\tbytes\t\t\naelf.BinaryMerkleTree​\nField\tType\tDescription\tLabel\nnodes\tHash\tThe leaf nodes.\trepeated\nroot\tHash\tThe root node hash.\t\nleaf_count\tint32\tThe count of leaf node.\t\naelf.Hash​\nField\tType\tDescription\tLabel\nvalue\tbytes\t\t\naelf.LogEvent​\nField\tType\tDescription\tLabel\naddress\tAddress\tThe contract address.\t\nname\tstring\tThe name of the log event.\t\nindexed\tbytes\tThe indexed data, used to calculate bloom.\trepeated\nnon_indexed\tbytes\tThe non indexed data.\t\naelf.MerklePath​\nField\tType\tDescription\tLabel\nmerkle_path_nodes\tMerklePathNode <#aelf.MerklePathNode>\tThe merkle path nodes.\trepeated\naelf.MerklePathNode​\nField\tType\tDescription\tLabel\nhash\tHash\tThe node hash.\t\nis_left_child_node\tbool\tWhether it is a left child node.\t\naelf.SInt32Value​\nField\tType\tDescription\tLabel\nvalue\tsint32\t\t\naelf.SInt64Value​\nField\tType\tDescription\tLabel\nvalue\tsint64\t\t\naelf.ScopedStatePath​\nField\tType\tDescription\tLabel\naddress\tAddress\tThe scope address, which will be the contract address.\t\npath\tStatePath\tThe path of contract state.\t\naelf.SmartContractRegistration​\nField\tType\tDescription\tLabel\ncategory\tsint32\tThe category of contract code (0: C#).\t\ncode\tbytes\tThe byte array of the contract code.\t\ncode_hash\tHash\tThe hash of the contract code.\t\nis_system_contract\tbool\tWhether it is a system contract.\t\nversion\tint32\tThe version of the current contract.\t\naelf.StatePath​\nField\tType\tDescription\tLabel\nparts\tstring\tThe partial path of the state path.\trepeated\naelf.Transaction​\nField\tType\tDescription\tLabel\nfrom\tAddress\tThe address of the sender of the transaction.\t\nto\tAddress\tThe address of the contract when calling a contract.\t\nref_block_number\tint64\tThe height of the referenced block hash.\t\nref_block_prefix\tbytes\tThe first four bytes of the referenced block hash.\t\nmethod_name\tstring\tThe name of a method in the smart contract at the To address.\t\nparams\tbytes\tThe parameters to pass to the smart contract method.\t\nsignature\tbytes\tWhen signing a transaction it’s actually a subset of the fields: from/to and the target method as well as the parameter that were given. It also contains the reference block number and prefix.\t\naelf.TransactionExecutingStateSet​\nField\tType\tDescription\tLabel\nwrites\tTransactionExecutingStateSet.WritesEntry\tThe changed states.\trepeated\nreads\tTransactionExecutingStateSet.ReadsEntry\tThe read states.\trepeated\ndeletes\tTransactionExecutingStateSet.DeletesEntry\tThe deleted states.\trepeated\naelf.TransactionExecutingStateSet.DeletesEntry​\nField\tType\tDescription\tLabel\nkey\tstring\t\t\nvalue\tbool\t\t\naelf.TransactionExecutingStateSet.ReadsEntry​\nField\tType\tDescription\tLabel\nkey\tstring\t\t\nvalue\tbool\t\t\naelf.TransactionExecutingStateSet.WritesEntry​\nField\tType\tDescription\tLabel\nkey\tstring\t\t\nvalue\tbytes\t\t\naelf.TransactionResult​\nField\tType\tDescription\tLabel\ntransaction_id\tHash\tThe transaction id.\t\nstatus\tTransactionResultStatus\tThe transaction result status.\t\nlogs\tLogEvent\tThe log events.\trepeated\nbloom\tbytes\tBloom filter for transaction logs. A transaction log event can be defined in the contract and stored in the bloom filter after the transaction is executed. Through this filter, we can quickly search for and determine whether a log exists in the transaction result.\t\nreturn_value\tbytes\tThe return value of the transaction execution.\t\nblock_number\tint64\tThe height of the block that packages the transaction.\t\nblock_hash\tHash\tThe hash of the block that packages the transaction.\t\nerror\tstring\tFailed execution error message.\t\naelf.TransactionResultStatus​\nName\tNumber\tDescription\nNOT_EXISTED\t0\tThe execution result of the transaction does not exist.\nPENDING\t1\tThe transaction is in the transaction pool waiting to be packaged.\nFAILED\t2\tTransaction execution failed.\nMINED\t3\tThe transaction was successfully executed and successfully packaged into a block.\nCONFLICT\t4\tWhen executed in parallel, there are conflicts with other transactions.\nPENDING_VALIDATION\t5\tThe transaction is waiting for validation.\nNODE_VALIDATION_FAILED\t6\tTransaction validation failed.\nAuthorityInfo​\nField\tType\tDescription\tLabel\ncontract_address\taelf.Address\tThe contract address of the controller.\t\nowner_address\taelf.Address\tThe address of the owner of the contract.\t\nPrevious\nVote Contract\nNext\nEconomic Contract\nContract Methods\nAElf.Standards.ACS1\nAElf.Contracts.TokenHolder\nTokenHolder.AddTokenHolderBeneficiaryInput\nTokenHolder.ClaimProfitsInput\nTokenHolder.ContributeProfitsInput\nTokenHolder.CreateTokenHolderProfitSchemeInput\nTokenHolder.CreateTokenHolderProfitSchemeInput.AutoDistributeThresholdEntry\nTokenHolder.DistributeProfitsInput\nTokenHolder.DistributeProfitsInput.AmountsMapEntry\nTokenHolder.ReceivedProfitsMap\nTokenHolder.ReceivedProfitsMap.ValueEntry\nTokenHolder.RegisterForProfitsInput\nTokenHolder.RemoveTokenHolderBeneficiaryInput\nTokenHolder.TokenHolderProfitScheme\nTokenHolder.TokenHolderProfitScheme.AutoDistributeThresholdEntry\nAElf.Standards.ACS1\nacs1.MethodFee\nacs1.MethodFees\nAElf.Types\naelf.Address\naelf.BinaryMerkleTree\naelf.Hash\naelf.LogEvent\naelf.MerklePath\naelf.MerklePathNode\naelf.SInt32Value\naelf.SInt64Value\naelf.ScopedStatePath\naelf.SmartContractRegistration\naelf.StatePath\naelf.Transaction\naelf.TransactionExecutingStateSet\naelf.TransactionExecutingStateSet.DeletesEntry\naelf.TransactionExecutingStateSet.ReadsEntry\naelf.TransactionExecutingStateSet.WritesEntry\naelf.TransactionResult\naelf.TransactionResultStatus\nAuthorityInfo\nPlatform\nTechnology\nAudit Report\nPrivacy\nTerms of Use\nCookie Policy\nDeveloper Resources\nQuick Start\nLearn\nDocs\nTools\nResources\nEcosystem\nOverview\ndApps\naelf Ventures\nBlog\nConnect\nContact Us\nCopyright © 2024 aelf"
    },
    {
      "title": "AELF Docs",
      "url": "https://docs.aelf.com/docs/smart-contract-api/vote-contract/",
      "html": "Skip to main content\nQuick Start\nLearn\nDocs\nTools\nResources\nBlog\nSearch\nDocs Reference\nSmart Contract API\nAssociation Contract\nReferendum Contract\nParliament Contract\nConsensus Contract\nElection Contract\nGenesis Contract\nMulti Token Contract\nProfit Contract\nCross Chain Contract\nTreasury Contract\nVote Contract\nToken Holder Contract\nEconomic Contract\nToken Converter Contract\nConfiguration Contract\nWeb API\nDocs ReferenceSmart Contract APIVote Contract\nVote Contract\n\nThe Vote contract is an abstract layer for voting. Developers implement concrete voting activities by calling this contract. Implements aelf Standards ACS1.\n\nContract Methods​\nMethod Name\tRequest Type\tResponse Type\tDescription\nRegister\tVote.VotingRegisterInput\tgoogle.protobuf.Empty <#google.protobuf.Empty>\tCreate a voting activity.\nVote\tVote.VoteInput\tgoogle.protobuf.Empty <#google.protobuf.Empty>\tAfter successfully creating a voting activity, others are able to vote.\nWithdraw\tVote.WithdrawInput\tgoogle.protobuf.Empty <#google.protobuf.Empty>\tA voter can withdraw the token after the lock time.\nTakeSnapshot\tVote.TakeSnapshotInput\tgoogle.protobuf.Empty <#google.protobuf.Empty>\tSave the result of the specified number of votes and generates a new round of votes.\nAddOption\tVote.AddOptionInput\tgoogle.protobuf.Empty <#google.protobuf.Empty>\tAdd an option to a voting activity.\nRemoveOption\tVote.RemoveOptionInput\tgoogle.protobuf.Empty <#google.protobuf.Empty>\tRemove an option from a voting activity.\nAddOptions\tVote.AddOptionsInput\tgoogle.protobuf.Empty <#google.protobuf.Empty>\tAdd multiple options to a voting activity.\nRemoveOptions\tVote.RemoveOptionsInput\tgoogle.protobuf.Empty <#google.protobuf.Empty>\tRemove multiple options from a voting activity.\nGetVotingItem\tVote.GetVotingItemInput\tVote.VotingItem\tGet a voting activity information.\nGetVotingResult\tVote.GetVotingResultInput\tVote.VotingResult\tGet a voting result according to the provided voting activity id and snapshot number.\nGetLatestVotingResult\taelf.Hash\tVote.VotingResult\tGets the latest result according to the voting activity id.\nGetVotingRecord\taelf.Hash\tVote.VotingRecord\tGet the voting record according to vote id.\nGetVotingRecords\tVote.GetVotingRecordsInput\tVote.VotingRecords <#Vote.VotingRecords>\tGet the voting record according to vote ids.\nGetVotedItems\taelf.Address\tVote.VotedItems <#Vote.VotedItems>\tGet all voted information according to voter address.\nGetVotingIds\tVote.GetVotingIdsInput\tVote.VotedIds\tGet the vote ids according to voting activity id.\nAElf.Standards.ACS1​\nMethod Name\tRequest Type\tResponse Type\tDescription\nSetMethodFee\tacs1.MethodFees\tgoogle.protobuf.Empty\tSet the method fees for the specified method. Note that this will override all fees of the method.\nChangeMethodFeeController\tAuthorityInfo\tgoogle.protobuf.Empty\tChange the method fee controller, the default is parliament and default organization.\nGetMethodFee\tgoogle.protobuf.StringValue\tacs1.MethodFees\tQuery method fee information by method name.\nGetMethodFeeController\tgoogle.protobuf.Empty\tAuthorityInfo\tQuery the method fee controller.\n\nContract Types\n\nAElf.Contracts.Vote​\nVote.AddOptionInput​\nField\tType\tDescription\tLabel\nvoting_item_id\taelf.Hash\tThe voting activity id.\t\noption\tstring\tThe new option to add.\t\nVote.AddOptionsInput​\nField\tType\tDescription\tLabel\nvoting_item_id\taelf.Hash\tThe voting activity id.\t\noptions\tstring\tThe new options to add.\trepeated\nVote.GetVotingIdsInput​\nField\tType\tDescription\tLabel\nvoter\taelf.Address\tThe address of voter.\t\nvoting_item_id\taelf.Hash\tThe voting activity id.\t\nVote.GetVotingItemInput​\nField\tType\tDescription\tLabel\nvoting_item_id\taelf.Hash\tThe voting activity id.\t\nVote.GetVotingRecordsInput​\nField\tType\tDescription\tLabel\nids\taelf.Hash\tThe vote ids.\trepeated\nVote.GetVotingResultInput​\nField\tType\tDescription\tLabel\nvoting_item_id\taelf.Hash\tThe voting activity id.\t\nsnapshot_number\tint64\tThe snapshot number.\t\nVote.RemoveOptionInput​\nField\tType\tDescription\tLabel\nvoting_item_id\taelf.Hash\tThe voting activity id.\t\noption\tstring\tThe option to remove.\t\nVote.RemoveOptionsInput​\nField\tType\tDescription\tLabel\nvoting_item_id\taelf.Hash\tThe voting activity id.\t\noptions\tstring\tThe options to remove.\trepeated\nVote.TakeSnapshotInput​\nField\tType\tDescription\tLabel\nvoting_item_id\taelf.Hash\tThe voting activity id.\t\nsnapshot_number\tint64\tThe snapshot number to take.\t\nVote.VoteInput​\nField\tType\tDescription\tLabel\nvoting_item_id\taelf.Hash\tThe voting activity id.\t\nvoter\taelf.Address\tThe address of voter.\t\namount\tint64\tThe amount of vote.\t\noption\tstring\tThe option to vote.\t\nvote_id\taelf.Hash\tThe vote id.\t\nis_change_target\tbool\tWhether vote others.\t\nVote.Voted​\nField\tType\tDescription\tLabel\nvoting_item_id\taelf.Hash\tThe voting activity id.\t\nvoter\taelf.Address\tThe address of voter.\t\nsnapshot_number\tint64\tThe snapshot number.\t\namount\tint64\tThe amount of vote.\t\nvote_timestamp\tgoogle.protobuf.Timestamp <#google.protobuf.Timestamp>\tThe time of vote.\t\noption\tstring\tThe option voted.\t\nvote_id\taelf.Hash\tThe vote id.\t\nVote.VotedIds​\nField\tType\tDescription\tLabel\nactive_votes\taelf.Hash\tThe active vote ids.\trepeated\nwithdrawn_votes\taelf.Hash\tThe withdrawn vote ids.\trepeated\nVote.VotedItems​\nField\tType\tDescription\tLabel\nvoted_item_vote_ids\tVotedItems.VotedItemVoteIdsEntry\tThe voted ids.\trepeated\nVote.VotedItems.VotedItemVoteIdsEntry​\nField\tType\tDescription\tLabel\nkey\tstring\t\t\nvalue\tVotedIds\t\t\nVote.VotingItem​\nField\tType\tDescription\tLabel\nvoting_item_id\taelf.Hash\tThe voting activity id.\t\naccepted_currency\tstring\tThe token symbol which will be accepted.\t\nis_lock_token\tbool\tWhether the vote will lock token.\t\ncurrent_snapshot_number\tint64\tThe current snapshot number.\t\ntotal_snapshot_number\tint64\tThe total snapshot number.\t\noptions\tstring\tThe list of options.\trepeated\nregister_timestamp\tgoogle.protobuf.Timestamp <#google.protobuf.Timestamp>\tThe register time of the voting activity.\t\nstart_timestamp\tgoogle.protobuf.Timestamp <#google.protobuf.Timestamp>\tThe start time of the voting.\t\nend_timestamp\tgoogle.protobuf.Timestamp <#google.protobuf.Timestamp>\tThe end time of the voting.\t\ncurrent_snapshot_start_timestamp\tgoogle.protobuf.Timestamp <#google.protobuf.Timestamp>\tThe start time of current round of the voting.\t\nsponsor\taelf.Address\tThe sponsor address of the voting activity.\t\nVote.VotingItemRegistered​\nField\tType\tDescription\tLabel\nvoting_item_id\taelf.Hash\tThe voting activity id.\t\naccepted_currency\tstring\tThe token symbol which will be accepted.\t\nis_lock_token\tbool\tWhether the vote will lock token.\t\ncurrent_snapshot_number\tint64\tThe current snapshot number.\t\ntotal_snapshot_number\tint64\tThe total number of snapshots of the vote.\t\nregister_timestamp\tgoogle.protobuf.Timestamp <#google.protobuf.Timestamp>\tThe register time of the voting activity.\t\nstart_timestamp\tgoogle.protobuf.Timestamp <#google.protobuf.Timestamp>\tThe start time of the voting.\t\nend_timestamp\tgoogle.protobuf.Timestamp <#google.protobuf.Timestamp>\tThe end time of the voting.\t\ncurrent_snapshot_start_timestamp\tgoogle.protobuf.Timestamp <#google.protobuf.Timestamp>\tThe start time of current round of the voting.\t\nsponsor\taelf.Address\tThe sponsor address of the voting activity.\t\nVote.VotingRecord​\nField\tType\tDescription\tLabel\nvoting_item_id\taelf.Hash\tThe voting activity id.\t\nvoter\taelf.Address\tThe address of voter.\t\nsnapshot_number\tint64\tThe snapshot number.\t\namount\tint64\tThe amount of vote.\t\nwithdraw_timestamp\tgoogle.protobuf.Timestamp <#google.protobuf.Timestamp>\tThe time of withdraw.\t\nvote_timestamp\tgoogle.protobuf.Timestamp <#google.protobuf.Timestamp>\tThe time of vote.\t\nis_withdrawn\tbool\tWhether the vote had been withdrawn.\t\noption\tstring\tThe option voted.\t\nis_change_target\tbool\tWhether vote others.\t\nVote.VotingRecords​\nField\tType\tDescription\tLabel\nrecords\tVotingRecord\tThe voting records.\trepeated\nVote.VotingRegisterInput​\nField\tType\tDescription\tLabel\nstart_timestamp\tgoogle.protobuf.Timestamp <#google.protobuf.Timestamp>\tThe start time of the voting.\t\nend_timestamp\tgoogle.protobuf.Timestamp <#google.protobuf.Timestamp>\tThe end time of the voting.\t\naccepted_currency\tstring\tThe token symbol which will be accepted.\t\nis_lock_token\tbool\tWhether the vote will lock token.\t\ntotal_snapshot_number\tint64\tThe total number of snapshots of the vote.\t\noptions\tstring\tThe list of options.\trepeated\nVote.VotingResult​\nField\tType\tDescription\tLabel\nvoting_item_id\taelf.Hash\tThe voting activity id.\t\nresults\tVotingResult.ResultsEntry\tThe voting result, option -> amount of votes,\trepeated\nsnapshot_number\tint64\tThe snapshot number.\t\nvoters_count\tint64\tThe total number of voters.\t\nsnapshot_start_timestamp\tgoogle.protobuf.Timestamp <#google.protobuf.Timestamp>\tThe start time of this snapshot.\t\nsnapshot_end_timestamp\tgoogle.protobuf.Timestamp <#google.protobuf.Timestamp>\tThe end time of this snapshot.\t\nvotes_amount\tint64\tTotal votes received during the process of this snapshot.\t\nVote.VotingResult.ResultsEntry​\nField\tType\tDescription\tLabel\nkey\tstring\t\t\nvalue\tint64\t\t\nVote.WithdrawInput​\nField\tType\tDescription\tLabel\nvote_id\taelf.Hash\tThe vote id.\t\nVote.Withdrawn​\nField\tType\tDescription\tLabel\nvote_id\taelf.Hash\tThe vote id.\t\nAElf.Standards.ACS1​\nacs1.MethodFee​\nField\tType\tDescription\tLabel\nsymbol\tstring\tThe token symbol of the method fee.\t\nbasic_fee\tint64\tThe amount of fees to be charged.\t\nacs1.MethodFees​\nField\tType\tDescription\tLabel\nmethod_name\tstring\tThe name of the method to be charged.\t\nfees\tMethodFee\tList of fees to be charged.\trepeated\nis_size_fee_free\tbool\tOptional based on the implementation of SetMethodFee method.\t\nAElf.Types​\naelf.Address​\nField\tType\tDescription\tLabel\nvalue\tbytes\t\t\naelf.BinaryMerkleTree​\nField\tType\tDescription\tLabel\nnodes\tHash\tThe leaf nodes.\trepeated\nroot\tHash\tThe root node hash.\t\nleaf_count\tint32\tThe count of leaf node.\t\naelf.Hash​\nField\tType\tDescription\tLabel\nvalue\tbytes\t\t\naelf.LogEvent​\nField\tType\tDescription\tLabel\naddress\tAddress\tThe contract address.\t\nname\tstring\tThe name of the log event.\t\nindexed\tbytes\tThe indexed data.\trepeated\nnon_indexed\tbytes\tThe non indexed data.\t\naelf.MerklePath​\nField\tType\tDescription\tLabel\nmerkle_path_nodes\tMerklePathNode\tThe merkle path nodes.\trepeated\naelf.MerklePathNode​\nField\tType\tDescription\tLabel\nhash\tHash\tThe node hash.\t\nis_left_child_node\tbool\tWhether it is a left child node.\t\naelf.SInt32Value​\nField\tType\tDescription\tLabel\nvalue\tsint32\t\t\naelf.SInt64Value​\nField\tType\tDescription\tLabel\nvalue\tsint64\t\t\naelf.ScopedStatePath​\nField\tType\tDescription\tLabel\naddress\tAddress\tThe scope address, which will be the contract address.\t\npath\tStatePath <#aelf.StatePath>\tThe path of contract state.\t\naelf.SmartContractRegistration​\nField\tType\tDescription\tLabel\ncategory\tsint32\tThe category of contract code(0: C#).\t\ncode\tbytes\tThe byte array of the contract code.\t\ncode_hash\tHash\tThe hash of the contract code.\t\nis_system_contract\tbool\tWhether it is a system contract.\t\nversion\tint32\tThe version of the current contract.\t\naelf.StatePath​\nField\tType\tDescription\tLabel\nparts\tstring\tThe partial path of the state path.\trepeated\naelf.Transaction​\nField\tType\tDescription\tLabel\nfrom\tAddress\tThe address of the sender of the transaction.\t\nto\tAddress\tThe address of the contract when calling a contract.\t\nref_block_number\tint64\tThe height of the referenced block hash.\t\nref_block_prefix\tbytes\tThe first four bytes of the referenced block hash.\t\nmethod_name\tstring\tThe name of a method in the smart contract at the To address.\t\nparams\tbytes\tThe parameters to pass to the smart contract method.\t\nsignature\tbytes\tWhen signing a transaction it’s actually a subset of the fields: from/to and the target method as well as the parameter that were given.\t\naelf.TransactionExecutingStateSet.DeletesEntry​\nField\tType\tDescription\tLabel\nkey\tstring\t\t\nvalue\tbool\t\t\naelf.TransactionExecutingStateSet.ReadsEntry​\nField\tType\tDescription\tLabel\nkey\tstring\t\t\nvalue\tbool\t\t\naelf.TransactionExecutingStateSet.WritesEntry​\nField\tType\tDescription\tLabel\nkey\tstring\t\t\nvalue\tbytes\t\t\naelf.TransactionResult​\nField\tType\tDescription\tLabel\ntransaction_id\tHash\tThe transaction id.\t\nstatus\tTransactionResultStatus\tThe transaction result status.\t\nlogs\tLogEvent\tThe log events.\trepeated\nbloom\tbytes\tBloom filter for transaction logs.\t\nreturn_value\tbytes\tThe return value of the transaction execution.\t\nblock_number\tint64 **\tThe height of the block that packages the transaction.\t\nblock_hash\tHash **\tThe hash of the block that packages the transaction.\t\nerror\tstring\tFailed execution error message.\t\naelf.TransactionResultStatus​\nName\tNumber\tDescription\nNOT_EXISTED\t0\tThe execution result of the transaction does not exist.\nPENDING\t1\tThe transaction is in the transaction pool waiting to be packaged.\nFAILED\t2\tTransaction execution failed.\nMINED\t3\tThe transaction was successfully executed and successfully packaged into a block.\nCONFLICT\t4\tWhen executed in parallel, there are conflicts with other transactions.\nPENDING_VALIDATION\t5\tThe transaction is waiting for validation.\nNODE_VALIDATION_FAILED\t6\tTransaction validation failed.\nAuthorityInfo​\nField\tType\tDescription\tLabel\ncontract_address\taelf.Address\tThe contract address of the controller.\t\nowner_address\taelf.Address\tThe address of the owner of the contract.\t\nPrevious\nTreasury Contract\nNext\nToken Holder Contract\nContract Methods\nAElf.Standards.ACS1\nAElf.Contracts.Vote\nVote.AddOptionInput\nVote.AddOptionsInput\nVote.GetVotingIdsInput\nVote.GetVotingItemInput\nVote.GetVotingRecordsInput\nVote.GetVotingResultInput\nVote.RemoveOptionInput\nVote.RemoveOptionsInput\nVote.TakeSnapshotInput\nVote.VoteInput\nVote.Voted\nVote.VotedIds\nVote.VotedItems\nVote.VotedItems.VotedItemVoteIdsEntry\nVote.VotingItem\nVote.VotingItemRegistered\nVote.VotingRecord\nVote.VotingRecords\nVote.VotingRegisterInput\nVote.VotingResult\nVote.VotingResult.ResultsEntry\nVote.WithdrawInput\nVote.Withdrawn\nAElf.Standards.ACS1\nacs1.MethodFee\nacs1.MethodFees\nAElf.Types\naelf.Address\naelf.BinaryMerkleTree\naelf.Hash\naelf.LogEvent\naelf.MerklePath\naelf.MerklePathNode\naelf.SInt32Value\naelf.SInt64Value\naelf.ScopedStatePath\naelf.SmartContractRegistration\naelf.StatePath\naelf.Transaction\naelf.TransactionExecutingStateSet.DeletesEntry\naelf.TransactionExecutingStateSet.ReadsEntry\naelf.TransactionExecutingStateSet.WritesEntry\naelf.TransactionResult\naelf.TransactionResultStatus\nAuthorityInfo\nPlatform\nTechnology\nAudit Report\nPrivacy\nTerms of Use\nCookie Policy\nDeveloper Resources\nQuick Start\nLearn\nDocs\nTools\nResources\nEcosystem\nOverview\ndApps\naelf Ventures\nBlog\nConnect\nContact Us\nCopyright © 2024 aelf"
    },
    {
      "title": "Treasury Contract | AELF Docs",
      "url": "https://docs.aelf.com/docs/smart-contract-api/treasury-contract/",
      "html": "Skip to main content\nQuick Start\nLearn\nDocs\nTools\nResources\nBlog\nSearch\nK\nDocs Reference\nSmart Contract API\nAssociation Contract\nReferendum Contract\nParliament Contract\nConsensus Contract\nElection Contract\nGenesis Contract\nMulti Token Contract\nProfit Contract\nCross Chain Contract\nTreasury Contract\nVote Contract\nToken Holder Contract\nEconomic Contract\nToken Converter Contract\nConfiguration Contract\nWeb API\nDocs ReferenceSmart Contract APITreasury Contract\nTreasury Contract\n\nUsed for distributing bonuses to voters and candidates during the election process. Implement aelf Standards ACS1 and ACS10.\n\nContract Methods​\nMethod Name\tRequest Type\tResponse Type\tDescription\nInitialTreasuryContract\tgoogle.protobuf.Empty\tgoogle.protobuf.Empty\tInitialize treasury contract.\nInitialMiningRewardProfitItem\tgoogle.protobuf.Empty\tgoogle.protobuf.Empty\tInitialize the sub-item of the bonus scheme.\nDonateAll\tTreasury.DonateAllInput\tgoogle.protobuf.Empty\tDonate all tokens owned by the sender.\nSetDividendPoolWeightSetting\tTreasury.DividendPoolWeightSetting\tgoogle.protobuf.Empty\tSet the dividend weight of the sub-item of the dividend item.\nSetMinerRewardWeightSetting\tTreasury.MinerRewardWeightSetting\tgoogle.protobuf.Empty\tSet the miner reward weight.\nSetProfitsReceiver\tTreasury.SetProfitsReceiverInput\tgoogle.protobuf.Empty\tSet collect profits receiver address.\nUpdateMiningReward\tgoogle.protobuf.Int64Value\tgoogle.protobuf.Empty\tSet the reward for mining.\nChangeTreasuryController\tAuthorityInfo\tgoogle.protobuf.Empty\tChange the governance authority information for the treasury contract.\nRecordMinerReplacement\tTreasury.RecordMinerReplacementInput\tgoogle.protobuf.Empty\tAEDPoS Contract can notify Treasury Contract to be aware of miner replacement happening.\nGetWelfareRewardAmountSample\tTreasury.GetWelfareRewardAmountSampleInput\tTreasury.GetWelfareRewardAmountSampleOutput\tUsed to estimate the revenue weight of 10000 tokens voted by users.\nGetTreasurySchemeId\tgoogle.protobuf.Empty\taelf.Hash\tGet the scheme id of treasury.\nGetDividendPoolWeightProportion\tgoogle.protobuf.Empty\tTreasury.DividendPoolWeightProportion\tQuery the weight percentage of dividend pool items.\nGetMinerRewardWeightProportion\tgoogle.protobuf.Empty\tTreasury.MinerRewardWeightProportion\tQuery the weight percentage of the dividend item for miners.\nGetTreasuryController\tgoogle.protobuf.Empty\tAuthorityInfo\tQuery the governance authority information.\nGetProfitsReceiver\tgoogle.protobuf.StringValue\taelf.Address\tGet profits receiver. If not set, return the candidate's address.\nGetProfitsReceiverOrDefault\tgoogle.protobuf.StringValue\taelf.Address\tGet profits receiver. If not set, return null.\nReplaceCandidateProfitsReceiver\tTreasury.ReplaceCandidateProfitsReceiverInput\tgoogle.protobuf.Empty\tQuery the governance authority information.\nAElf.Standards.ACS1​\nMethod Name\tRequest Type\tResponse Type\tDescription\nSetMethodFee\tacs1.MethodFees\tgoogle.protobuf.Empty\tSet the method fees for the specified method. Note that this will override all fees of the method.\nChangeMethodFeeController\tAuthorityInfo\tgoogle.protobuf.Empty\tChange the method fee controller, the default is parliament and default organization.\nGetMethodFee\tgoogle.protobuf.StringValue\tacs1.MethodFees\tQuery method fee information by method name.\nGetMethodFeeController\tgoogle.protobuf.Empty\tAuthorityInfo\tQuery the method fee controller.\nAElf.Standards.ACS10​\nMethod Name\tRequest Type\tResponse Type\tDescription\nDonate\tacs10.DonateInput\tgoogle.protobuf.Empty\tDonates tokens from the caller to the treasury. If the tokens are not native tokens in the current chain, they will be first converted to the native token.\nRelease\tacs10.ReleaseInput\tgoogle.protobuf.Empty\tRelease dividend pool according to the period number.\nSetSymbolList\tacs10.SymbolList\tgoogle.protobuf.Empty\tSet the token symbols dividend pool supports.\nGetSymbolList\tgoogle.protobuf.Empty\tacs10.SymbolList\tQuery the token symbols dividend pool supports.\nGetUndistributedDividends\tgoogle.protobuf.Empty\tacs10.Dividends\tQuery the balance of undistributed tokens whose symbols are included in the symbol list.\nGetDividends\tgoogle.protobuf.Int64Value\tacs10.Dividends\tQuery the dividend information according to the height.\n\nContract Types\n\nAElf.Contracts.Treasury​\nTreasury.DividendPoolWeightProportion​\nField\tType\tDescription\tLabel\ncitizen_welfare_proportion_info\tSchemeProportionInfo\tThe proportion of citizen welfare.\t\nbackup_subsidy_proportion_info\tSchemeProportionInfo\tThe proportion of candidate nodes.\t\nminer_reward_proportion_info\tSchemeProportionInfo\tThe proportion of miner\t\nTreasury.DividendPoolWeightSetting​\nField\tType\tDescription\tLabel\ncitizen_welfare_weight\tint32\tThe dividend weight of citizen welfare.\t\nbackup_subsidy_weight\tint32\tThe dividend weight of candidate nodes.\t\nminer_reward_weight\tint32\tThe dividend weight of miner.\t\nTreasury.DonateAllInput​\nField\tType\tDescription\tLabel\nsymbol\tstring\tThe token symbol to donate.\t\nTreasury.GetWelfareRewardAmountSampleInput​\nField\tType\tDescription\tLabel\nvalue\tint64\tToken lock time.\trepeated\nTreasury.GetWelfareRewardAmountSampleOutput​\nField\tType\tDescription\tLabel\nvalue\tint64\tThe weight calculated.\trepeated\nTreasury.MinerReElectionInformation​\nField\tType\tDescription\tLabel\ncontinual_appointment_times\tMinerReElectionInformation.ContinualAppointmentTimesEntry\tThe reappointment information for miner.\trepeated\nTreasury.MinerReElectionInformation.ContinualAppointmentTimesEntry​\nField\tType\tDescription\tLabel\nkey\tstring\t\t\nvalue\tint64\t\t\nTreasury.MinerRewardWeightProportion​\nField\tType\tDescription\tLabel\nbasic_miner_reward_proportion_info\tSchemeProportionInfo\tThe proportion of the basic income of the miner.\t\nvotes_weight_reward_proportion_info\tSchemeProportionInfo\tThe proportion of the vote of the miner.\t\nre_election_reward_proportion_info\tSchemeProportionInfo\tThe proportion of the reappointment of the miner.\t\nTreasury.MinerRewardWeightSetting​\nField\tType\tDescription\tLabel\nbasic_miner_reward_weight\tint32\tThe dividend weight of the basic income of the miner.\t\nvotes_weight_reward_weight\tint32\tThe dividend weight of the vote of the miner.\t\nre_election_reward_weight\tint32\tThe dividend weight of the reappointment of the miner.\t\nTreasury.RecordMinerReplacementInput​\nField\tType\tDescription\tLabel\nold_pubkey\tstring\t\t\nnew_pubkey\tstring\t\t\ncurrent_term_number\tint64\t\t\nTreasury.SchemeProportionInfo​\nField\tType\tDescription\tLabel\nscheme_id\taelf.Hash\tThe scheme id.\t\nproportion\tint32\tDividend weight percentage.\t\nTreasury.SetProfitsReceiverInput​\nField\tType\tDescription\tLabel\npubkey\tstring\tThe candidate's public key.\t\nprofits_receiver_address\taelf.Hash\tThe address of profits receiver.\t\nTreasury.ReplaceCandidateProfitsReceiverInput​\nField\tType\tDescription\tLabel\nold_pubkey\tstring\tThe old candidate's public key.\t\nnew_pubkey\tstring\tThe new candidate's public key.\t\nAElf.Standards.ACS1​\nacs1.MethodFee​\nField\tType\tDescription\tLabel\nsymbol\tstring\tThe token symbol of the method fee.\t\nbasic_fee\tint64\tThe amount of fees to be charged.\t\nacs1.MethodFees​\nField\tType\tDescription\tLabel\nmethod_name\tstring\tThe name of the method to be charged.\t\nfees\tMethodFee\tList of fees to be charged.\trepeated\nis_size_fee_free\tbool\tOptional based on the implementation.\t\nAElf.Standards.ACS10​\nacs10.Dividends​\nField\tType\tDescription\tLabel\nvalue\tDividends.ValueEntry\tThe dividends, symbol -> amount.\trepeated\nacs10.Dividends.ValueEntry​\nField\tType\tDescription\tLabel\nkey\tstring\t\t\nvalue\tint64\t\t\nacs10.DonateInput​\nField\tType\tDescription\tLabel\nsymbol\tstring\tThe token symbol to donate.\t\namount\tint64\tThe amount to donate.\t\nacs10.DonationReceived​\nField\tType\tDescription\tLabel\nfrom\taelf.Address\tThe address of donors.\t\npool_contract\taelf.Address\tThe address of dividend pool.\t\nsymbol\tstring\tThe token symbol Donated.\t\namount\tint64\tThe amount Donated.\t\nacs10.ReleaseInput​\nField\tType\tDescription\tLabel\nperiod_number\tint64\tThe period number to release.\t\nacs10.SymbolList​\nField\tType\tDescription\tLabel\nvalue\tstring\tThe token symbol list.\trepeated\nAElf.Types​\naelf.Address​\nField\tType\tDescription\tLabel\nvalue\tbytes\t\t\naelf.BinaryMerkleTree​\nField\tType\tDescription\tLabel\nnodes\tHash\tThe leaf nodes.\trepeated\nroot\tHash\tThe root node hash.\t\nleaf_count\tint32\tThe count of leaf node.\t\naelf.Hash​\nField\tType\tDescription\tLabel\nvalue\tbytes\t\t\naelf.LogEvent​\nField\tType\tDescription\tLabel\naddress\tAddress\tThe contract address.\t\nname\tstring\tThe name of the log event.\t\nindexed\tbytes\tThe indexed data, used to calculate bloom.\trepeated\nnon_indexed\tbytes\tThe non-indexed data.\t\naelf.MerklePath​\nField\tType\tDescription\tLabel\nmerkle_path_nodes\tMerklePathNode\tThe merkle path nodes.\trepeated\naelf.MerklePathNode​\nField\tType\tDescription\tLabel\nhash\tHash\tThe node hash.\t\nis_left_child_node\tbool\tWhether it's a left child node.\t\naelf.SInt32Value​\nField\tType\tDescription\tLabel\nvalue\tsint32\t\t\naelf.SInt64Value​\nField\tType\tDescription\tLabel\nvalue\tsint64\t\t\naelf.ScopedStatePath​\nField\tType\tDescription\tLabel\naddress\tAddress\tThe scope address, which will be the contract address.\t\npath\tStatePath\tThe path of contract state.\t\naelf.SmartContractRegistration​\nField\tType\tDescription\tLabel\ncategory\tsint32\tThe category of contract code (0: C#).\t\ncode\tbytes\tThe byte array of the contract code.\t\ncode_hash\tHash\tThe hash of the contract code.\t\nis_system_contract\tbool\tWhether it is a system contract.\t\nversion\tint32\tThe version of the current contract.\t\naelf.StatePath​\nField\tType\tDescription\tLabel\nparts\tstring\tThe partial path of the state path.\trepeated\naelf.Transaction​\nField\tType\tDescription\tLabel\nfrom\tAddress\tThe address of the sender of the transaction.\t\nto\tAddress\tThe address of the contract when calling a contract.\t\nref_block_number\tint64\tThe height of the referenced block hash.\t\nref_block_prefix\tbytes\tThe first four bytes of the referenced block hash.\t\nmethod_name\tstring\tThe name of a method in the smart contract at the To address.\t\nparams\tbytes\tThe parameters to pass to the smart contract method.\t\nsignature\tbytes\tWhen signing a transaction, it’s actually a subset of the fields: from/to and the target method, as well as the parameter that were given. It also contains the reference block number and prefix.\t\naelf.TransactionExecutingStateSet​\nField\tType\tDescription\tLabel\nwrites\tTransactionExecutingStateSet.WritesEntry\tThe changed states.\trepeated\nreads\tTransactionExecutingStateSet.ReadsEntry\tThe read states.\trepeated\ndeletes\tTransactionExecutingStateSet.DeletesEntry\tThe deleted states.\trepeated\naelf.TransactionExecutingStateSet.DeletesEntry​\nField\tType\tDescription\tLabel\nkey\tstring\t\t\nvalue\tbool\t\t\naelf.TransactionExecutingStateSet.ReadsEntry​\nField\tType\tDescription\tLabel\nkey\tstring\t\t\nvalue\tbool\t\t\naelf.TransactionExecutingStateSet.WritesEntry​\nField\tType\tDescription\tLabel\nkey\tstring\t\t\nvalue\tbytes\t\t\naelf.TransactionResult​\nField\tType\tDescription\tLabel\ntransaction_id\tHash\tThe transaction id.\t\nstatus\tTransactionResultStatus\tThe transaction result status.\t\nlogs\tLogEvent\tThe log events.\trepeated\nbloom\tbytes\tBloom filter for transaction logs. A transaction log event can be defined in the contract and stored in the bloom filter after the transaction is executed.\t\nreturn_value\tbytes\tThe return value of the transaction execution.\t\nblock_number\tint64\tThe height of the block that packages the transaction.\t\nblock_hash\tHash\tThe hash of the block that packages the transaction.\t\nerror\tstring\tFailed execution error message.\t\naelf.TransactionResultStatus​\nName\tNumber\tDescription\nNOT_EXISTED\t0\tThe execution result of the transaction does not exist.\nPENDING\t1\tThe transaction is in the transaction pool waiting to be packaged.\nFAILED\t2\tTransaction execution failed.\nMINED\t3\tThe transaction was successfully executed and successfully packaged into a block.\nCONFLICT\t4\tWhen executed in parallel, there are conflicts with other transactions.\nPENDING_VALIDATION\t5\tThe transaction is waiting for validation.\nNODE_VALIDATION_FAILED\t6\tTransaction validation failed.\nAuthorityInfo​\nField\tType\tDescription\tLabel\ncontract_address\taelf.Address\tThe contract address of the controller.\t\nowner_address\taelf.Address\tThe address of the owner of the contract.\t\nPrevious\nCross Chain Contract\nNext\nVote Contract\nContract Methods\nAElf.Standards.ACS1\nAElf.Standards.ACS10\nAElf.Contracts.Treasury\nTreasury.DividendPoolWeightProportion\nTreasury.DividendPoolWeightSetting\nTreasury.DonateAllInput\nTreasury.GetWelfareRewardAmountSampleInput\nTreasury.GetWelfareRewardAmountSampleOutput\nTreasury.MinerReElectionInformation\nTreasury.MinerReElectionInformation.ContinualAppointmentTimesEntry\nTreasury.MinerRewardWeightProportion\nTreasury.MinerRewardWeightSetting\nTreasury.RecordMinerReplacementInput\nTreasury.SchemeProportionInfo\nTreasury.SetProfitsReceiverInput\nTreasury.ReplaceCandidateProfitsReceiverInput\nAElf.Standards.ACS1\nacs1.MethodFee\nacs1.MethodFees\nAElf.Standards.ACS10\nacs10.Dividends\nacs10.Dividends.ValueEntry\nacs10.DonateInput\nacs10.DonationReceived\nacs10.ReleaseInput\nacs10.SymbolList\nAElf.Types\naelf.Address\naelf.BinaryMerkleTree\naelf.Hash\naelf.LogEvent\naelf.MerklePath\naelf.MerklePathNode\naelf.SInt32Value\naelf.SInt64Value\naelf.ScopedStatePath\naelf.SmartContractRegistration\naelf.StatePath\naelf.Transaction\naelf.TransactionExecutingStateSet\naelf.TransactionExecutingStateSet.DeletesEntry\naelf.TransactionExecutingStateSet.ReadsEntry\naelf.TransactionExecutingStateSet.WritesEntry\naelf.TransactionResult\naelf.TransactionResultStatus\nAuthorityInfo\nPlatform\nTechnology\nAudit Report\nPrivacy\nTerms of Use\nCookie Policy\nDeveloper Resources\nQuick Start\nLearn\nDocs\nTools\nResources\nEcosystem\nOverview\ndApps\naelf Ventures\nBlog\nConnect\nContact Us\nCopyright © 2024 aelf"
    },
    {
      "title": "AELF Docs",
      "url": "https://docs.aelf.com/docs/smart-contract-api/profit-contract/",
      "html": "Skip to main content\nQuick Start\nLearn\nDocs\nTools\nResources\nBlog\nSearch\nK\nDocs Reference\nSmart Contract API\nAssociation Contract\nReferendum Contract\nParliament Contract\nConsensus Contract\nElection Contract\nGenesis Contract\nMulti Token Contract\nProfit Contract\nCross Chain Contract\nTreasury Contract\nVote Contract\nToken Holder Contract\nEconomic Contract\nToken Converter Contract\nConfiguration Contract\nWeb API\nDocs ReferenceSmart Contract APIProfit Contract\nProfit Contract\n\nThe Profit contract is an abstract layer for creating a scheme to share bonuses. Developers can build a system to distribute bonuses by calling this contract. Implement aelf Standards ACS1.\n\nContract Methods​\nMethod Name\tRequest Type\tResponse Type\tDescription\nCreateScheme\tProfit.CreateSchemeInput\taelf.Hash\tCreate a scheme for profit distribution and return the created scheme id.\nAddBeneficiary\tProfit.AddBeneficiaryInput\tgoogle.protobuf.Empty\tAdd beneficiary to scheme.\nRemoveBeneficiary\tProfit.RemoveBeneficiaryInput\tgoogle.protobuf.Empty\tRemove beneficiary from scheme.\nAddBeneficiaries\tProfit.AddBeneficiariesInput\tgoogle.protobuf.Empty\tBatch add beneficiaries to scheme.\nRemoveBeneficiaries\tProfit.RemoveBeneficiariesInput\tgoogle.protobuf.Empty\tBatch remove beneficiaries from scheme.\nContributeProfits\tProfit.ContributeProfitsInput\tgoogle.protobuf.Empty\tContribute profit to a scheme.\nClaimProfits\tProfit.ClaimProfitsInput\tgoogle.protobuf.Empty\tThe beneficiary draws tokens from the scheme.\nDistributeProfits\tProfit.DistributeProfitsInput\tgoogle.protobuf.Empty\tDistribute profits to schemes, including its sub-schemes according to period and token symbol; should be called by the manager.\nAddSubScheme\tProfit.AddSubSchemeInput\tgoogle.protobuf.Empty\tAdd sub-scheme to a scheme. This effectively adds the specified sub-scheme as a beneficiary of the parent scheme.\nRemoveSubScheme\tProfit.RemoveSubSchemeInput\tgoogle.protobuf.Empty\tRemove sub-scheme from a scheme.\nResetManager\tProfit.ResetManagerInput\tgoogle.protobuf.Empty\tReset the manager of a scheme.\nGetManagingSchemeIds\tProfit.GetManagingSchemeIdsInput\tProfit.CreatedSchemeIds\tGet all schemes managed by the specified manager.\nGetScheme\taelf.Hash\tProfit.Scheme\tGet scheme according to scheme id.\nGetSchemeAddress\tProfit.SchemePeriod\taelf.Address\tGet the virtual address of the number of periods of the scheme.\nGetDistributedProfitsInfo\tProfit.SchemePeriod\tProfit.DistributedProfitsInfo\tQuery the distributed profit information for the specified period.\nGetProfitDetails\tProfit.GetProfitDetailsInput\tProfit.ProfitDetails\tQuery the beneficiary's profit information on the scheme.\nGetProfitAmount\tProfit.GetProfitAmountInput\tgoogle.protobuf.Int64Value\tQuery the amount of profit according to token symbol (up to 10 periods).\nGetProfitsMap\tProfit.ClaimProfitsInput\tProfit.ReceivedProfitsMap\tQuery all profit (up to 10 periods).\nAElf.Standards.ACS1​\nMethod Name\tRequest Type\tResponse Type\tDescription\nSetMethodFee\tacs1.MethodFees\tgoogle.protobuf.Empty\tSet the method fees for the specified method. Note that this will override all fees of the method.\nChangeMethodFeeController\tAuthorityInfo\tgoogle.protobuf.Empty\tChange the method fee controller; the default is parliament and default organization.\nGetMethodFee\tgoogle.protobuf.StringValue\tacs1.MethodFees\tQuery method fee information by method name.\nGetMethodFeeController\tgoogle.protobuf.Empty\tAuthorityInfo\tQuery the method fee controller.\n\nContract Types\n\nAElf.Contracts.Profit​\nProfit.AddBeneficiariesInput​\nField\tType\tDescription\tLabel\nscheme_id\taelf.Hash\tThe scheme id.\t\nbeneficiary_shares\tBeneficiaryShare\tThe beneficiary information.\trepeated\nend_period\tint64\tThe end period for beneficiary profits.\t\nProfit.AddBeneficiaryInput​\nField\tType\tDescription\tLabel\nscheme_id\taelf.Hash\tThe scheme id.\t\nbeneficiary_share\tBeneficiaryShare\tThe beneficiary information.\t\nend_period\tint64\tThe end period for beneficiary profits.\t\nProfit.AddSubSchemeInput​\nField\tType\tDescription\tLabel\nscheme_id\taelf.Hash\tThe parent scheme id.\t\nsub_scheme_id\taelf.Hash\tThe sub scheme id.\t\nsub_scheme_shares\tint64\tThe profit weight of sub scheme.\t\nProfit.BeneficiaryShare​\nField\tType\tDescription\tLabel\nbeneficiary\taelf.Address\tThe beneficiary's address.\t\nshares\tint64\tThe profit weight of the beneficiary.\t\nProfit.ClaimProfitsInput​\nField\tType\tDescription\tLabel\nscheme_id\taelf.Hash\tThe scheme id.\t\nbeneficiary\taelf.Address\tThe beneficiary's address.\t\nProfit.ContributeProfitsInput​\nField\tType\tDescription\tLabel\nscheme_id\taelf.Hash\tThe scheme id to contribute.\t\namount\tint64\tThe amount to contribute.\t\nperiod\tint64\tThe number of periods for dividends.\t\nsymbol\tstring\tThe token symbol to contribute.\t\nProfit.CreateSchemeInput​\nField\tType\tDescription\tLabel\nprofit_receiving_due_period_count\tint64\tPeriod of profit distribution.\t\nis_release_all_balance_every_time_by_default\tbool\tWhether all the scheme balance is distributed each period.\t\ndelay_distribute_period_count\tint32\tDelay distribute period.\t\nmanager\taelf.Address\tThe manager of the scheme.\t\ncan_remove_beneficiary_directly\tbool\tWhether you can directly remove beneficiaries.\t\ntoken\taelf.Hash\tUsed to generate scheme id.\t\nProfit.CreatedSchemeIds​\nField\tType\tDescription\tLabel\nscheme_ids\taelf.Hash\tThe scheme ids.\trepeated\n\nHere's the content converted to Markdown format with the information presented in boxes:\n\nProfit.DistributeProfitsInput​\nField\tType\tDescription\tLabel\nscheme_id\taelf.Hash\tThe scheme id to distribute.\t\nperiod\tint64\tThe period number to distribute, current period.\t\namounts_map\tAmountsMapEntry\tThe amount to distribute, symbol -> amount.\trepeated\nProfit.DistributeProfitsInput.AmountsMapEntry​\nField\tType\tDescription\tLabel\nkey\tstring\t\t\nvalue\tint64\t\t\nProfit.DistributedProfitsInfo​\nField\tType\tDescription\tLabel\ntotal_shares\tint64\tTotal shares in this scheme at the current period.\t\namounts_map\tAmountsMapEntry\tContributed amount in this scheme at the current period.\trepeated\nis_released\tbool\tWhether released.\t\nProfit.DistributedProfitsInfo.AmountsMapEntry​\nField\tType\tDescription\tLabel\nkey\tstring\t\t\nvalue\tsint64\t\t\nProfit.GetManagingSchemeIdsInput​\nField\tType\tDescription\tLabel\nmanager\taelf.Address\tThe manager address.\t\nProfit.GetProfitAmountInput​\nField\tType\tDescription\tLabel\nscheme_id\taelf.Hash\tThe scheme id.\t\nsymbol\tstring\tThe token symbol.\t\nbeneficiary\taelf.Address\tBeneficiary's address.\t\nProfit.GetProfitDetailsInput​\nField\tType\tDescription\tLabel\nscheme_id\taelf.Hash\tThe scheme id.\t\nbeneficiary\taelf.Address\tBeneficiary's address.\t\nProfit.ProfitDetail​\nField\tType\tDescription\tLabel\nstart_period\tint64\tThe start period number.\t\nend_period\tint64\tThe end period number.\t\nshares\tint64\tThe weight of the proceeds on the current period of the scheme.\t\nlast_profit_period\tint64\tThe last period number that the beneficiary received the profit.\t\nis_weight_removed\tbool\tWhether the weight has been removed.\t\nProfit.ProfitDetails​\nField\tType\tDescription\tLabel\ndetails\tProfitDetail\tThe profit information.\trepeated\nProfit.ProfitDetails.ProfitDetail​\nField\tType\tDescription\tLabel\nstart_period\tint64\tThe start period number.\t\nend_period\tint64\tThe end period number.\t\nshares\tint64\tThe weight of the proceeds.\t\nlast_profit_period\tint64\tThe last period received.\t\nis_weight_removed\tbool\tWhether weight removed.\t\nProfit.ProfitsClaimed​\nField\tType\tDescription\tLabel\nbeneficiary\taelf.Address\tBeneficiary's address claimed.\t\nsymbol\tstring\tToken symbol claimed.\t\namount\tint64\tThe amount claimed.\t\nperiod\tint64\tThe period number claimed.\t\nclaimer_shares\tint64\tShares of the claimer.\t\ntotal_shares\tint64\tTotal shares at current period.\t\nProfit.ReceivedProfitsMap​\nField\tType\tDescription\tLabel\nvalue\tReceivedProfitsMap.ValueEntry\tCollection of profits received, symbol -> amount.\trepeated\nProfit.ReceivedProfitsMap.ValueEntry​\nField\tType\tDescription\tLabel\nkey\tstring\t\t\nvalue\tint64\t\t\nProfit.RemoveBeneficiariesInput​\nField\tType\tDescription\tLabel\nbeneficiaries\taelf.Address\tAddresses of beneficiaries.\trepeated\nscheme_id\taelf.Hash\tThe scheme id.\t\nProfit.RemoveBeneficiaryInput​\nField\tType\tDescription\tLabel\nbeneficiary\taelf.Address\tBeneficiary's address.\t\nscheme_id\taelf.Hash\tThe scheme id.\t\nProfit.RemoveSubSchemeInput​\nField\tType\tDescription\tLabel\nscheme_id\taelf.Hash\tThe parent scheme id.\t\nsub_scheme_id\taelf.Hash\tThe sub scheme id.\t\nProfit.ResetManagerInput​\nField\tType\tDescription\tLabel\nscheme_id\taelf.Hash\tThe scheme id.\t\nnew_manager\taelf.Address\tAddress of new manager.\t\nProfit.Scheme​\nField\tType\tDescription\tLabel\nvirtual_address\taelf.Address\tThe virtual address of the scheme.\t\ntotal_shares\tint64\tThe total weight of the scheme.\t\nmanager\taelf.Address\tThe manager of the scheme.\t\ncurrent_period\tint64\tThe current period.\t\nsub_schemes\tSchemeBeneficiaryShare\tSub schemes information.\trepeated\ncan_remove_beneficiary_directly\tbool\tWhether you can directly remove the beneficiary.\t\nprofit_receiving_due_period_count\tint64\tPeriod of profit distribution.\t\nis_release_all_balance_every_time_by_default\tbool\tWhether all the schemes balance will be distributed during distribution each period.\t\nscheme_id\taelf.Hash\tThe is of the scheme.\t\ndelay_distribute_period_count\tint32\tDelay distribute period.\t\ncached_delay_total_shares\tScheme.CachedDelayTotalSharesEntry\tRecord the scheme's current total share for deferred distribution of benefits, period -> total shares.\trepeated\nreceived_token_symbols\tstring\tThe received token symbols.\trepeated\nProfit.Scheme.CachedDelayTotalSharesEntry​\nField\tType\tDescription\tLabel\nkey\tint64\t\t\nvalue\tint64\t\t\nProfit.SchemeBeneficiaryShare​\nField\tType\tDescription\tLabel\nscheme_id\taelf.Hash\tThe id of the sub scheme.\t\nshares\tint64\tThe weight of the sub scheme.\t\nProfit.SchemeCreated​\nField\tType\tDescription\tLabel\nvirtual_address\taelf.Address\tThe virtual address of the created scheme.\t\nmanager\taelf.Address\tThe manager of the created scheme.\t\nprofit_receiving_due_period_count\tint64\tPeriod of profit distribution.\t\nis_release_all_balance_every_time_by_default\tbool\tWhether all the schemes balance will be distributed each period.\t\nscheme_id\taelf.Hash\tThe id of the created scheme.\t\nProfit.SchemePeriod​\nField\tType\tDescription\tLabel\nscheme_id\taelf.Hash\tThe scheme id.\t\nperiod\tint64\tThe period number.\t\nAElf.Standards.ACS1​\nacs1.MethodFee​\nField\tType\tDescription\tLabel\nsymbol\tstring\tThe token symbol of the method fee.\t\nbasic_fee\tint64\tThe amount of fees to be charged.\t\nacs1.MethodFees​\nField\tType\tDescription\tLabel\nmethod_name\tstring\tThe name of the method.\t\nfees\tMethodFee\tList of fees to be charged.\trepeated\nis_size_fee_free\tbool\tOptional based on the implementation of SetMethodFee method.\t\nAElf.Types​\naelf.Address​\nField\tType\tDescription\tLabel\nvalue\tbytes\t\t\naelf.BinaryMerkleTree​\nField\tType\tDescription\tLabel\nnodes\tHash\tThe leaf nodes.\trepeated\nroot\tHash\tThe root node hash.\t\nleaf_count\tint32\tThe count of leaf node.\t\naelf.Hash​\nField\tType\tDescription\tLabel\nvalue\tbytes\t\t\naelf.LogEvent​\nField\tType\tDescription\tLabel\naddress\tAddress\tThe contract address.\t\nname\tstring\tThe name of the log event.\t\nindexed\tbytes\tThe indexed data, used to calculate bloom.\trepeated\nnon_indexed\tbytes\tThe non indexed data.\t\naelf.MerklePath​\nField\tType\tDescription\tLabel\nmerkle_path_nodes\tMerklePathNode\tThe merkle path nodes.\trepeated\naelf.MerklePathNode​\nField\tType\tDescription\tLabel\nhash\tHash\tThe node hash.\t\nis_left_child_node\tbool\tWhether it is a left child node.\t\naelf.SInt32Value​\nField\tType\tDescription\tLabel\nvalue\tsint32\t\t\naelf.SInt64Value​\nField\tType\tDescription\tLabel\nvalue\tsint64\t\t\naelf.ScopedStatePath​\nField\tType\tDescription\tLabel\naddress\tAddress\tThe scope address, which will be the contract address.\t\npath\tStatePath\tThe path of contract state.\t\naelf.SmartContractRegistration​\nField\tType\tDescription\tLabel\ncategory\tsint32\tThe category of contract code(0: C#).\t\ncode\tbytes\tThe byte array of the contract code.\t\ncode_hash\tHash\tThe hash of the contract code.\t\nis_system_contract\tbool\tWhether it is a system contract.\t\nversion\tint32\tThe version of the current contract.\t\naelf.StatePath​\nField\tType\tDescription\tLabel\nparts\tstring\tThe partial path of the state path.\trepeated\naelf.Transaction​\nField\tType\tDescription\tLabel\nfrom\tAddress\tThe address of the sender of the transaction.\t\nto\tAddress\tThe address of the contract when calling a contract.\t\nref_block_number\tint64\tThe height of the referenced block hash.\t\nref_block_prefix\tbytes\tThe first four bytes of the referenced block hash.\t\nmethod_name\tstring\tThe name of a method in the smart contract at the To address.\t\nparams\tbytes\tThe parameters to pass to the smart contract method.\t\nsignature\tbytes\tWhen signing a transaction it’s actually a subset of the fields: from/to and the target method as well as the parameter that were given.\t\naelf.TransactionExecutingStateSet​\nField\tType\tDescription\tLabel\nwrites\tTransactionExecutingStateSet.WritesEntry\tThe changed states.\trepeated\nreads\tTransactionExecutingStateSet.ReadsEntry\tThe read states.\trepeated\ndeletes\tTransactionExecutingStateSet.DeletesEntry\tThe deleted states.\trepeated\naelf.TransactionExecutingStateSet.DeletesEntry​\nField\tType\tDescription\tLabel\nkey\tstring\t\t\nvalue\tbool\t\t\naelf.TransactionExecutingStateSet.ReadsEntry​\nField\tType\tDescription\tLabel\nkey\tstring\t\t\nvalue\tbool\t\t\naelf.TransactionExecutingStateSet.WritesEntry​\nField\tType\tDescription\tLabel\nkey\tstring\t\t\nvalue\tbytes\t\t\naelf.TransactionResult​\nField\tType\tDescription\tLabel\ntransaction_id\tHash\tThe transaction id.\t\nstatus\tTransactionResultStatus\tThe transaction result status.\t\nlogs\tLogEvent\tThe log events.\trepeated\nbloom\tbytes\tBloom filter for transaction logs.\t\nreturn_value\tbytes\tThe return value of the transaction execution.\t\nblock_number\tint64\tThe height of the block that packages the transaction.\t\nblock_hash\tHash\tThe hash of the block that packages the transaction.\t\nerror\tstring\tFailed execution error message.\t\naelf.TransactionResultStatus​\nName\tNumber\tDescription\nNOT_EXISTED\t0\tThe execution result of the transaction does not exist.\nPENDING\t1\tThe transaction is in the transaction pool waiting to be packaged.\nFAILED\t2\tTransaction execution failed.\nMINED\t3\tThe transaction was successfully executed and successfully packaged into a block.\nCONFLICT\t4\tWhen executed in parallel, there are conflicts with other transactions.\nPENDING_VALIDATION\t5\tThe transaction is waiting for validation.\nNODE_VALIDATION_FAILED\t6\tTransaction validation failed.\nAuthorityInfo​\nField\tType\tDescription\tLabel\ncontract_address\taelf.Address\tThe contract address of the controller.\t\nPrevious\nMulti Token Contract\nNext\nCross Chain Contract\nContract Methods\nAElf.Standards.ACS1\nAElf.Contracts.Profit\nProfit.AddBeneficiariesInput\nProfit.AddBeneficiaryInput\nProfit.AddSubSchemeInput\nProfit.BeneficiaryShare\nProfit.ClaimProfitsInput\nProfit.ContributeProfitsInput\nProfit.CreateSchemeInput\nProfit.CreatedSchemeIds\nProfit.DistributeProfitsInput\nProfit.DistributedProfitsInfo\nProfit.DistributedProfitsInfo.AmountsMapEntry\nProfit.GetManagingSchemeIdsInput\nProfit.GetProfitAmountInput\nProfit.GetProfitDetailsInput\nProfit.ProfitDetail\nProfit.ProfitDetails\nProfit.ProfitDetails.ProfitDetail\nProfit.ProfitsClaimed\nProfit.ReceivedProfitsMap\nProfit.ReceivedProfitsMap.ValueEntry\nProfit.RemoveBeneficiariesInput\nProfit.RemoveBeneficiaryInput\nProfit.RemoveSubSchemeInput\nProfit.ResetManagerInput\nProfit.Scheme\nProfit.Scheme.CachedDelayTotalSharesEntry\nProfit.SchemeBeneficiaryShare\nProfit.SchemeCreated\nProfit.SchemePeriod\nAElf.Standards.ACS1\nacs1.MethodFee\nacs1.MethodFees\nAElf.Types\naelf.Address\naelf.BinaryMerkleTree\naelf.Hash\naelf.LogEvent\naelf.MerklePath\naelf.MerklePathNode\naelf.SInt32Value\naelf.SInt64Value\naelf.ScopedStatePath\naelf.SmartContractRegistration\naelf.StatePath\naelf.Transaction\naelf.TransactionExecutingStateSet\naelf.TransactionExecutingStateSet.DeletesEntry\naelf.TransactionExecutingStateSet.ReadsEntry\naelf.TransactionExecutingStateSet.WritesEntry\naelf.TransactionResult\naelf.TransactionResultStatus\nAuthorityInfo\nPlatform\nTechnology\nAudit Report\nPrivacy\nTerms of Use\nCookie Policy\nDeveloper Resources\nQuick Start\nLearn\nDocs\nTools\nResources\nEcosystem\nOverview\ndApps\naelf Ventures\nBlog\nConnect\nContact Us\nCopyright © 2024 aelf"
    },
    {
      "title": "AELF Docs",
      "url": "https://docs.aelf.com/docs/smart-contract-api/multi-token-contract/",
      "html": "Skip to main content\nQuick Start\nLearn\nDocs\nTools\nResources\nBlog\nSearch\nDocs Reference\nSmart Contract API\nAssociation Contract\nReferendum Contract\nParliament Contract\nConsensus Contract\nElection Contract\nGenesis Contract\nMulti Token Contract\nProfit Contract\nCross Chain Contract\nTreasury Contract\nVote Contract\nToken Holder Contract\nEconomic Contract\nToken Converter Contract\nConfiguration Contract\nWeb API\nDocs ReferenceSmart Contract APIMulti Token Contract\nMultiToken Contract\n\nThe MultiToken contract is mainly used to manage the user's account and transaction fees related settings. Implements aelf Standards ACS1 and ACS2.\n\nContract Methods​\nMethod Name\tRequest Type\tResponse Type\tDescription\nAdvanceResourceToken\ttokenimpl.AdvanceResourceTokenInput\tgoogle.protobuf.Empty\tTransfer resource tokens to designated contract address.\nTakeResourceTokenBack\ttokenimpl.TakeResourceTokenBackInput\tgoogle.protobuf.Empty\tTake token from contract address.\nRegisterCrossChainTokenContractAddress\ttokenimpl.RegisterCrossChainTokenContractAddressInput\tgoogle.protobuf.Empty\tRegister the token contract address for cross chain.\nSetFeeReceiver\taelf.Address\tgoogle.protobuf.Empty\tSet the receiver address of the side chain transaction fee.\nValidateTokenInfoExists\ttokenimpl.ValidateTokenInfoExistsInput\tgoogle.protobuf.Empty\tValidates if the token exist.\nUpdateRental\ttokenimpl.UpdateRentalInput\tgoogle.protobuf.Empty\tUpdate the rental unit price of the side chain.\nUpdateRentedResources\ttokenimpl.UpdateRentedResourcesInput\tgoogle.protobuf.Empty\tSet the amount of resources fee per minute for the side chain.\nTransferToContract\ttokenimpl.TransferToContractInput\tgoogle.protobuf.Empty\tTransfer Token to the specified contract.\nChangeSideChainRentalController\tAuthorityInfo\tgoogle.protobuf.Empty\tChange the governance organization of side chain rental.\nChangeSymbolsToPayTXSizeFeeController\tAuthorityInfo\tgoogle.protobuf.Empty\tChange the governance organization for tokens to pay transaction fees.\nChangeCrossChainTokenContractRegistrationController\tAuthorityInfo\tgoogle.protobuf.Empty\tChange the governance organization for cross-chain token contract address registration.\nChangeUserFeeController\tAuthorityInfo\tgoogle.protobuf.Empty\tChange the governance organization of the coefficient of the user transaction fee calculation formula.\nChangeDeveloperController\tAuthorityInfo\tgoogle.protobuf.Empty\tChange the governance organization of the coefficient of the developer's transaction resource fee calculation formula.\nConfigTransactionFeeFreeAllowances\ttoken.ConfigTransactionFeeFreeAllowancesInput\tgoogle.protobuf.Empty\tSet allowance configurations for transaction fee exemption.\nGetFeeReceiver\tgoogle.protobuf.Empty\taelf.Address\tGet the address of fee receiver.\nGetResourceUsage\tgoogle.protobuf.Empty\ttokenimpl.ResourceUsage\tQuery the amount of resources usage currently.\nGetSymbolsToPayTXSizeFeeController\tgoogle.protobuf.Empty\tAuthorityInfo\tQuery the governance organization for tokens to pay transaction fees.\nGetCrossChainTokenContractRegistrationController\tgoogle.protobuf.Empty\tAuthorityInfo\tQuery the governance organization of the\nGetUserFeeController\tgoogle.protobuf.Empty\ttokenimpl.UserFeeController\tQuery the governance organization that calculates the formula coefficient for the transaction cost the user sends the contract.\nGetDeveloperFeeController\tgoogle.protobuf.Empty\ttokenimpl.DeveloperFeeController\tQuery the governing organization of the formula coefficients for calculating developer contract transaction fee.\nGetSideChainRentalControllerCreateInfo\tgoogle.protobuf.Empty\tAuthorityInfo\tQuery the organization that governs the side chain rental fee.\nGetTransactionFeeFreeAllowances\taelf.Address\ttoken.TransactionFeeFreeAllowancesMap >\tGet the allowances for transaction fee exemption.\nGetTransactionFeeFreeAllowancesConfig\tgoogle.protobuf.Empty\ttoken.GetTransactionFeeFreeAllowancesConfigOutput\tQuery allowance configurations for transaction fee exemption.\nGetTransactionFeeDelegatees\ttoken.GetTransactionFeeDelegateesInput\ttoken.GetTransactionFeeDelegateesOutput\tRetrieve a list of proxy addresses corresponding to a given address.\nGetVirtualAddressForLocking\ttokenimpl.GetVirtualAddressForLockingInput\taelf.Address\tCompute the virtual address for locking.\nGetOwningRental\tgoogle.protobuf.Empty\ttokenimpl.OwningRental\tQuery how much resource tokens should be paid currently.\nGetOwningRentalUnitValue\tgoogle.protobuf.Empty\ttokenimpl.OwningRentalUnitValue\tQuery the unit price of the side chain resource cost resource cost = unit price * quantity the quantity can be queried through GetResourceUsage.\nCreate\ttoken.CreateInput\tgoogle.protobuf.Empty\tCreate a new token/collection/nft.\nIssue\ttoken.IssueInput\tgoogle.protobuf.Empty\tIssuing some amount of tokens/collection/nft to an address is the action of increasing that addresses balance for the given token. The total amount of issued tokens must not exceed the total supply of the token and only the issuer (creator) of the token/collection/nft can issue tokens. Issuing token/collection/nft effectively increases the circulating supply.\nTransfer\ttoken.TransferInput\tgoogle.protobuf.Empty\tTransferring tokens simply is the action of transferring a given amount of tokens from one address to another. The origin or source address is the signer of the transaction. The balance of the sender must be higher than the amount that is transferred.\nTransferFrom\ttoken.TransferFromInput\tgoogle.protobuf.Empty\tThe TransferFrom action will transfer a specified amount of tokens from one address to another. For this operation to succeed the from address needs to have approved (see allowances) enough tokens to Sender of this transaction. If successful the amount will be removed from the allowance.\nApprove\ttoken.ApproveInput\tgoogle.protobuf.Empty\tThe approve action increases the allowance from the Sender to the Spender address enabling the Spender to call TransferFrom.\nUnApprove\ttoken.UnApproveInput\tgoogle.protobuf.Empty\tThis is the reverse operation for Approve it will decrease the allowance.\nLock\ttoken.LockInput\tgoogle.protobuf.Empty\tThis method can be used to lock tokens.\nUnlock\ttoken.UnlockInput\tgoogle.protobuf.Empty\tThis is the reverse operation of locking it un-locks some previously locked tokens.\nBurn\ttoken.BurnInput\tgoogle.protobuf.Empty\tThis action will burn the specified amount of tokens removing them from the token’s Supply.\nSetPrimaryTokenSymbol\ttoken.SetPrimaryTokenSymbolInput\tgoogle.protobuf.Empty\tSet the primary token of side chain.\nCrossChainTransfer\ttoken.CrossChainTransferInput\tgoogle.protobuf.Empty\tThis interface is used for cross-chain transfer.\nCrossChainReceiveToken\ttoken.CrossChainReceiveTokenInput\tgoogle.protobuf.Empty\tThis method is used to receive cross-chain transfers.\nCrossChainCreateToken\ttoken.CrossChainCreateTokenInput\tgoogle.protobuf.Empty\tCreate token/collection/nft on the other chain. Collection must be created before creating nft.\nInitializeFromParentChain\ttoken.InitializeFromParentChainInput\tgoogle.protobuf.Empty\tWhen the side chain is started the side chain is initialized with the parent chain information.\nClaimTransactionFees\ttoken.TotalTransactionFeesMap\tgoogle.protobuf.Empty\tHandle the transaction fees charged by ChargeTransactionFees.\nChargeTransactionFees\ttoken.ChargeTransactionFeesInput\ttoken.ChargeTransactionFeesOutput\tUsed to collect transaction fees.\nChargeUserContractTransactionFees\ttoken.ChargeTransactionFeesInput\ttoken.ChargeTransactionFeesOutput\tUsed to collect transaction fees of user contract .\nCheckThreshold\ttoken.CheckThresholdInput\tgoogle.protobuf.Empty\tCheck the token threshold.\nInitialCoefficients\tgoogle.protobuf.Empty\tgoogle.protobuf.Empty\tInitialize coefficients of every type of tokens supporting charging fee.\nDonateResourceToken\ttoken.TotalResourceTokensMaps\tgoogle.protobuf.Empty\tProcessing resource token received.\nChargeResourceToken\ttoken.ChargeResourceTokenInput\tgoogle.protobuf.Empty\tA transaction resource fee is charged to implement the ACS8 standards.\nCheckResourceToken\tgoogle.protobuf.Empty\tgoogle.protobuf.Empty\tVerify that the resource token are sufficient.\nSetSymbolsToPayTxSizeFee\ttoken.SymbolListToPayTxSizeFee\tgoogle.protobuf.Empty\tSet the list of tokens to pay transaction fees.\nUpdateCoefficientsForSender\ttoken.UpdateCoefficientsInput\tgoogle.protobuf.Empty\tUpdate the coefficient of the transaction fee calculation formula.\nUpdateCoefficientsForContract\ttoken.UpdateCoefficientsInput\tgoogle.protobuf.Empty\tUpdate the coefficient of the transaction fee calculation formula.\nInitializeAuthorizedController\tgoogle.protobuf.Empty\tgoogle.protobuf.Empty\tThis method is used to initialize the governance organization for some functions including: the coefficient of the user transaction fee calculation formula the coefficient of the contract developer resource fee calculation formula and the side chain rental fee.\nGetTokenInfo\ttoken.GetTokenInfoInput\ttoken.TokenInfo\tQuery token information.\nGetNativeTokenInfo\tgoogle.protobuf.Empty\ttoken.TokenInfo\tQuery native token information.\nGetResourceTokenInfo\tgoogle.protobuf.Empty\ttoken.TokenInfoList <#token.TokenInfoList>\tQuery resource token information.\nGetBalance\ttoken.GetBalanceInput\ttoken.GetBalanceOutput\tQuery the balance at the specified address.\nGetAllowance\ttoken.GetAllowanceInput\ttoken.GetAllowanceOutput\tQuery the account's allowance for other addresses\nIsInWhiteList\ttoken.IsInWhiteListInput\tgoogle.protobuf.BoolValue\tCheck whether the token is in the whitelist of an address which can be called TransferFrom to transfer the token under the condition of not being credited.\nGetLockedAmount\ttoken.GetLockedAmountInput\ttoken.GetLockedAmountOutput <#token.GetLockedAmountOutput>\tQuery the information for a lock.\nGetCrossChainTransferTokenContractAddress\ttoken.GetCrossChainTransferTokenContractAddressInput <#token.GetCrossChainTransferTokenContractAddressInput>\taelf.Address\tQuery the address of receiving token in cross-chain transfer.\nGetPrimaryTokenSymbol\tgoogle.protobuf.Empty\tgoogle.protobuf.StringValue\tQuery the name of the primary Token.\nGetCalculateFeeCoefficientsForContract\tgoogle.protobuf.Int32Value\ttoken.CalculateFeeCoefficients\tQuery the coefficient of the transaction fee calculation formula.\nUpdateCoefficientsForContract\ttoken.UpdateCoefficientsInput\tgoogle.protobuf.Empty\tUpdate the coefficient of the transaction fee calculation formula.\nInitializeAuthorizedController\tgoogle.protobuf.Empty\tgoogle.protobuf.Empty\tThis method is used to initialize the governance organization for some functions including: the coefficient of the user transaction fee calculation formula the coefficient of the contract developer resource fee calculation formula and the side chain rental fee.\nGetTokenInfo\ttoken.GetTokenInfoInput\ttoken.TokenInfo\tQuery token information.\nGetNativeTokenInfo\tgoogle.protobuf.Empty\ttoken.TokenInfo\tQuery native token information.\nGetResourceTokenInfo\tgoogle.protobuf.Empty\ttoken.TokenInfoList\tQuery resource token information.\nGetBalance\ttoken.GetBalanceInput\ttoken.GetBalanceOutput\tQuery the balance at the specified address.\nGetAllowance\ttoken.GetAllowanceInput\ttoken.GetAllowanceOutput\tQuery the account's allowance for other addresses\nIsInWhiteList\ttoken.IsInWhiteListInput\tgoogle.protobuf.BoolValue\tCheck whether the token is in the whitelist of an address which can be called TransferFrom to transfer the token under the condition of not being credited.\nGetLockedAmount\ttoken.GetLockedAmountInput\ttoken.GetLockedAmountOutput\tQuery the information for a lock.\nGetCrossChainTransferTokenContractAddress\ttoken.GetCrossChainTransferTokenContractAddressInput\taelf.Address\tQuery the address of receiving token in cross-chain transfer.\nGetPrimaryTokenSymbol\tgoogle.protobuf.Empty\tgoogle.protobuf.StringValue\tQuery the name of the primary Token.\nGetCalculateFeeCoefficientsForContract\tgoogle.protobuf.Int32Value\ttoken.CalculateFeeCoefficients\tQuery the coefficient of the transaction fee calculation formula.\nGetCalculateFeeCoefficientsForSender\tgoogle.protobuf.Empty\ttoken.CalculateFeeCoefficients\tQuery the coefficient of the transaction fee calculation formula.\nGetSymbolsToPayTxSizeFee\tgoogle.protobuf.Empty\ttoken.SymbolListToPayTxSizeFee\tQuery tokens that can pay transaction fees.\nGetLatestTotalTransactionFeesMapHash\tgoogle.protobuf.Empty\taelf.Hash\tQuery the hash of the last input of ClaimTransactionFees.\nGetLatestTotalResourceTokensMapsHash\tgoogle.protobuf.Empty\taelf.Hash\tQuery the hash of the last input of DonateResourceToken.\nIsTokenAvailableForMethodFee\tgoogle.protobuf.StringValue\tgoogle.protobuf.BoolValue\t\nSetTransactionFeeDelegations\ttoken.SetTransactionFeeDelegationsInput\ttoken.SetTransactionFeeDelegationsOutput <#token.SetTransactionFeeDelegationsOutput>\tSet delegation of transaction fee payment.\nSetTransactionFeeDelegateInfos\ttoken.SetTransactionFeeDelegateInfosInput\tgoogle.protobuf.Empty\tSet delegate info to pay transaction fee.\nRemoveTransactionFeeFreeAllowancesConfig\ttoken.RemoveTransactionFeeFreeAllowancesConfigInput\tgoogle.protobuf.Empty\tRemove allowance configurations for transaction fee exemption.\nRemoveTransactionFeeDelegator\ttoken.RemoveTransactionFeeDelegatorInput\tgoogle.protobuf.Empty\tRemove transaction fee delegator.\nRemoveTransactionFeeDelegatorInfos\ttoken.RemoveTransactionFeeDelegatorInfosInput\tgoogle.protobuf.Empty\tRemove delegator info of the delegatee.\nRemoveTransactionFeeDelegatee\ttoken.RemoveTransactionFeeDelegateeInput\tgoogle.protobuf.Empty\tRemove transaction fee delegatee.\nRemoveTransactionFeeDelegateeInfos\ttoken.RemoveTransactionFeeDelegateeInfosInput\tgoogle.protobuf.Empty\tRemove delegatee info of the delegator.\nGetTransactionFeeDelegationsOfADelegatee\ttoken.GetTransactionFeeDelegationsOfADelegateeInput\ttoken.TransactionFeeDelegations\tGet the delegation of transaction fee payment of a delegatee.\nGetTransactionFeeDelegateeList\ttoken.GetTransactionFeeDelegateeListInput\ttoken.GetTransactionFeeDelegateeListOutput\tGet all delegatee list of a delegator.\nGetTransactionFeeDelegateInfo\ttoken.GetTransactionFeeDelegateInfoInput\ttoken.TransactionFeeDelegations\tGet delegate info for transaction fee.\nAElf.Standards.ACS1​\nMethod Name\tRequest Type\tResponse Type\tDescription\nSetMethodFee\tacs1.MethodFees\tgoogle.protobuf.Empty\tSet the method fees for the specified method. Note that this will override all fees of the method.\nChangeMethodFeeController\tAuthorityInfo\tgoogle.protobuf.Empty\tChange the method fee controller the default is parliament and default organization.\nGetMethodFee\tgoogle.protobuf.StringValue\tacs1.MethodFees\tQuery method fee information by method name.\nGetMethodFeeController\tgoogle.protobuf.Empty\tAuthorityInfo\tQuery the method fee controller.\nAElf.Standards.ACS2​\nMethod Name\tRequest Type\tResponse Type\tDescription\nGetResourceInfo\taelf.Transaction <#aelf.Transaction>\tacs2.ResourceInfo\tGets the resource information that the transaction execution depends on.\n\nContract Types\n\nAElf.Contracts.MultiToken​\ntokenimpl.AdvanceResourceTokenInput​\nField\tType\tDescription\tLabel\ncontract_address\taelf.Address\tThe contract address to transfer.\t\nresource_token_symbol\tstring\tThe resource token symbol to transfer.\t\namount\tint64\tThe amount of resource token to transfer.\t\ntokenimpl.DeveloperFeeController​\nField\tType\tDescription\tLabel\nroot_controller\tAuthorityInfo\tThe association that governs the organization.\t\nparliament_controller\tAuthorityInfo\tThe parliament organization of members.\t\ndeveloper_controller\tAuthorityInfo\tThe developer organization of members.\t\ntokenimpl.GetVirtualAddressForLockingInput​\nField\tType\tDescription\tLabel\naddress\taelf.Address\tThe address of the lock.\t\nlock_id\taelf.Hash\tThe id of the lock.\t\ntokenimpl.OwningRental​\nField\tType\tDescription\tLabel\nresource_amount\tOwningRental.ResourceAmountEntry\tThe amount of resource tokens owed symbol -> amount.\trepeated\ntokenimpl.OwningRental.ResourceAmountEntry​\nField\tType\tDescription\tLabel\nkey\tstring\t\t\nvalue\tint64\t\t\ntokenimpl.OwningRentalUnitValue​\nField\tType\tDescription\tLabel\nresource_unit_value\tOwningRentalUnitValue.ResourceUnitValueEntry\tResource unit price symbol -> unit price.\trepeated\ntokenimpl.OwningRentalUnitValue.ResourceUnitValueEntry​\nField\tType\tDescription\tLabel\nkey\tstring\t\t\nvalue\tint64\t\t\nAElf.Standards.ACS1​\nMethod Name\tRequest Type\tResponse Type\tDescription\nSetMethodFee\tacs1.MethodFees\tgoogle.protobuf.Empty\tSet the method fees for the specified method. Note that this will override all fees of the method.\nChangeMethodFeeController\tAuthorityInfo\tgoogle.protobuf.Empty\tChange the method fee controller the default is parliament and default organization.\nGetMethodFee\tgoogle.protobuf.StringValue\tacs1.MethodFees\tQuery method fee information by method name.\nGetMethodFeeController\tgoogle.protobuf.Empty\tAuthorityInfo\tQuery the method fee controller.\nAElf.Standards.ACS2​\nMethod Name\tRequest Type\tResponse Type\tDescription\nGetResourceInfo\taelf.Transaction\tacs2.ResourceInfo\tGets the resource information that the transaction execution depends on.\nAElf.Contracts.MultiToken - tokenimpl.AdvanceResourceTokenInput​\nField\tType\tDescription\tLabel\ncontract_address\taelf.Address\tThe contract address to transfer.\t\nresource_token_symbol\tstring\tThe resource token symbol to transfer.\t\namount\tint64\tThe amount of resource token to transfer.\t\ntokenimpl.RegisterCrossChainTokenContractAddressInput​\nField\tType\tDescription\tLabel\nfrom_chain_id\tint32\tThe source chain id.\t\nparent_chain_height\tint64\tThe parent chain height of the transaction.\t\ntransaction_bytes\tbytes\tThe raw bytes of the transfer transaction.\t\nmerkle_path\taelf.MerklePath\tThe merkle path created from the transaction.\t\ntoken_contract_address\taelf.Address\tThe token contract address.\t\ntokenimpl.ValidateTokenInfoExistsInput​\nField\tType\tDescription\tLabel\nsymbol\tstring\tThe symbol of the token.\t\ntoken_name\tstring\tThe full name of the token.\t\ntotal_supply\tint64\tThe total supply of the token.\t\ndecimals\tint32\tThe precision of the token.\t\nissuer\taelf.Address\tThe address that has permission to issue the token/collection/nft.\t\nis_burnable\tbool\tA flag indicating if this token is burnable.\t\nissue_chain_id\tint32\tThe chain id of the token.\t\nexternal_info\tmap<stringstring>\tAttributes or description of the token/collection/nft.\t\nowner\taelf.Address\tThe address that has permission to create nft.\t\ntoken.AllCalculateFeeCoefficients​\nField\tType\tDescription\tLabel\nvalue\tCalculateFeeCoefficients\tThe coefficients of fee Calculation.\trepeated\ntoken.ApproveInput​\nField\tType\tDescription\tLabel\nspender\taelf.Address\tThe address that allowance will be increased.\t\nsymbol\tstring\tThe symbol of token to approve.\t\namount\tint64\tThe amount of token to approve.\t\ntoken.Approved​\nField\tType\tDescription\tLabel\nowner\taelf.Address\tThe address of the token owner.\t\nspender\taelf.Address\tThe address that allowance be increased.\t\nsymbol\tstring\tThe symbol of approved token.\t\namount\tint64\tThe amount of approved token.\t\ntoken.BurnInput​\nField\tType\tDescription\tLabel\nsymbol\tstring\tThe symbol of token to burn.\t\namount\tint64\tThe amount of token to burn.\t\ntoken.Burned​\nField\tType\tDescription\tLabel\nburner\taelf.Address\tThe address who wants to burn token.\t\nsymbol\tstring\tThe symbol of burned token.\t\namount\tint64\tThe amount of burned token.\t\ntoken.CalculateFeeAlgorithmUpdated​\nField\tType\tDescription\tLabel\nall_type_fee_coefficients\tAllCalculateFeeCoefficients\tAll calculate fee coefficients after modification.\t\ntoken.CalculateFeeCoefficients​\nField\tType\tDescription\tLabel\nfee_token_type\tint32\tThe resource fee type like READ WRITE etc.\t\npiece_coefficients_list\tCalculateFeePieceCoefficients\tCoefficients of one single piece.\trepeated\ntoken.CalculateFeePieceCoefficients​\nField\tType\tDescription\tLabel\nvalue\tint32\tCoefficients of one single piece. The first char is its type: liner / power. The second char is its piece upper bound.\trepeated\ntoken.ChainPrimaryTokenSymbolSet​\nField\tType\tDescription\tLabel\ntoken_symbol\tstring\tThe symbol of token.\t\ntoken.ChargeResourceTokenInput​\nField\tType\tDescription\tLabel\ncost_dic\tChargeResourceTokenInput.CostDicEntry\tCollection of charge resource token Symbol->Amount.\trepeated\ncaller\taelf.Address\tThe sender of the transaction.\t\ntoken.ChargeResourceTokenInput.CostDicEntry​\nField\tType\tDescription\tLabel\nkey\tstring\t\t\nvalue\tint64\t\t\ntoken.ChargeTransactionFeesInput​\nField\tType\tDescription\tLabel\nmethod_name\tstring\tThe method name of transaction.\t\ncontract_address\taelf.Address\tThe contract address of transaction.\t\ntransaction_size_fee\tint64\tThe amount of transaction size fee.\t\nsymbols_to_pay_tx_size_fee\tSymbolToPayTxSizeFee\tTransaction fee token information.\trepeated\ntoken.ChargeTransactionFeesOutput​\nField\tType\tDescription\nsuccess\tbool\tWhether the charge was successful.\ncharging_information\tstring\tThe charging information.\ntoken.CheckThresholdInput​\nField\tType\tDescription\nsender\taelf.Address\tThe sender of the transaction.\nsymbol_to_threshold\tSymbolToThresholdEntry\tThe threshold to set Symbol->Threshold.\nis_check_allowance\tbool\tWhether to check the allowance.\ntoken.CheckThresholdInput.SymbolToThresholdEntry​\nField\tType\tDescription\nkey\tstring\t\nvalue\tint64\t\ntoken.ConfigTransactionFeeFreeAllowancesInput​\nField\tType\tDescription\nvalue\tConfigTransactionFeeFreeAllowance\tThe configuration of free allowance.\ntoken.ConfigTransactionFeeFreeAllowance​\nField\tType\tDescription\nsymbol\tstring\tThe symbol of threshold token.\ntransaction_fee_free_allowances\tTransactionFeeFreeAllowances\tThe allowance of each token when a user gets his allowance of the full amount.\nrefresh_seconds\tint64\tThe time needed for a user’s allowance to be refreshed back to the full amount. Unit: second\nthreshold\tint64\tThe required amount of Token in possession for a user to be eligible for transaction fee exemption.\ntoken.TransactionFeeFreeAllowances​\nField\tType\tDescription\nvalue\tTransactionFeeFreeAllowance\tThe allowance of the token.\ntoken.TransactionFeeFreeAllowance​\nField\tType\tDescription\nsymbol\tstring\tToken symbol.\namount\tint64\tThe amount of fee free allowance.\ntoken.TransactionFeeFreeAllowanceConfig​\nField\tType\tDescription\nsymbol\tstring\tThe symbol of threshold token.\nfree_allowances\tTransactionFeeFreeAllowanceMap\tThe allowance of each token when a user gets his allowance of the full amount.\nrefresh_seconds\tint64\tThe time needed for a user’s allowance to be refreshed back to the full amount. Unit: second\nthreshold\tint64\tThe required amount of Token in possession for a user to be eligible for transaction fee exemption.\ntoken.TransactionFeeFreeAllowanceMap​\nField\tType\tDescription\nmap\tmap<string TransactionFeeFreeAllowance>\tfree allowance symbol free allowance\ntoken.ContractTotalResourceTokens​\nField\tType\tDescription\ncontract_address\taelf.Address\tThe contract address.\ntokens_map\tTotalResourceTokensMap\tResource tokens to charge.\ntoken.CreateInput​\nField\tType\tDescription\nsymbol\tstring\tThe symbol of the token/collection/nft.\ntoken_name\tstring\tThe full name of the token/collection/nft.\ntotal_supply\tint64\tThe total supply of the token/collection/nft.\ndecimals\tint32\tThe precision of the toke/collection/nft.\nissuer\taelf.Address\tThe address that has permission to issue the token/collection/nft.\nis_burnable\tbool\tA flag indicating if this token/collection/nft is burnable.\nlock_white_list\taelf.Address\tA whitelist address list used to lock tokens/collection/nft.\nissue_chain_id\tint32\tThe chain id of the token/collection/nft.\nexternal_info\tmap<stringstring>\tAttributes or description of the token/collcection/nft. There is no mandatory constraint on the naming of the key. But it is recommended to use nft as the prefix key to set the nft attribute such asnft_image_url.\nowner\taelf.Address\tThe address that has permission to create nft.\ntoken.CrossChainCreateTokenInput​\nField\tType\tDescription\tLabel\nfrom_chain_id\tint32\tThe chain id of the chain on which the token was created.\t\nparent_chain_height\tint64\tThe height of the transaction that created the token/collection/nft.\t\ntransaction_bytes\tbytes\tThe transaction that created the token/collection/nft.\t\nmerkle_path\taelf.MerklePath\tThe merkle path created from the transaction that created the transaction.\t\ntoken.CrossChainReceiveTokenInput​\nField\tType\tDescription\tLabel\nfrom_chain_id\tint32\tThe source chain id.\t\nparent_chain_height\tint64\tThe height of the transfer transaction.\t\ntransfer_transaction_bytes\tbytes\tThe raw bytes of the transfer transaction.\t\nmerkle_path\taelf.MerklePath\tThe merkle path created from the transfer transaction.\t\ntoken.CrossChainReceived​\nField\tType\tDescription\tLabel\nfrom\taelf.Address\tThe source address of the transferred token.\t\nto\taelf.Address\tThe destination address of the transferred token.\t\nsymbol\tstring\tThe symbol of the received token.\t\namount\tint64\tThe amount of the received token.\t\nmemo\tstring\tThe memo.\t\nfrom_chain_id\tint32\tThe destination chain id.\t\nissue_chain_id\tint32\tThe chain id of the token.\t\nparent_chain_height\tint64\tThe parent chain height of the transfer transaction.\t\ntransfer_transaction_id\taelf.Hash\tThe id of transfer transaction.\t\ntoken.CrossChainTransferInput​\nField\tType\tDescription\tLabel\nto\taelf.Address\tThe receiver of transfer.\t\nsymbol\tstring\tThe symbol of token.\t\namount\tint64\tThe amount of token to transfer.\t\nmemo\tstring\tThe memo.\t\nto_chain_id\tint32\tThe destination chain id.\t\nissue_chain_id\tint32\tThe chain id of the token.\t\ntoken.CrossChainTransferred​\nField\tType\tDescription\tLabel\nfrom\taelf.Address\tThe source address of the transferred token.\t\nto\taelf.Address\tThe destination address of the transferred token.\t\nsymbol\tstring\tThe symbol of the transferred token.\t\namount\tint64\tThe amount of the transferred token.\t\nmemo\tstring\tThe memo.\t\nto_chain_id\tint32\tThe destination chain id.\t\nissue_chain_id\tint32\tThe chain id of the token.\t\ntoken.ExtraTokenListModified​\nField\tType\tDescription\tLabel\nsymbol_list_to_pay_tx_size_fee\tSymbolListToPayTxSizeFee\tTransaction fee token information.\t\ntoken.GetAllowanceInput​\nField\tType\tDescription\tLabel\nsymbol\tstring\tThe symbol of token.\t\nowner\taelf.Address\tThe address of the token owner.\t\nspender\taelf.Address\tThe address of the spender.\t\ntoken.GetAllowanceOutput​\nField\tType\tDescription\tLabel\nsymbol\tstring\tThe symbol of token.\t\nowner\taelf.Address\tThe address of the token owner.\t\nspender\taelf.Address\tThe address of the spender.\t\nallowance\tint64\tThe amount of allowance.\t\ntoken.GetBalanceInput​\nField\tType\tDescription\tLabel\nsymbol\tstring\tThe symbol of token.\t\nowner\taelf.Address\tThe target address of the query.\t\ntoken.GetBalanceOutput​\nField\tType\tDescription\tLabel\nsymbol\tstring\tThe symbol of token.\t\nowner\taelf.Address\tThe target address of the query.\t\nbalance\tint64\tThe balance of the owner.\t\ntoken.GetCrossChainTransferTokenContractAddressInput​\nField\tType\tDescription\tLabel\nchainId\tint32\tThe chain id.\t\ntoken.GetLockedAmountInput​\nField\tType\tDescription\tLabel\naddress\taelf.Address\tThe address of the lock.\t\nsymbol\tstring\tThe token symbol.\t\nlock_id\taelf.Hash\tThe id of the lock.\t\ntoken.GetLockedAmountOutput​\nField\tType\tDescription\tLabel\naddress\taelf.Address\tThe address of the lock.\t\nsymbol\tstring\tThe token symbol.\t\nlock_id\taelf.Hash\tThe id of the lock.\t\namount\tint64\tThe locked amount.\t\ntoken.GetTokenInfoInput​\nField\tType\tDescription\tLabel\nsymbol\tstring\tThe symbol of token.\t\ntoken.GetTransactionFeeDelegateesInput​\nField\tType\tDescription\tLabel\ndelegator_address\taelf.Address\tThe address of delegator.\t\ntoken.GetTransactionFeeDelegateeListInput​\nField\tType\tDescription\tLabel\ndelegator_address\taelf.Address\tThe address of delegator.\t\ncontract_address\taelf.Address\tThe contract address.\t\nmethod_name\tstring\tThe method name.\t\ntoken.GetTransactionFeeDelegateeListOutput​\nField\tType\tDescription\tLabel\ndelegatee_addresses\taelf.Address\tThe address list of delegatee.\trepeated\ntoken.GetTransactionFeeDelegateInfoInput​\nField\tType\tDescription\tLabel\ndelegator_address\taelf.Address\tThe address of delegator.\t\ndelegatee_address\taelf.Address\tThe address of delegatee.\t\ncontract_address\taelf.Address\tThe contract address.\t\nmethod_name\tstring\tThe method name.\t\ntoken.GetTransactionFeeFreeAllowancesConfigOutput​\nField\tType\tDescription\tLabel\nvalue\ttoken.TransactionFeeFreeAllowanceConfigs\tThe configuration of transaction fee free allowance.\trepeated\ntoken.InitializeFromParentChainInput​\nField\tType\tDescription\tLabel\nresource_amount\tInitializeFromParentChainInput.ResourceAmountEntry\tThe amount of resource.\trepeated\nregistered_other_token_contract_addresses\tInitializeFromParentChainInput.RegisteredOtherTokenContractAddressesEntry\tThe token contract addresses.\trepeated\ncreator\taelf.Address\tThe creator of the side chain.\t\ntoken.InitializeFromParentChainInput.RegisteredOtherTokenContractAddressesEntry​\nField\tType\tDescription\tLabel\nkey\tint32\t\t\nvalue\taelf.Address\t\t\ntoken.InitializeFromParentChainInput.ResourceAmountEntry​\nField\tType\tDescription\tLabel\nkey\tstring\t\t\nvalue\tint32\t\t\ntoken.IsInWhiteListInput​\nField\tType\tDescription\tLabel\nsymbol\tstring\tThe symbol of token.\t\naddress\taelf.Address\tThe address to check.\t\ntoken.IssueInput​\nField\tType\tDescription\tLabel\nsymbol\tstring\tThe token/collection/nft symbol to issue.\t\namount\tint64\tThe token/collection/nft amount to issue.\t\nmemo\tstring\tThe memo.\t\nto\taelf.Address\tThe target address to issue.\t\ntoken.Issued​\nField\tType\tDescription\tLabel\nsymbol\tstring\tThe symbol of issued token.\t\namount\tint64\tThe amount of issued token.\t\nmemo\tstring\tThe memo.\t\nto\taelf.Address\tThe issued target address.\t\ntoken.LockInput​\nField\tType\tDescription\tLabel\naddress\taelf.Address\tThe one who wants to lock their token.\t\nlock_id\taelf.Hash\tThe id of the lock.\t\nsymbol\tstring\tThe symbol of the token to lock.\t\nusage\tstring\tA memo.\t\namount\tint64\tThe amount of tokens to lock.\t\ntoken.RemoveTransactionFeeDelegatorInfosInput​\nField\tType\tDescription\tLabel\ndelegator_address\taelf.Address\tThe address of delegator.\t\ndelegate_transaction_list\ttoken.DelegateTransaction\tThe transaction list of delegate.\trepeated\ntoken.RemoveTransactionFeeDelegateeInfosInput​\nField\tType\tDescription\tLabel\ndelegator_address\taelf.Address\tThe address of delegatee.\t\ndelegate_transaction_list\ttoken.DelegateTransaction\tThe transaction list of delegate.\trepeated\ntoken.DelegateTransaction​\nField\tType\tDescription\tLabel\ncontract_address\taelf.Address\tThe contract address.\t\nmethod_name\tstring\tThe method name.\t\ntoken.RentalAccountBalanceInsufficient​\nField\tType\tDescription\tLabel\nsymbol\tstring\tThe symbol of insufficient rental account balance.\t\namount\tint64\tThe balance of the account.\t\ntoken.RentalCharged​\nField\tType\tDescription\tLabel\nsymbol\tstring\tThe symbol of rental fee charged.\t\namount\tint64\tThe amount of rental fee charged.\t\npayer\taelf.Address\tThe payer of rental fee.\t\nreceiver\taelf.Address\tThe receiver of rental fee.\t\ntoken.RemoveTransactionFeeFreeAllowancesConfigInput​\nField\tType\tDescription\tLabel\nsymbols\tstring\tList of symbols to remove from configuration of transaction fee free allowance.\trepeated\ntoken.ResourceTokenClaimed​\nField\tType\tDescription\tLabel\nsymbol\tstring\tThe symbol of fee claimed.\t\namount\tint64\tThe amount of fee claimed.\t\npayer\taelf.Address\tThe payer of fee.\t\nreceiver\taelf.Address\tThe receiver of fee.\t\ntoken.SetTransactionFeeDelegateInfos​\nField\tType\tDescription\tLabel\ndelegator_address\taelf.Address\tThe address of delegator.\t\ndelegate_info_list\ttoken.DelegateInfo\tThe delegate information for the transaction.\trepeated\ntoken.DelegateInfo​\nField\tType\tDescription\tLabel\ndelegations\tmap<string int64>\ttoken symbol amount\t\ncontract_address\taelf.Address\tThe contract address.\t\nmethod_name\tstring\tThe method name.\t\nisUnlimitedDelegate\tbool\tWhether to pay transaction fee continuously without limitation.\t\ntoken.SetPrimaryTokenSymbolInput​\nField\tType\tDescription\tLabel\nsymbol\tstring\tThe symbol of the token.\t\ntoken.SymbolListToPayTxSizeFee​\nField\tType\tDescription\tLabel\nsymbols_to_pay_tx_size_fee\tSymbolToPayTxSizeFee\tTransaction fee token information.\trepeated\ntoken.SymbolToPayTxSizeFee​\nField\tType\tDescription\tLabel\ntoken_symbol\tstring\tThe symbol of token.\t\nbase_token_weight\tint32\tThe charge weight of primary token.\t\nadded_token_weight\tint32\tThe new added token charge weight.\t\ntoken.TransactionFeeClaimed​\nField\tType\tDescription\tLabel\nsymbol\tstring\tThe symbol of fee claimed.\t\namount\tint64\tThe amount of fee claimed.\t\nreceiver\taelf.Address\tThe receiver of fee.\t\ntoken.TransactionFeeFreeAllowancesMap​\nField\tType\tDescription\tLabel\nmap\tmap<string TransactionFeeFreeAllowanceMap>\tthreshold symbol free allowances\t\ntoken.TokenCreated​\nField\tType\tDescription\tLabel\nsymbol\tstring\tThe symbol of the token.\t\ntoken_name\tstring\tThe full name of the token.\t\ntotal_supply\tint64\tThe total supply of the token.\t\ndecimals\tint32\tThe precision of the token.\t\nissuer\taelf.Address\tThe address that created the token.\t\nis_burnable\tbool\tA flag indicating if this token is burnable.\t\nissue_chain_id\tint32\tThe chain id of the token.\t\ntoken.TokenInfo​\nField\tType\tDescription\tLabel\nsymbol\tstring\tThe symbol of the token.\t\ntoken_name\tstring\tThe full name of the token.\t\nsupply\tint64\tThe current supply of the token.\t\ntotal_supply\tint64\tThe total supply of the token.\t\ndecimals\tint32\tThe precision of the token.\t\nissuer\taelf.Address\tThe address that created the token.\t\nis_burnable\tbool\tA flag indicating if this token is burnable.\t\nissue_chain_id\tint32\tThe chain id of the token.\t\nissued\tint64\tThe amount of issued tokens.\t\ntoken.TokenInfoList​\nField\tType\tDescription\tLabel\nvalue\tTokenInfo\tList of token information.\trepeated\ntoken.TotalResourceTokensMap​\nField\tType\tDescription\tLabel\nvalue\tTotalResourceTokensMap.ValueEntry\tResource token dictionary Symbol->Amount.\trepeated\ntoken.TotalResourceTokensMap.ValueEntry​\nField\tType\tDescription\tLabel\nkey\tstring\t\t\nvalue\tint64\t\t\ntoken.TotalResourceTokensMaps​\nField\tType\tDescription\tLabel\nvalue\tContractTotalResourceTokens\tResource tokens to charge.\trepeated\nblock_hash\taelf.Hash\tThe hash of the block processing the transaction.\t\nblock_height\tint64\tThe height of the block processing the transaction.\t\ntoken.TotalTransactionFeesMap​\nField\tType\tDescription\tLabel\nvalue\tTotalTransactionFeesMap.ValueEntry\tToken dictionary that charge transaction fee Symbol->Amount.\trepeated\nblock_hash\taelf.Hash\tThe hash of the block processing the transaction.\t\nblock_height\tint64\tThe height of the block processing the transaction.\t\ntoken.TransactionFeeCharged​\nField\tType\tDescription\tLabel\nsymbol\tstring\tResource tokens to charge.\trepeated\namount\tint64\tThe hash of the block processing the transaction.\t\nchargingAddress\taelf.Hash\tThe height of the block processing the transaction.\t\ntoken.TotalTransactionFeesMap.ValueEntry​\nField\tType\tDescription\tLabel\nkey\tstring\t\t\nvalue\tint64\t\t\ntoken.TransactionFeeBill​\nField\tType\tDescription\tLabel\nfees_map\tTransactionFeeBill.FeesMapEntry\tThe transaction fee dictionary Symbol->fee.\trepeated\ntoken.TransactionFeeBill.FeesMapEntry​\nField\tType\tDescription\tLabel\nkey\tstring\t\t\nvalue\tint64\t\t\ntoken.TransferFromInput​\nField\tType\tDescription\tLabel\nfrom\taelf.Address\tThe source address of the token.\t\nto\taelf.Address\tThe destination address of the token.\t\nsymbol\tstring\tThe symbol of the token to transfer.\t\namount\tint64\tThe amount to transfer.\t\nmemo\tstring\tThe memo.\t\ntoken.TransferInput​\nField\tType\tDescription\tLabel\nto\taelf.Address\tThe receiver of the token.\t\nsymbol\tstring\tThe token symbol to transfer.\t\namount\tint64\tThe amount to transfer.\t\nmemo\tstring\tThe memo.\t\ntoken.Transferred​\nField\tType\tDescription\tLabel\nfrom\taelf.Address\tThe source address of the transferred token.\t\nto\taelf.Address\tThe destination address of the transferred token.\t\nsymbol\tstring\tThe symbol of the transferred token.\t\namount\tint64\tThe amount of the transferred token.\t\nmemo\tstring\tThe memo.\t\ntoken.UnApproveInput​\nField\tType\tDescription\tLabel\nspender\taelf.Address\tThe address that allowance will be decreased.\t\nsymbol\tstring\tThe symbol of token to un-approve.\t\namount\tint64\tThe amount of token to un-approve.\t\ntoken.UnApproved​\nField\tType\tDescription\tLabel\nowner\taelf.Address\tThe address of the token owner.\t\nspender\taelf.Address\tThe address that allowance be decreased.\t\nsymbol\tstring\tThe symbol of un-approved token.\t\namount\tint64\tThe amount of un-approved token.\t\ntoken.UnlockInput​\nField\tType\tDescription\tLabel\naddress\taelf.Address\tThe one want to un-lock his token.\t\nlock_id\taelf.Hash\tId of the lock.\t\nsymbol\tstring\tThe symbol of the token to un-lock.\t\nusage\tstring **\tA memo.\t\namount\tint64 **\tThe amount of tokens to un-lock.\t\ntoken.UpdateCoefficientsInput​\nField\tType\tDescription\tLabel\npiece_numbers\tint32\tThe specify pieces gonna update.\trepeated\ncoefficients\tCalculateFeeCoefficients\tCoefficients of one single type.\t\ntoken.FeeTypeEnum​\nName\tNumber\tDescription\nREAD\t0\t\nSTORAGE\t1\t\nWRITE\t2\t\nTRAFFIC\t3\t\nTX\t4\t\ntoken.SetTransactionFeeDelegationsInput​\nField\tType\tDescription\tLabel\ndelegator_address\taelf.Addresss\tThe address of delegator.\t\ndelegations\tmap<string int64>\t<token symbol delegation>\t\ntoken.SetTransactionFeeDelegationsOutput​\nField\tType\tDescription\tLabel\nsuccess\tbool\tWhether set delegation success.\t\ntoken.RemoveTransactionFeeDelegatorInput​\nField\tType\tDescription\tLabel\ndelegator_address\taelf.Addresss\tThe address of delegator.\t\ntoken.RemoveTransactionFeeDelegateeInput​\nField\tType\tDescription\tLabel\ndelegatee_address\taelf.Addresss\tThe address of delegatee.\t\ntoken.MethodFeeFreeAllowance​\nField\tType\tDescription\tLabel\nsymbol\tstring\tToken symbol\t\namount\tint64\tThe amount of fee free allowance\t\ntoken.GetTransactionFeeDelegationsOfADelegateeInput​\nField\tType\tDescription\tLabel\ndelegatee_address\taelf.Addresss\tThe address of delegatee.\t\ndelegator_address\taelf.Addresss\tThe address of delegator.\t\ntoken.TransactionFeeDelegations​\nField\tType\tDescription\tLabel\ndelegations\tmap<string int64>\tThe number of tokens allowed to be delegated\t\nblock_height\tint64\tThe block height when the information of delegation is added\t\nAElf.Standards.ACS1​\nacs1.MethodFee​\nField\tType\tDescription\tLabel\nsymbol\tstring\tThe token symbol of the method fee.\t\nbasic_fee\tint64\tThe amount of fees to be charged.\t\nacs1.MethodFees​\nField\tType\tDescription\tLabel\nmethod_name\tstring\tThe name of the method to be charged.\t\nfees\tMethodFee\tList of fees to be charged.\trepeated\nis_size_fee_free\tbool\tOptional based on the implementation of SetMethodFee method.\t\nAElf.Standards.ACS2​\nacs2.ResourceInfo​\nField\tType\tDescription\tLabel\nwrite_paths\taelf.ScopedStatePath\tThe state path that depends on when writing.\trepeated\nread_paths\taelf.ScopedStatePath\tThe state path that depends on when reading.\trepeated\nnon_parallelizable\tbool\tWhether the transaction is not executed in parallel.\t\nAElf.Types​\naelf.Address​\nField\tType\tDescription\tLabel\nvalue\tbytes\t\t\naelf.BinaryMerkleTree​\nField\tType\tDescription\tLabel\nnodes\tHash\tThe leaf nodes.\trepeated\nroot\tHash\tThe root node hash.\t\nleaf_count\tint32\tThe count of leaf node.\t\naelf.Hash​\nField\tType\tDescription\tLabel\nvalue\tbytes\t\t\naelf.LogEvent​\nField\tType\tDescription\tLabel\naddress\tAddress\tThe contract address.\t\nname\tstring\tThe name of the log event.\t\nindexed\tbytes\tThe indexed data used to calculate bloom.\trepeated\nnon_indexed\tbytes\tThe non indexed data.\t\naelf.MerklePath​\nField\tType\tDescription\tLabel\nmerkle_path_nodes\tMerklePathNode\tThe merkle path nodes.\trepeated\naelf.MerklePathNode​\nField\tType\tDescription\tLabel\nhash\tHash\tThe node hash.\t\nis_left_child_node\tbool\tWhether it is a left child node.\t\naelf.SInt32Value​\nField\tType\tDescription\tLabel\nvalue\tsint32\t\t\naelf.SInt64Value​\nField\tType\tDescription\tLabel\nvalue\tsint64\t\t\naelf.ScopedStatePath​\nField\tType\tDescription\tLabel\naddress\tAddress\tThe scope address which will be the contract address.\t\npath\tStatePath\tThe path of contract state.\t\naelf.SmartContractRegistration​\nField\tType\tDescription\tLabel\ncategory\tsint32\tThe category of contract code(0: C#).\t\ncode\tbytes\tThe byte array of the contract code.\t\ncode_hash\tHash\tThe hash of the contract code.\t\nis_system_contract\tbool\tWhether it is a system contract.\t\nversion\tint32\tThe version of the current contract.\t\naelf.StatePath​\nField\tType\tDescription\tLabel\nparts\tstring\tThe partial path of the state path.\trepeated\naelf.Transaction​\nField\tType\tDescription\tLabel\nfrom\tAddress\tThe address of the sender of the transaction.\t\nto\tAddress\tThe address of the contract when calling a contract.\t\nref_block_number\tint64\tThe height of the referenced block hash.\t\nref_block_prefix\tbytes\tThe first four bytes of the referenced block hash.\t\nmethod_name\tstring\tThe name of a method in the smart contract at the To address.\t\nparams\tbytes\tThe parameters to pass to the smart contract method.\t\nsignature\tbytes\tWhen signing a transaction it’s actually a subset of the fields: from/to and the target method as well as the parameter that were given. It also contains the reference block number and prefix.\t\naelf.TransactionExecutingStateSet​\nField\tType\tDescription\tLabel\nwrites\tTransactionExecutingStateSet.WritesEntry\tThe changed states.\trepeated\nreads\tTransactionExecutingStateSet.ReadsEntry\tThe read states.\trepeated\ndeletes\tTransactionExecutingStateSet.DeletesEntry >\tThe deleted states.\trepeated\naelf.TransactionExecutingStateSet.DeletesEntry​\nField\tType\tDescription\tLabel\nkey\tstring\t\t\nvalue\tbool\t\t\naelf.TransactionExecutingStateSet.ReadsEntry​\nField\tType\tDescription\tLabel\nkey\tstring\t\t\nvalue\tbool\t\t\naelf.TransactionExecutingStateSet.WritesEntry​\nField\tType\tDescription\tLabel\nkey\tstring\t\t\nvalue\tbytes\t\t\naelf.TransactionResult​\nField\tType\tDescription\tLabel\ntransaction_id\tHash\tThe transaction id.\t\nstatus\tTransactionResultStatus\tThe transaction result status.\t\nlogs\tLogEvent\tThe log events.\trepeated\nbloom\tbytes\tBloom filter for transaction logs. A transaction log event can be defined in the contract and stored in the bloom filter after the transaction is executed. Through this filter we can quickly search for and determine whether a log exists in the transaction result.\t\nreturn_value\tbytes\tThe return value of the transaction execution.\t\nblock_number\tint64\tThe height of the block that packages the transaction.\t\nblock_hash\tHash\tThe hash of the block that packages the transaction.\t\nerror\tstring\tFailed execution error message.\t\naelf.TransactionResultStatus​\nName\tNumber\tDescription\nNOT_EXISTED\t0\tThe execution result of the transaction does not exist.\nPENDING\t1\tThe transaction is in the transaction pool waiting to be packaged.\nFAILED\t2\tTransaction execution failed.\nMINED\t3\tThe transaction was successfully executed and successfully packaged into a block.\nCONFLICT\t4\tWhen executed in parallel there are conflicts with other transactions.\nPENDING_VALIDATION\t5\tThe transaction is waiting for validation.\nNODE_VALIDATION_FAILED\t6\tTransaction validation failed.\nAuthorityInfo​\nField\tType\tDescription\tLabel\ncontract_address\taelf.Address\tThe contract address of the controller.\t\nowner_address\taelf.Address\tThe address of the owner of the contract.\t\nPrevious\nGenesis Contract\nNext\nProfit Contract\nContract Methods\nAElf.Standards.ACS1\nAElf.Standards.ACS2\nAElf.Contracts.MultiToken\ntokenimpl.AdvanceResourceTokenInput\ntokenimpl.DeveloperFeeController\ntokenimpl.GetVirtualAddressForLockingInput\ntokenimpl.OwningRental\ntokenimpl.OwningRental.ResourceAmountEntry\ntokenimpl.OwningRentalUnitValue\ntokenimpl.OwningRentalUnitValue.ResourceUnitValueEntry\nAElf.Standards.ACS1\nAElf.Standards.ACS2\nAElf.Contracts.MultiToken - tokenimpl.AdvanceResourceTokenInput\ntokenimpl.RegisterCrossChainTokenContractAddressInput\ntokenimpl.ValidateTokenInfoExistsInput\ntoken.AllCalculateFeeCoefficients\ntoken.ApproveInput\ntoken.Approved\ntoken.BurnInput\ntoken.Burned\ntoken.CalculateFeeAlgorithmUpdated\ntoken.CalculateFeeCoefficients\ntoken.CalculateFeePieceCoefficients\ntoken.ChainPrimaryTokenSymbolSet\ntoken.ChargeResourceTokenInput\ntoken.ChargeResourceTokenInput.CostDicEntry\ntoken.ChargeTransactionFeesInput\ntoken.ChargeTransactionFeesOutput\ntoken.CheckThresholdInput\ntoken.CheckThresholdInput.SymbolToThresholdEntry\ntoken.ConfigTransactionFeeFreeAllowancesInput\ntoken.ConfigTransactionFeeFreeAllowance\ntoken.TransactionFeeFreeAllowances\ntoken.TransactionFeeFreeAllowance\ntoken.TransactionFeeFreeAllowanceConfig\ntoken.TransactionFeeFreeAllowanceMap\ntoken.ContractTotalResourceTokens\ntoken.CreateInput\ntoken.CrossChainCreateTokenInput\ntoken.CrossChainReceiveTokenInput\ntoken.CrossChainReceived\ntoken.CrossChainTransferInput\ntoken.CrossChainTransferred\ntoken.ExtraTokenListModified\ntoken.GetAllowanceInput\ntoken.GetAllowanceOutput\ntoken.GetBalanceInput\ntoken.GetBalanceOutput\ntoken.GetCrossChainTransferTokenContractAddressInput\ntoken.GetLockedAmountInput\ntoken.GetLockedAmountOutput\ntoken.GetTokenInfoInput\ntoken.GetTransactionFeeDelegateesInput\ntoken.GetTransactionFeeDelegateeListInput\ntoken.GetTransactionFeeDelegateeListOutput\ntoken.GetTransactionFeeDelegateInfoInput\ntoken.GetTransactionFeeFreeAllowancesConfigOutput\ntoken.InitializeFromParentChainInput\ntoken.InitializeFromParentChainInput.RegisteredOtherTokenContractAddressesEntry\ntoken.InitializeFromParentChainInput.ResourceAmountEntry\ntoken.IsInWhiteListInput\ntoken.IssueInput\ntoken.Issued\ntoken.LockInput\ntoken.RemoveTransactionFeeDelegatorInfosInput\ntoken.RemoveTransactionFeeDelegateeInfosInput\ntoken.DelegateTransaction\ntoken.RentalAccountBalanceInsufficient\ntoken.RentalCharged\ntoken.RemoveTransactionFeeFreeAllowancesConfigInput\ntoken.ResourceTokenClaimed\ntoken.SetTransactionFeeDelegateInfos\ntoken.DelegateInfo\ntoken.SetPrimaryTokenSymbolInput\ntoken.SymbolListToPayTxSizeFee\ntoken.SymbolToPayTxSizeFee\ntoken.TransactionFeeClaimed\ntoken.TransactionFeeFreeAllowancesMap\ntoken.TokenCreated\ntoken.TokenInfo\ntoken.TokenInfoList\ntoken.TotalResourceTokensMap\ntoken.TotalResourceTokensMap.ValueEntry\ntoken.TotalResourceTokensMaps\ntoken.TotalTransactionFeesMap\ntoken.TransactionFeeCharged\ntoken.TotalTransactionFeesMap.ValueEntry\ntoken.TransactionFeeBill\ntoken.TransactionFeeBill.FeesMapEntry\ntoken.TransferFromInput\ntoken.TransferInput\ntoken.Transferred\ntoken.UnApproveInput\ntoken.UnApproved\ntoken.UnlockInput\ntoken.UpdateCoefficientsInput\ntoken.FeeTypeEnum\ntoken.SetTransactionFeeDelegationsInput\ntoken.SetTransactionFeeDelegationsOutput\ntoken.RemoveTransactionFeeDelegatorInput\ntoken.RemoveTransactionFeeDelegateeInput\ntoken.MethodFeeFreeAllowance\ntoken.GetTransactionFeeDelegationsOfADelegateeInput\ntoken.TransactionFeeDelegations\nAElf.Standards.ACS1\nacs1.MethodFee\nacs1.MethodFees\nAElf.Standards.ACS2\nacs2.ResourceInfo\nAElf.Types\naelf.Address\naelf.BinaryMerkleTree\naelf.Hash\naelf.LogEvent\naelf.MerklePath\naelf.MerklePathNode\naelf.SInt32Value\naelf.SInt64Value\naelf.ScopedStatePath\naelf.SmartContractRegistration\naelf.StatePath\naelf.Transaction\naelf.TransactionExecutingStateSet\naelf.TransactionExecutingStateSet.DeletesEntry\naelf.TransactionExecutingStateSet.ReadsEntry\naelf.TransactionExecutingStateSet.WritesEntry\naelf.TransactionResult\naelf.TransactionResultStatus\nAuthorityInfo\nPlatform\nTechnology\nAudit Report\nPrivacy\nTerms of Use\nCookie Policy\nDeveloper Resources\nQuick Start\nLearn\nDocs\nTools\nResources\nEcosystem\nOverview\ndApps\naelf Ventures\nBlog\nConnect\nContact Us\nCopyright © 2024 aelf"
    },
    {
      "title": "AELF Docs",
      "url": "https://docs.aelf.com/docs/smart-contract-api/genesis-contract/",
      "html": "Skip to main content\nQuick Start\nLearn\nDocs\nTools\nResources\nBlog\nSearch\nK\nDocs Reference\nSmart Contract API\nAssociation Contract\nReferendum Contract\nParliament Contract\nConsensus Contract\nElection Contract\nGenesis Contract\nMulti Token Contract\nProfit Contract\nCross Chain Contract\nTreasury Contract\nVote Contract\nToken Holder Contract\nEconomic Contract\nToken Converter Contract\nConfiguration Contract\nWeb API\nDocs ReferenceSmart Contract APIGenesis Contract\nGenesis Contract\n\nUsed to manage the deployment and update of contracts. Implement aelf Standards ACS0 and ACS1.\n\nContract Methods​\nMethod Name\tRequest Type\tResponse Type\tDescription\nInitialize\tZero.InitializeInput\tgoogle.protobuf.Empty\tInitializes the genesis contract.\nSetInitialControllerAddress\taelf.Address\tgoogle.protobuf.Empty\tSets the initial controller address.\nChangeContractDeploymentController\tAuthorityInfo\tgoogle.protobuf.Empty\tModifies the contract deployment controller authority.\nChangeCodeCheckController\tAuthorityInfo\tgoogle.protobuf.Empty\tModifies the contract code check controller authority.\nGetContractDeploymentController\tgoogle.protobuf.Empty\tAuthorityInfo\tQueries the ContractDeploymentController authority info.\nGetCodeCheckController\tgoogle.protobuf.Empty\tAuthorityInfo\tQueries the CodeCheckController authority info.\nSetContractProposalExpirationTimePeriod\tZero.SetContractProposalExpirationTimePeriodInput\tgoogle.protobuf.Empty\tSets expiration time for contract proposals.\nGetCurrentContractProposalExpirationTimePeriod\tgoogle.protobuf.Empty\tint32\tGets the expiration time for the current contract proposal.\nAElf.Standards.ACS0​\nContract Methods​\nMethod Name\tRequest Type\tResponse Type\tDescription\nDeploySystemSmartContract\tacs0.SystemContractDeploymentInput\taelf.Address\tDeploys a system smart contract and returns the address.\nDeploySmartContract\tacs0.ContractDeploymentInput\taelf.Address\tDeploys a smart contract and returns the address.\nUpdateSmartContract\tacs0.ContractUpdateInput\taelf.Address\tUpdates a smart contract on chain.\nProposeNewContract\tacs0.ContractDeploymentInput\taelf.Hash\tCreates a proposal to deploy a new contract.\nProposeContractCodeCheck\tacs0.ContractCodeCheckInput\taelf.Hash\tCreates a proposal to check the code of a contract.\nProposeUpdateContract\tacs0.ContractUpdateInput\taelf.Hash\tCreates a proposal to update a contract.\nReleaseApprovedContract\tacs0.ReleaseContractInput\tgoogle.protobuf.Empty\tReleases an approved contract proposal.\nReleaseCodeCheckedContract\tacs0.ReleaseContractInput\tgoogle.protobuf.Empty\tReleases a code-checked contract proposal.\nValidateSystemContractAddress\tacs0.ValidateSystemContractAddressInput\tgoogle.protobuf.Empty\tValidates the existence of an input system contract.\nSetContractProposerRequiredState\tgoogle.protobuf.BoolValue\tgoogle.protobuf.Empty\tSets authority of contract deployment.\nCurrentContractSerialNumber\tgoogle.protobuf.Empty\tgoogle.protobuf.Int64Value\tGets the current serial number of the genesis contract.\nGetContractInfo\taelf.Address\tacs0.ContractInfo\tGets detailed information about a contract.\nGetContractAuthor\taelf.Address\taelf.Address\tGets the author of a contract.\nGetContractHash\taelf.Address\taelf.Hash\tGets the code hash of a contract.\nGetContractAddressByName\taelf.Hash\taelf.Address\tGets the address of a system contract by its name.\nGetSmartContractRegistrationByAddress\taelf.Address\taelf.SmartContractRegistration\tGets the registration of a smart contract by its address.\nGetSmartContractRegistrationByCodeHash\taelf.Hash\taelf.SmartContractRegistration\tGets the registration of a smart contract by code hash.\nDeployUserSmartContract\tacs0.UserContractDeploymentInput\tacs0.DeployUserSmartContractOutput\tDeploys a user smart contract and returns the code hash.\nUpdateUserSmartContract\tacs0.UserContractUpdateInput\tgoogle.protobuf.Empty\tUpdates a user smart contract on chain.\nReleaseApprovedUserSmartContract\tacs0.ReleaseContractInput\tgoogle.protobuf.Empty\tReleases an approved user smart contract proposal.\nPerformDeployUserSmartContract\tacs0.UserContractDeploymentInput\taelf.Address\tPerforms user contract deployment.\nPerformUpdateUserSmartContract\tacs0.UserContractUpdateInput\tgoogle.protobuf.Empty\tPerforms user contract update.\nSetContractAuthor\tacs0.SetContractAuthorInput\tgoogle.protobuf.Empty\tSets the author of a contract.\nSetSigner\taelf.Address\tgoogle.protobuf.Empty\tSets proxy signer for contract deployment/update.\nRemoveSigner\tgoogle.protobuf.Empty\tgoogle.protobuf.Empty\tRemoves proxy signer for contract deployment/update.\nGetSigner\taelf.Address\taelf.Address\tQueries signer of specified address.\nAElf.Standards.ACS1​\nMethod Name\tRequest Type\tResponse Type\tDescription\nSetMethodFee\tacs1.MethodFees\tgoogle.protobuf.Empty\tSets method fees for the specified method.\nChangeMethodFeeController\tAuthorityInfo\tgoogle.protobuf.Empty\tChanges the method fee controller.\nGetMethodFee\tgoogle.protobuf.StringValue\tacs1.MethodFees\tQueries method fee information by method name.\nGetMethodFeeController\tgoogle.protobuf.Empty\tAuthorityInfo\tQueries the method fee controller.\n\nContract Types\n\nAElf.Contracts.Genesis​\nZero.ContractProposingInput​\nField\tType\tDescription\tLabel\nproposer\taelf.Address\tThe address of proposer for contract deployment/update.\t\nstatus\tContractProposingInputStatus\tThe status of proposal.\t\nexpired_time\tgoogle.protobuf.Timestamp\tThe expiration time of proposal.\t\nZero.InitializeInput​\nField\tType\tDescription\tLabel\ncontract_deployment_authority_required\tbool\tWhether contract deployment/update requires authority.\t\nZero.ContractProposingInputStatus​\nName\tNumber\tDescription\nPROPOSED\t0\tProposal is proposed.\nAPPROVED\t1\tProposal is approved by parliament.\nCODE_CHECK_PROPOSED\t2\tCode check is proposed.\nCODE_CHECKED\t3\tPassed code checks.\nZero.SetContractProposalExpirationTimePeriodInput​\nField\tType\tDescription\tLabel\nexpiration_time_period\tint32\tThe period of expiration time\t\nAElf.Standards.ACS0​\nacs0.AuthorUpdated​\nField\tType\tDescription\tLabel\naddress\taelf.address\tThe byte array of the contract code.\t\nold_author\taelf.address\tThe category of contract code (0: C#).\t\nCrossChainCreateToken\taelf.address\tIndicates if the contract is the system contract.\t\nacs0.CodeCheckRequired​\nField\tType\tDescription\tLabel\ncode\tbytes\tThe byte array of the contract code.\t\nproposed_contract_input_hash\taelf.Hash\tThe id of the proposed contract.\t\ncategory\tsint32\tThe category of contract code (0: C#).\t\nis_system_contract\tbool\tIndicates if the contract is the system contract.\t\nis_user_contract\tbool\tIndicates if the contract is the user contract.\t\nacs0.CodeUpdated​\nField\tType\tDescription\tLabel\naddress\taelf.Address\tThe address of the updated contract.\t\nold_code_hash\taelf.Hash\tThe byte array of the old contract code.\t\nnew_code_hash\taelf.Hash\tThe byte array of the new contract code.\t\nversion\tint32\tThe version of the current contract.\t\nacs0.ContractCodeCheckInput​\nField\tType\tDescription\tLabel\ncontract_input\tbytes\tThe byte array of the contract code to be checked.\t\nis_contract_deployment\tbool\tWhether the input contract is to be deployed or updated.\t\ncode_check_release_method\tstring\tMethod to call after code check complete (DeploySmartContract or UpdateSmartContract).\t\nproposed_contract_input_hash\taelf.Hash\tThe id of the proposed contract.\t\ncategory\tsint32\tThe category of contract code (0: C#).\t\nis_system_contract\tbool\tIndicates if the contract is the system contract.\t\nacs0.ContractDeployed​\nField\tType\tDescription\tLabel\nauthor\taelf.Address\tThe author of the contract.\t\ncode_hash\taelf.Hash\tThe hash of the contract code.\t\naddress\taelf.Address\tThe address of the contract.\t\nversion\tint32\tThe version of the current contract.\t\nname\taelf.Hash\tThe name of the contract.\t\ncontract_version\tstring\tThe version of the current contract.\t\ndeployer\taelf.Address\tThe actual address that initiated the contract deployment.\t\nacs0.ContractDeploymentInput​\nField\tType\tDescription\tLabel\ncategory\tsint32\tThe category of contract code (0: C#).\t\ncode\tbytes\tThe byte array of the contract code.\t\ncontract_operation\tacs0.ContractOperation\tThe information needed for contract deployment.\t\nacs0.ContractInfo​\nField\tType\tDescription\tLabel\nserial_number\tint64\tThe serial number of the contract.\t\nauthor\taelf.Address\tThe author of the contract.\t\ncategory\tsint32\tThe category of contract code (0: C#).\t\ncode_hash\taelf.Hash\tThe hash of the contract code.\t\nis_system_contract\tbool\tWhether it is a system contract.\t\nversion\tint32\tThe version of the current contract.\t\ncontract_version\tstring\tThe version of the current contract.\t\nis_user_contract\tbool\tIndicates if the contract is the user contract.\t\ndeployer\taelf.Address\tThe actual address that initiated the contract deployment.\t\nacs0.ContractProposed​\nField\tType\tDescription\tLabel\nproposed_contract_input_hash\taelf.Hash\tThe id of the proposed contract.\t\nacs0.ContractUpdateInput​\nField\tType\tDescription\tLabel\naddress\taelf.Address\tThe contract address that needs to be updated.\t\ncode\tbytes\tThe byte array of the new contract code.\t\ncontract_operation\tacs0.ContractOperation\tThe information needed for contract update.\t\nacs0.UserContractUpdateInput​\nField\tType\tDescription\tLabel\naddress\taelf.Address\tThe user contract address that needs to be updated.\t\ncode\tbytes\tThe byte array of the new user contract code.\t\nacs0.ReleaseContractInput​\nField\tType\tDescription\tLabel\nproposal_id\taelf.Hash\tThe hash of the proposal.\t\nproposed_contract_input_hash\taelf.Hash\tThe id of the proposed contract.\t\nacs0.SystemContractDeploymentInput​\nField\tType\tDescription\tLabel\ncategory\tsint32\tThe category of contract code(0: C#).\t\ncode\tbytes\tThe byte array of the contract code.\t\nname\taelf.Hash\tThe name of the contract. It has to be unique.\t\ntransaction_method_call_list\tSystemContractDeploymentInput.SystemTransactionMethodCallList\tAn initial list of transactions for the system contract, which is executed in sequence when the contract is deployed.\t\nacs0.SystemContractDeploymentInput.SystemTransactionMethodCall​\nField\tType\tDescription\tLabel\nmethod_name\tstring\tThe method name of system transaction.\t\nparams\tbytes\tThe params of system transaction method.\t\nacs0.SystemContractDeploymentInput.SystemTransactionMethodCallList​\nField\tType\tDescription\tLabel\nvalue\tSystemContractDeploymentInput.SystemTransactionMethodCall\tThe list of system transactions.\trepeated\nacs0.ValidateSystemContractAddressInput​\nField\tType\tDescription\tLabel\nsystem_contract_hash_name\taelf.Hash\tThe name hash of the contract.\t\naddress\taelf.Address\tThe address of the contract.\t\nacs0.DeployUserSmartContractOutput​\nField\tType\tDescription\tLabel\ncode_hash\taelf.Hash\tThe deployed or updated contract code hash.\t\nacs0.SetContractAuthorInput​\nField\tType\tDescription\tLabel\ncontract_address\taelf.Address\tThe author's contract address needs to be updated.\t\nnew_author\taelf.Address\tThe new contract author.\t\nacs0.ContractOperation​\nField\tType\tDescription\tLabel\nchain_id\tint32\tThe ID of the chain where the contract is deployed/updated.\t\ncode_hash\taelf.Hash\tThe hash of the contract code.\t\ndeployer\taelf.Address\tThe actual address that initiates the contract deployment.\t\nsalt\taelf.Hash\tThe hash based on which the user contract address is generated.\t\nversion\tint32\tThe version of the deployed/updated contract.\t\nsignature\tbytes\tThe signature for deployer verification.\t\nacs0.UserContractDeploymentInput​\nField\tType\tDescription\tLabel\ncategory\tsint32\tThe category of contract code(0: C#).\t\ncode\tbytes\tThe byte array of the contract code.\t\nsalt\taelf.Hash\tThe hash based on which user contract address is generated.\t\nAElf.Standards.ACS1​\nacs1.MethodFee​\nField\tType\tDescription\tLabel\nsymbol\tstring\tThe token symbol of the method fee.\t\nbasic_fee\tint64\tThe amount of fees to be charged.\t\nacs1.MethodFees​\nField\tType\tDescription\tLabel\nmethod_name\tstring\tThe name of the method to be charged.\t\nfees\tMethodFee (List)\tList of fees to be charged.\trepeated\nis_size_fee_free\tbool\tOptional based on the implementation of SetMethodFee method.\t\nAElf.Types​\naelf.Address​\nField\tType\tDescription\tLabel\nvalue\tbytes\t\t\naelf.BinaryMerkleTree​\nField\tType\tDescription\tLabel\nnodes\tHash (List)\tThe leaf nodes.\trepeated\nroot\tHash\tThe root node hash.\t\nleaf_count\tint32\tThe count of leaf node.\t\naelf.Hash​\nField\tType\tDescription\tLabel\nvalue\tbytes\t\t\naelf.LogEvent​\nField\tType\tDescription\tLabel\naddress\tAddress\tThe contract address.\t\nname\tstring\tThe name of the log event.\t\nindexed\tbytes (List)\tThe indexed data.\trepeated\nnon_indexed\tbytes\tThe non indexed data.\t\naelf.MerklePath​\nField\tType\tDescription\tLabel\nmerkle_path_nodes\tMerklePathNode (List)\tThe merkle path nodes.\trepeated\naelf.MerklePathNode​\nField\tType\tDescription\tLabel\nhash\tHash\tThe node hash.\t\nis_left_child_node\tbool\tWhether it is a left child node.\t\naelf.SInt32Value​\nField\tType\tDescription\tLabel\nvalue\tsint32\t\t\naelf.SInt64Value​\nField\tType\tDescription\tLabel\nvalue\tsint64\t\t\naelf.ScopedStatePath​\nField\tType\tDescription\tLabel\naddress\tAddress\tThe scope address, which will be the contract address.\t\npath\tStatePath\tThe path of contract state.\t\naelf.SmartContractRegistration​\nField\tType\tDescription\tLabel\ncategory\tsint32\tThe category of contract code(0: C#).\t\ncode\tbytes\tThe byte array of the contract code.\t\ncode_hash\tHash\tThe hash of the contract code.\t\nis_system_contract\tbool\tWhether it is a system contract.\t\nversion\tint32\tThe version of the current contract.\t\naelf.StatePath​\nField\tType\tDescription\tLabel\nparts\tstring (List)\tThe partial path of the state path.\trepeated\naelf.Transaction​\nField\tType\tDescription\tLabel\nfrom\taelf.Address\tThe address of the sender of the transaction.\t\nto\taelf.Address\tThe address of the contract when calling a contract.\t\nref_block_number\tint64\tThe height of the referenced block hash.\t\nref_block_prefix\tbytes\tThe first four bytes of the referenced block hash.\t\nmethod_name\tstring\tThe name of a method in the smart contract at the To address.\t\nparams\tbytes\tThe parameters to pass to the smart contract method.\t\nsignature\tbytes\tWhen signing a transaction, it's a subset of the fields: from/to and the target method as well as the parameter that were given.\t\naelf.TransactionExecutingStateSet​\nField\tType\tDescription\tLabel\nwrites\tTransactionExecutingStateSet.WritesEntry (see details)\tThe changed states.\trepeated\nreads\tTransactionExecutingStateSet.ReadsEntry (see details)\tThe read states.\trepeated\ndeletes\tTransactionExecutingStateSet.DeletesEntry (see details)\tThe deleted states.\trepeated\naelf.TransactionExecutingStateSet.DeletesEntry​\nField\tType\tDescription\tLabel\nkey\tstring\t\t\nvalue\tbool\t\t\naelf.TransactionExecutingStateSet.ReadsEntry​\nField\tType\tDescription\tLabel\nkey\tstring\t\t\nvalue\tbool\t\t\naelf.TransactionExecutingStateSet.WritesEntry​\nField\tType\tDescription\tLabel\nkey\tstring\t\t\nvalue\tbytes\t\t\naelf.TransactionResult​\nField\tType\tDescription\tLabel\ntransaction_id\taelf.Hash\tThe transaction id.\t\nstatus\tTransactionResultStatus\tThe transaction result status.\t\nlogs\taelf.LogEvent (List)\tThe log events.\trepeated\nbloom\tbytes\tBloom filter for transaction logs. A transaction log event can be defined in the contract and stored in the bloom filter after the transaction is executed.\t\nreturn_value\tbytes\tThe return value of the transaction execution.\t\nblock_number\tint64\tThe height of the block that packages the transaction.\t\nblock_hash\taelf.Hash\tThe hash of the block that packages the transaction.\t\nerror\tstring\tFailed execution error message.\t\naelf.TransactionResultStatus​\nName\tNumber\tDescription\nNOT_EXISTED\t0\tThe execution result of the transaction does not exist.\nPENDING\t1\tThe transaction is in the transaction pool waiting to be packaged.\nFAILED\t2\tTransaction execution failed.\nMINED\t3\tThe transaction was successfully executed and successfully packaged into a block.\nCONFLICT\t4\tWhen executed in parallel, there are conflicts with other transactions.\nPENDING_VALIDATION\t5\tThe transaction is waiting for validation.\nNODE_VALIDATION_FAILED\t6\tTransaction validation failed.\nAuthorityInfo​\nField\tType\tDescription\tLabel\ncontract_address\taelf.Address\tThe contract address of the controller.\t\nowner_address\taelf.Address\tThe address of the owner of the contract.\t\nPrevious\nElection Contract\nNext\nMulti Token Contract\nContract Methods\nAElf.Standards.ACS0\nContract Methods\nAElf.Standards.ACS1\nAElf.Contracts.Genesis\nZero.ContractProposingInput\nZero.InitializeInput\nZero.ContractProposingInputStatus\nZero.SetContractProposalExpirationTimePeriodInput\nAElf.Standards.ACS0\nacs0.AuthorUpdated\nacs0.CodeCheckRequired\nacs0.CodeUpdated\nacs0.ContractCodeCheckInput\nacs0.ContractDeployed\nacs0.ContractDeploymentInput\nacs0.ContractInfo\nacs0.ContractProposed\nacs0.ContractUpdateInput\nacs0.UserContractUpdateInput\nacs0.ReleaseContractInput\nacs0.SystemContractDeploymentInput\nacs0.SystemContractDeploymentInput.SystemTransactionMethodCall\nacs0.SystemContractDeploymentInput.SystemTransactionMethodCallList\nacs0.ValidateSystemContractAddressInput\nacs0.DeployUserSmartContractOutput\nacs0.SetContractAuthorInput\nacs0.ContractOperation\nacs0.UserContractDeploymentInput\nAElf.Standards.ACS1\nacs1.MethodFee\nacs1.MethodFees\nAElf.Types\naelf.Address\naelf.BinaryMerkleTree\naelf.Hash\naelf.LogEvent\naelf.MerklePath\naelf.MerklePathNode\naelf.SInt32Value\naelf.SInt64Value\naelf.ScopedStatePath\naelf.SmartContractRegistration\naelf.StatePath\naelf.Transaction\naelf.TransactionExecutingStateSet\naelf.TransactionExecutingStateSet.DeletesEntry\naelf.TransactionExecutingStateSet.ReadsEntry\naelf.TransactionExecutingStateSet.WritesEntry\naelf.TransactionResult\naelf.TransactionResultStatus\nAuthorityInfo\nPlatform\nTechnology\nAudit Report\nPrivacy\nTerms of Use\nCookie Policy\nDeveloper Resources\nQuick Start\nLearn\nDocs\nTools\nResources\nEcosystem\nOverview\ndApps\naelf Ventures\nBlog\nConnect\nContact Us\nCopyright © 2024 aelf"
    },
    {
      "title": "AELF Docs",
      "url": "https://docs.aelf.com/docs/smart-contract-api/election-contract/",
      "html": "Skip to main content\nQuick Start\nLearn\nDocs\nTools\nResources\nBlog\nSearch\nDocs Reference\nSmart Contract API\nAssociation Contract\nReferendum Contract\nParliament Contract\nConsensus Contract\nElection Contract\nGenesis Contract\nMulti Token Contract\nProfit Contract\nCross Chain Contract\nTreasury Contract\nVote Contract\nToken Holder Contract\nEconomic Contract\nToken Converter Contract\nConfiguration Contract\nWeb API\nDocs ReferenceSmart Contract APIElection Contract\nElection Contract\n\nUsed for voting for Block Producers.Implement aelf Standards ACS1.\n\nContract Methods​\nMethod Name\tRequest Type\tResponse Type\tDescription\nInitialElectionContract\tElection.InitialElectionContractInput\tgoogle.protobuf.Empty\tInitialize the election contract.\nRegisterElectionVotingEvent\tgoogle.protobuf.Empty\tgoogle.protobuf.Empty\tRegister a new voting item through the vote contract.\nTakeSnapshot\tElection.TakeElectionSnapshotInput\tgoogle.protobuf.Empty\tTake a snapshot according to the term number and distribute profits.\nAnnounceElection\taelf.Address\tgoogle.protobuf.Empty\tTo be a block producer, a user should first register to be a candidate and lock some tokens as a deposit. If the data center is not full, the user will be added automatically and get one weight for sharing a bonus in the future.\nQuitElection\tgoogle.protobuf.StringValue\tgoogle.protobuf.Empty\tA candidate is able to quit the election provided they are not currently elected. If you quit successfully, the candidate will get their locked tokens back and will not receive any more bonus.\nVote\tElection.VoteMinerInput\taelf.Hash\tUsed for voting for a candidate to be elected. The tokens you vote with will be locked until the end time. According to the number of tokens you voted and their lock time, you can get a corresponding weight for sharing the bonus in the future. Returns the vote id.\nChangeVotingOption\tElection.ChangeVotingOptionInput\tgoogle.protobuf.Empty\tBefore the end time, you are able to change your vote target to other candidates.\nWithdraw\taelf.Hash\tgoogle.protobuf.Empty\tAfter the lock time, your locked tokens will be unlocked, and you can withdraw them according to the vote id.\nUpdateCandidateInformation\tElection.UpdateCandidateInformationInput\tgoogle.protobuf.Empty\tUpdate candidate information by the consensus contract.\nUpdateMultipleCandidateInformation\tElection.UpdateMultipleCandidateInformationInput\tgoogle.protobuf.Empty\tBatch update candidate information by the consensus contract.\nUpdateMinersCount\tElection.UpdateMinersCountInput\tgoogle.protobuf.Empty\tUpdate the count of miners by the consensus contract.\nSetProfitsReceiver\tElection.SetProfitsReceiverInput\tgoogle.protobuf.Empty\tSet the collect profits receiver address.\nSetTreasurySchemeIds\tElection.SetTreasurySchemeIdsInput\tgoogle.protobuf.Empty\tSet the treasury profit ids.\nSetVoteWeightInterest\tElection.VoteWeightInterestList\tgoogle.protobuf.Empty\tSet the weight of vote interest.\nSetVoteWeightProportion\tElection.VoteWeightProportion\tgoogle.protobuf.Empty\tSet the weight of lock time and votes in the calculation of voting weight.\nChangeVoteWeightInterestController\tAuthorityInfo\tgoogle.protobuf.Empty\tChange the controller for the weight of vote interest.\nReplaceCandidatePubkey\tElection.ReplaceCandidatePubkeyInput\tgoogle.protobuf.Empty\tCandidate admin can replace the candidate pubkey with a new pubkey.\nSetCandidateAdmin\tElection.SetCandidateAdminInput\tgoogle.protobuf.Empty\tSet the admin address of the candidate (mostly supply).\nGetCandidates\tgoogle.protobuf.Empty\tElection.PubkeyList\tGet all candidates' public keys.\nGetVotedCandidates\tgoogle.protobuf.Empty\tElection.PubkeyList\tGet all candidates whose number of votes is greater than 0.\n\t\t\t\nGetCandidateInformation\tgoogle.protobuf.StringValue\tElection.CandidateInformation\tGet a candidate’s information.\nGetVictories\tgoogle.protobuf.Empty\tElection.PubkeyList\tGet the victories of the latest term.\nGetTermSnapshot\tElection.GetTermSnapshotInput\tElection.TermSnapshot\tGet the snapshot of term according to the term number.\nGetMinersCount\tgoogle.protobuf.Empty\tgoogle.protobuf.Int32Value\tGet the count of miners.\nGetElectionResult\tElection.GetElectionResultInput\tElection.ElectionResult\tGet the election result according to the term id.\nGetElectorVote\tgoogle.protobuf.StringValue\tElection.ElectorVote\tGet the voter information according to the voter public key.\nGetElectorVoteWithRecords\tgoogle.protobuf.StringValue\tElection.ElectorVote\tGets the voter information including the active voting records (excluding withdrawn voting records).\nGetElectorVoteWithAllRecords\tgoogle.protobuf.StringValue\tElection.ElectorVote\tGets the voter information including the active and withdrawn voting records.\nGetCandidateVote\tgoogle.protobuf.StringValue\tElection.CandidateVote\tGet voting information for the candidate according to the public key of the candidate.\nGetCandidateVoteWithRecords\tgoogle.protobuf.StringValue\tElection.CandidateVote\tGet voting information for the candidate according to the public key of the candidate.\nGetCandidateVoteWithAllRecords\tgoogle.protobuf.StringValue\tElection.CandidateVote\tGet voting information for the candidate according to the public key of the candidate (including the active and withdrawn voting records).\nGetVotersCount\tgoogle.protobuf.Empty\tgoogle.protobuf.Int64Value\tGet the total number of voters.\nGetVotesAmount\tgoogle.protobuf.Empty\tgoogle.protobuf.Int64Value\tGet the total number of vote tokens.\nGetPageableCandidateInformation\tElection.PageInformation\tElection.GetPageableCandidateInformationOutput\tGet candidate information according to the index and length.\nGetMinerElectionVotingItemId\tgoogle.protobuf.Empty\taelf.Hash\tGet the voting item id of miner election.\nGetDataCenterRankingList\tgoogle.protobuf.Empty\tElection.DataCenterRankingList\tGet the data center ranking list.\nGetVoteWeightSetting\tgoogle.protobuf.Empty\tElection.VoteWeightInterestList\tGet the weight of vote interest.\nGetVoteWeightProportion\tgoogle.protobuf.Empty\tElection.VoteWeightProportion\tGet the weight of lock time and votes in the calculation of voting weight.\nGetCalculateVoteWeight\tElection.VoteInformation\tgoogle.protobuf.Int64Value\tUsed to calculate the bonus weights that users can get by voting.\nGetVoteWeightInterestController\tgoogle.protobuf.Empty\tAuthorityInfo\tQuery the controller for the weight of vote interest.\nGetMinerReplacementInformation\tElection.GetMinerReplacementInformationInput\tElection.MinerReplacementInformation\tInspect the evil nodes included in the specified miners and return to the replacement node.\nGetCandidateAdmin\tgoogle.protobuf.StringValue\taelf.Address\tQuery candidate admin.\nGetNewestPubkey\tgoogle.protobuf.StringValue\tgoogle.protobuf.StringValue\tQuery the newest pubkey of an old pubkey.\nGetReplacedPubkey\tgoogle.protobuf.StringValue\tgoogle.protobuf.StringValue\tQuery the old pubkey.\nAElf.Standards.ACS1​\nMethod Name\tRequest Type\tResponse Type\tDescription\nSetMethodFee\tacs1.MethodFees\tgoogle.protobuf.Empty\tSet the method fees for the specified method. Note that this will override all fees of the method.\nChangeMethodFeeController\tAuthorityInfo\tgoogle.protobuf.Empty\tChange the method fee controller, the default is parliament and default organization.\nGetMethodFee\tgoogle.protobuf.StringValue\tacs1.MethodFees\tQuery method fee information by method name.\nGetMethodFeeController\tgoogle.protobuf.Empty\tAuthorityInfo\tQuery the method fee controller.\n\nContract Types\n\nAElf.Contracts.Election​\nElection.CandidateDetail​\nField\tType\tDescription\tLabel\ncandidate_information\tCandidateInformation\tThe candidate information.\t\nobtained_votes_amount\tint64\tThe number of votes a candidate has obtained.\t\nElection.CandidateInformation​\nField\tType\tDescription\tLabel\npubkey\tstring\tCandidate’s public key.\t\nterms\tint64\tThe number of terms that the candidate is elected.\trepeated\nproduced_blocks\tint64\tThe number of blocks the candidate has produced.\t\nmissed_time_slots\tint64\tThe time slot for which the candidate failed to produce blocks.\t\ncontinual_appointment_count\tint64\tThe count of continual appointment.\t\nannouncement_transaction_id\taelf.Hash\tThe transaction id when the candidate announced.\t\nis_current_candidate\tbool\tIndicate whether the candidate can be elected in the current term.\t\nElection.CandidatePubkeyReplaced​\nField\tType\tDescription\tLabel\nold_pubkey\tstring\t\t\nnew_pubkey\tstring\t\t\nElection.CandidateVote​\nField\tType\tDescription\tLabel\nobtained_active_voting_record_ids\taelf.Hash\tThe active voting record ids obtained.\trepeated\nobtained_withdrawn_voting_record_ids\taelf.Hash\tThe active voting record ids that were withdrawn.\trepeated\nobtained_active_voted_votes_amount\tint64\tThe total number of active votes obtained.\t\nall_obtained_voted_votes_amount\tint64\tThe total number of votes obtained.\t\nobtained_active_voting_records\tElectionVotingRecord\tThe active voting records.\trepeated\nobtained_withdrawn_votes_records\tElectionVotingRecord\tThe voting records that were withdrawn.\trepeated\npubkey\tbytes\tPublic key for candidate.\t\nElection.ChangeVotingOptionInput​\nField\tType\tDescription\tLabel\nvote_id\taelf.Hash\tThe vote id to change.\t\ncandidate_pubkey\tstring\tThe new candidate public key.\t\nElection.DataCenterRankingList​\nField\tType\tDescription\tLabel\ndata_centers\tDataCenterRankingList.DataCentersEntry\tThe top n * 5 candidates with vote amount, candidate public key -> vote amount.\trepeated\nElection.DataCenterRankingList.DataCentersEntry​\nField\tType\tDescription\tLabel\nkey\tstring\t\t\nvalue\tint64\t\t\nElection.ElectionResult​\nField\tType\tDescription\tLabel\nterm_number\tint64\tThe term number\t\nresults\tElectionResult.ResultsEntry\tThe election result, candidates’ public key -> number of votes.\trepeated\nis_active\tbool\tWhether an election is currently being held.\t\nElection.ElectionResult.ResultsEntry​\nField\tType\tDescription\tLabel\nkey\tstring\t\t\nvalue\tint64\t\t\nElection.ElectionVotingRecord​\nField\tType\tDescription\tLabel\nvoter\taelf.Address\tThe address of voter.\t\ncandidate\tstring\tThe public key of candidate.\t\namount\tint64\tAmount of voting.\t\nterm_number\tint64\tThe term number of voting.\t\nvote_id\taelf.Hash\tThe vote id.\t\nlock_time\tint64\tVote lock time.\t\nunlock_timestamp\tgoogle.protobuf.Timestamp\tThe unlock timestamp.\t\nwithdraw_timestamp\tgoogle.protobuf.Timestamp\tThe withdraw timestamp.\t\nvote_timestamp\tgoogle.protobuf.Timestamp\tThe vote timestamp.\t\nis_withdrawn\tbool\tIndicates if the vote has been withdrawn.\t\nweight\tint64\tVote weight for sharing bonus.\t\nis_change_target\tbool\tWhether vote others.\t\nElection.ElectorVote​\nField\tType\tDescription\tLabel\nactive_voting_record_ids\taelf.Hash\tThe active voting record ids.\trepeated\nwithdrawn_voting_record_ids\taelf.Hash\tThe voting record ids that were withdrawn.\trepeated\nactive_voted_votes_amount\tint64\tThe total number of active votes.\t\nall_voted_votes_amount\tint64\tThe total number of votes (including the number of votes withdrawn).\t\nactive_voting_records\tElectionVotingRecord\tThe active voting records.\trepeated\nwithdrawn_votes_records\tElectionVotingRecord\tThe voting records that were withdrawn.\trepeated\npubkey\tbytes\tPublic key for voter.\t\naddress\taelf.Address\tAddress for voter.\t\nElection.EvilMinerDetected​\nField\tType\tDescription\tLabel\npubkey\tstring\tThe public key of evil miner.\t\nElection.GetElectionResultInput​\nField\tType\tDescription\tLabel\nterm_number\tint64\tThe term number.\t\nElection.GetMinerReplacementInformationInput​\nField\tType\tDescription\tLabel\ncurrent_miner_list\tstring\tThe current miner list to inspect.\trepeated\nElection.GetPageableCandidateInformationOutput​\nField\tType\tDescription\tLabel\nvalue\tCandidateDetail\tThe details of the candidates.\trepeated\nElection.GetTermSnapshotInput​\nField\tType\tDescription\tLabel\nterm_number\tint64\tThe term number.\t\nElection.InitialElectionContractInput​\nField\tType\tDescription\tLabel\nminimum_lock_time\tint64\tMinimum number of seconds for locking.\t\nmaximum_lock_time\tint64\tMaximum number of seconds for locking.\t\nminer_list\tstring\tThe current miner list.\trepeated\ntime_each_term\tint64\tThe number of seconds per term.\t\nminer_increase_interval\tint64\tThe interval second that increases the number of miners.\t\nElection.MinerReplacementInformation​\nField\tType\tDescription\tLabel\nalternative_candidate_pubkeys\tstring\tThe alternative candidate public keys.\trepeated\nevil_miner_pubkeys\tstring\tThe evil miner public keys.\trepeated\nElection.PageInformation​\nField\tType\tDescription\tLabel\nstart\tint32\tThe start index.\t\nlength\tint32\tThe number of records.\t\nElection.PubkeyList​\nField\tType\tDescription\tLabel\nvalue\tbytes\tCandidates’ public keys\trepeated\nElection.ReplaceCandidatePubkeyInput​\nField\tType\tDescription\tLabel\nold_pubkey\tstring\t\t\nnew_pubkey\tstring\t\t\nElection.SetCandidateAdminInput​\nField\tType\tDescription\tLabel\npubkey\tstring\t\t\nadmin\taelf.Address\t\t\nElection.SetProfitsReceiverInput​\nField\tType\tDescription\tLabel\ncandidate_pubkey\tstring\tThe candidate's public key.\t\nprofits_receiver_address\taelf.Address\tThe address of profits receiver.\t\nprevious_receiver_address\taelf.Address\tThe previous address of profits receiver.\t\nElection.SetTreasurySchemeIdsInput​\nField\tType\tDescription\tLabel\ntreasury_hash\taelf.Hash\tThe scheme id of treasury reward.\t\nwelfare_hash\taelf.Hash\tThe scheme id of welfare reward.\t\nsubsidy_hash\taelf.Hash\tThe scheme id of subsidy reward.\t\nvotes_reward_hash\taelf.Hash\tThe scheme id of votes reward.\t\nre_election_reward_hash\taelf.Hash\tThe scheme id of re-election reward.\t\nElection.TakeElectionSnapshotInput​\nField\tType\tDescription\tLabel\nterm_number\tint64\tThe term number to take snapshot.\t\nmined_blocks\tint64\tThe number of mined blocks of this term.\t\nround_number\tint64\tThe end round number of this term.\t\nElection.TermSnapshot​\nField\tType\tDescription\tLabel\nend_round_number\tint64\tThe end round number of this term.\t\nmined_blocks\tint64\tThe number of blocks mined in this term.\t\nelection_result\tTermSnapshot.ElectionResultEntry (key: string, value: int64)\tThe election result, candidates’ public key -> number of votes.\trepeated\nElection.TermSnapshot.ElectionResultEntry​\nField\tType\tDescription\tLabel\nkey\tstring\t\t\nvalue\tint64\t\t\nElection.UpdateCandidateInformationInput​\nField\tType\tDescription\tLabel\npubkey\tstring\tThe candidate public key.\t\nrecently_produced_blocks\tint64\tThe number of blocks recently produced.\t\nrecently_missed_time_slots\tint64\tThe number of time slots recently missed.\t\nis_evil_node\tbool\tIs it an evil node. If true, will remove the candidate.\t\nElection.UpdateMinersCountInput​\nField\tType\tDescription\tLabel\nminers_count\tint32\tThe count of miner.\t\nElection.UpdateMultipleCandidateInformationInput​\nField\tType\tDescription\tLabel\nvalue\tUpdateCandidateInformationInput (see below)\tThe candidate information to update.\trepeated\nUpdateCandidateInformationInput​\nField\tType\tDescription\tLabel\npubkey\tstring\tThe candidate public key.\t\nrecently_produced_blocks\tint64\tThe number of blocks recently produced.\t\nrecently_missed_time_slots\tint64\tThe number of time slots recently missed.\t\nis_evil_node\tbool\tIs it an evil node. If true, will remove the candidate.\t\nElection.UpdateTermNumberInput​\nField\tType\tDescription\tLabel\nterm_number\tint64\tThe term number.\t\nElection.VoteInformation​\nField\tType\tDescription\tLabel\namount\tint64\tAmount of voting.\t\nlock_time\tint64\tVote lock time.\t\nElection.VoteMinerInput​\nField\tType\tDescription\tLabel\ncandidate_pubkey\tstring\tThe candidate public key.\t\namount\tint64\tThe amount token to vote.\t\nend_timestamp\tgoogle.protobuf.Timestamp\tThe end timestamp of this vote.\t\ntoken\taelf.Hash\tUsed to generate vote id.\t\nElection.VoteWeightInterest​\nField\tType\tDescription\tLabel\nday\tint32\tNumber of days locked.\t\ninterest\tint32\tLocked interest.\t\ncapital\tint32\t\t\nElection.VoteWeightInterestList​\nField\tType\tDescription\tLabel\nvote_weight_interest_infos\tVoteWeightInterest (see above)\tThe weight of vote interest.\trepeated\nElection.VoteWeightProportion​\nField\tType\tDescription\tLabel\ntime_proportion\tint32\tThe weight of lock time.\t\namount_proportion\tint32\tThe weight of the votes cast.\t\nAElf.Standards.ACS1​\nacs1.MethodFee​\nField\tType\tDescription\tLabel\nsymbol\tstring\tThe token symbol of the method fee.\t\nbasic_fee\tint64\tThe amount of fees to be charged.\t\nacs1.MethodFees​\nField\tType\tDescription\tLabel\nmethod_name\tstring\tThe name of the method to be charged.\t\nfees\tMethodFee (see above)\tList of fees to be charged.\trepeated\nis_size_fee_free\tbool\tOptional based on the implementation of SetMethodFee method.\t\nAElf.Types​\naelf.Address​\nField\tType\tDescription\tLabel\nvalue\tbytes\t\t\naelf.BinaryMerkleTree​\nField\tType\tDescription\tLabel\nnodes\tHash (see below)\tThe leaf nodes.\trepeated\nroot\tHash (see below)\tThe root node hash.\t\nleaf_count\tint32\tThe count of leaf node.\t\naelf.Hash​\nField\tType\tDescription\tLabel\nvalue\tbytes\t\t\naelf.LogEvent​\nField\tType\tDescription\tLabel\naddress\tAddress (see above)\tThe contract address.\t\nname\tstring\tThe name of the log event.\t\nindexed\tbytes (see below)\tThe indexed data, used to calculate bloom.\trepeated\nnon_indexed\tbytes\tThe non indexed data.\t\naelf.MerklePath​\nField\tType\tDescription\tLabel\nmerkle_path_nodes\tMerklePathNode (see below)\tThe merkle path nodes.\trepeated\naelf.MerklePathNode​\nField\tType\tDescription\tLabel\nhash\tHash\t\t\nis_left_child\tbool\t\t\naelf.SInt32Value​\nField\tType\tDescription\tLabel\nvalue\tsint32\t\t\naelf.SInt64Value​\nField\tType\tDescription\tLabel\nvalue\tsint64\t\t\naelf.ScopedStatePath​\nField\tType\tDescription\tLabel\naddress\tAddress\tThe scope address, which will be the contract address.\t\npath\tStatePath\tThe path of contract state.\t\naelf.SmartContractRegistration​\nField\tType\tDescription\tLabel\ncategory\tsint32\tThe category of contract code(0: C#).\t\ncode\tbytes\tThe byte array of the contract code.\t\ncode_hash\tHash\tThe hash of the contract code.\t\nis_system_contract\tbool\tWhether it is a system contract.\t\nversion\tint32\tThe version of the current contract.\t\naelf.StatePath​\nField\tType\tDescription\tLabel\nparts\tstring\tThe partial path of the state path.\trepeated\naelf.Transaction​\nField\tType\tDescription\tLabel\nfrom\tAddress\tThe address of the sender of the transaction.\t\nto\tAddress\tThe address of the contract when calling a contract.\t\nref_block_number\tint64\tThe height of the referenced block hash.\t\nref_block_prefix\tbytes\tThe first four bytes of the referenced block hash.\t\nmethod_name\tstring\tThe name of a method in the smart contract at the To address.\t\nparams\tbytes\tThe parameters to pass to the smart contract method.\t\nsignature\tbytes\tWhen signing a transaction it’s actually a subset of the fields: from/to and the target method as well as the parameter that were given. It also contains the reference block number and prefix.\t\naelf.TransactionExecutingStateSet​\nField\tType\tDescription\tLabel\nwrites\tTransactionExecutingStateSet.WritesEntry\tThe changed states.\trepeated\nreads\tTransactionExecutingStateSet.ReadsEntry\tThe read states.\trepeated\ndeletes\tTransactionExecutingStateSet.DeletesEntry\tThe deleted states.\trepeated\naelf.TransactionExecutingStateSet.DeletesEntry​\nField\tType\tDescription\tLabel\nkey\tstring\t\t\nvalue\tbool\t\t\naelf.TransactionExecutingStateSet.ReadsEntry​\nField\tType\tDescription\tLabel\nkey\tstring\t\t\nvalue\tbool\t\t\naelf.TransactionExecutingStateSet.WritesEntry​\nField\tType\tDescription\tLabel\nkey\tstring\t\t\nvalue\tbytes\t\t\naelf.TransactionResult​\nField\tType\tDescription\tLabel\ntransaction_id\tHash\tThe transaction id.\t\nstatus\tTransactionResultStatus\tThe transaction result status.\t\nlogs\tLogEvent\tThe log events.\trepeated\nbloom\tbytes\tBloom filter for transaction logs.\t\nreturn_value\tbytes\tThe return value of the transaction execution.\t\nblock_number\tint64\tThe height of the block hat packages the transaction.\t\nblock_hash\tHash\tThe hash of the block hat packages the transaction.\t\nerror\tstring\tFailed execution error message.\t\naelf.TransactionResultStatus​\nName\tNumber\tDescription\nNOT_EXISTED\t0\tThe execution result of the transaction does not exist.\nPENDING\t1\tThe transaction is in the transaction pool waiting to be packaged.\nFAILED\t2\tTransaction execution failed.\nMINED\t3\tThe transaction was successfully executed and successfully packaged into a block.\nCONFLICT\t4\tWhen executed in parallel, there are conflicts with other transactions.\nPENDING_VALIDATION\t5\tThe transaction is waiting for validation.\nNODE_VALIDATION_FAILED\t6\tTransaction validation failed.\nAuthorityInfo​\nField\tType\tDescription\tLabel\ncontract_address\taelf.Address\tThe contract address of the controller.\t\nowner_address\taelf.Address\tThe address of the owner of the contract.\t\nPrevious\nConsensus Contract\nNext\nGenesis Contract\nContract Methods\nAElf.Standards.ACS1\nAElf.Contracts.Election\nElection.CandidateDetail\nElection.CandidateInformation\nElection.CandidatePubkeyReplaced\nElection.CandidateVote\nElection.ChangeVotingOptionInput\nElection.DataCenterRankingList\nElection.DataCenterRankingList.DataCentersEntry\nElection.ElectionResult\nElection.ElectionResult.ResultsEntry\nElection.ElectionVotingRecord\nElection.ElectorVote\nElection.EvilMinerDetected\nElection.GetElectionResultInput\nElection.GetMinerReplacementInformationInput\nElection.GetPageableCandidateInformationOutput\nElection.GetTermSnapshotInput\nElection.InitialElectionContractInput\nElection.MinerReplacementInformation\nElection.PageInformation\nElection.PubkeyList\nElection.ReplaceCandidatePubkeyInput\nElection.SetCandidateAdminInput\nElection.SetProfitsReceiverInput\nElection.SetTreasurySchemeIdsInput\nElection.TakeElectionSnapshotInput\nElection.TermSnapshot\nElection.TermSnapshot.ElectionResultEntry\nElection.UpdateCandidateInformationInput\nElection.UpdateMinersCountInput\nElection.UpdateMultipleCandidateInformationInput\nUpdateCandidateInformationInput\nElection.UpdateTermNumberInput\nElection.VoteInformation\nElection.VoteMinerInput\nElection.VoteWeightInterest\nElection.VoteWeightInterestList\nElection.VoteWeightProportion\nAElf.Standards.ACS1\nacs1.MethodFee\nacs1.MethodFees\nAElf.Types\naelf.Address\naelf.BinaryMerkleTree\naelf.Hash\naelf.LogEvent\naelf.MerklePath\naelf.MerklePathNode\naelf.SInt32Value\naelf.SInt64Value\naelf.ScopedStatePath\naelf.SmartContractRegistration\naelf.StatePath\naelf.Transaction\naelf.TransactionExecutingStateSet\naelf.TransactionExecutingStateSet.DeletesEntry\naelf.TransactionExecutingStateSet.ReadsEntry\naelf.TransactionExecutingStateSet.WritesEntry\naelf.TransactionResult\naelf.TransactionResultStatus\nAuthorityInfo\nPlatform\nTechnology\nAudit Report\nPrivacy\nTerms of Use\nCookie Policy\nDeveloper Resources\nQuick Start\nLearn\nDocs\nTools\nResources\nEcosystem\nOverview\ndApps\naelf Ventures\nBlog\nConnect\nContact Us\nCopyright © 2024 aelf"
    },
    {
      "title": "Consensus Contract | AELF Docs",
      "url": "https://docs.aelf.com/docs/smart-contract-api/consensus-contract/",
      "html": "Skip to main content\nQuick Start\nLearn\nDocs\nTools\nResources\nBlog\nSearch\nDocs Reference\nSmart Contract API\nAssociation Contract\nReferendum Contract\nParliament Contract\nConsensus Contract\nElection Contract\nGenesis Contract\nMulti Token Contract\nProfit Contract\nCross Chain Contract\nTreasury Contract\nVote Contract\nToken Holder Contract\nEconomic Contract\nToken Converter Contract\nConfiguration Contract\nWeb API\nDocs ReferenceSmart Contract APIConsensus Contract\nConsensus Contract\nAEDPoS contract​\n\nUsed to manage block producers and synchronize data. Implements aelf Standards ACS1, ACS4, ACS6, ACS10, and ACS11.\n\nContract Methods​\nMethod Name\tRequest Type\tResponse Type\tDescription\nInitialAElfConsensusContract\tAEDPoS.InitialAElfConsensusContractInput\tgoogle.protobuf.Empty\tInitialize the consensus contract.\nFirstRound\tAEDPoS.Round\tgoogle.protobuf.Empty\tInitializes the consensus information in the first round.\nUpdateValue\tAEDPoS.UpdateValueInput\tgoogle.protobuf.Empty\tUpdate consensus information.\nNextRound\tAEDPoS.NextRoundInput\tgoogle.protobuf.Empty\tUpdate consensus information, create a new round.\nNextTerm\tAEDPoS.NextTermInput\tgoogle.protobuf.Empty\tUpdate consensus information, create a new term.\nUpdateTinyBlockInformation\tAEDPoS.TinyBlockInput\tgoogle.protobuf.Empty\tUpdate consensus tiny block information.\nSetMaximumMinersCount\tgoogle.protobuf.Int32Value\tgoogle.protobuf.Empty\tSet the maximum count of miners, by default, is unlimited.\nChangeMaximumMinersCountController\tAuthorityInfo\tgoogle.protobuf.Empty\tChange the authority information for maximum miners count.\nRecordCandidateReplacement\tAEDPoS.RecordCandidateReplacementInput\tgoogle.protobuf.Empty\tNotify AEDPoS Contract of candidate replacement.\nGetCurrentMinerList\tgoogle.protobuf.Empty\tAEDPoS.MinerList\tGet the list of current miners.\nGetCurrentMinerPubkeyList\tgoogle.protobuf.Empty\tAEDPoS.PubkeyList\tGet the list of current miners in hexadecimal format.\nGetCurrentMinerListWithRoundNumber\tgoogle.protobuf.Empty\tAEDPoS.MinerListWithRoundNumber\tGet the list of current miners and current round number.\nGetRoundInformation\tgoogle.protobuf.Int64Value\tAEDPoS.Round\tGet information of the round according to round number.\nGetCurrentRoundNumber\tgoogle.protobuf.Empty\tgoogle.protobuf.Int64Value\tGet the current round number.\nGetCurrentRoundInformation\tgoogle.protobuf.Empty\tAEDPoS.Round\tGet the current round information.\nGetPreviousRoundInformation\tgoogle.protobuf.Empty\tAEDPoS.Round\tGet the previous round information.\nGetCurrentTermNumber\tgoogle.protobuf.Empty\tgoogle.protobuf.Int64Value\tGet the current term number.\nGetCurrentTermMiningReward\tgoogle.protobuf.Empty\tgoogle.protobuf.Int64Value\tGet the welfare reward for the current term.\nGetMinerList\tAEDPoS.GetMinerListInput\tAEDPoS.MinerList\tGet the list of miners according to term number.\nGetPreviousMinerList\tgoogle.protobuf.Empty\tAEDPoS.MinerList\tGet the list of miners in the previous term.\nGetMinedBlocksOfPreviousTerm\tgoogle.protobuf.Empty\tgoogle.protobuf.Int64Value\tGet the amount of mined blocks in the previous term.\nGetNextMinerPubkey\tgoogle.protobuf.Empty\tgoogle.protobuf.StringValue\tGet the miner that produces the next block.\nIsCurrentMiner\taelf.Address\tgoogle.protobuf.BoolValue\tCheck if the account address is on the miner list for the current round.\nGetNextElectCountDown\tgoogle.protobuf.Empty\tgoogle.protobuf.Int64Value\tGet the left time before the next election takes effect (seconds).\nGetPreviousTermInformation\tgoogle.protobuf.Int64Value\tAEDPoS.Round\tGet term information according to term number.\nGetRandomHash\tgoogle.protobuf.Int64Value\taelf.Hash\tGet random hash (Compatibility note).\nGetMaximumBlocksCount\tgoogle.protobuf.Empty\tgoogle.protobuf.Int32Value\tGet the maximum of tiny blocks produced by a miner each round.\nGetMaximumMinersCount\tgoogle.protobuf.Empty\tgoogle.protobuf.Int32Value\tGet the maximum count of miners.\nGetMaximumMinersCountController\tgoogle.protobuf.Empty\tAuthorityInfo\tGet the authority information for maximum miners count.\nGetMainChainCurrentMinerList\tgoogle.protobuf.Empty\tAEDPoS.MinerList\tGet the list of miners in the main chain.\nGetPreviousTermMinerPubkeyList\tgoogle.protobuf.Empty\tAEDPoS.PubkeyList\tGet the list of miners in the previous term.\nGetCurrentMiningRewardPerBlock\tgoogle.protobuf.Empty\tgoogle.protobuf.Int64Value\tQuery the current mining reward for each block.\nSetMinerIncreaseInterval\tgoogle.protobuf.Int64Value\tgoogle.protobuf.Empty\tSet the current miner growth time interval.\nGetMinerIncreaseInterval\tgoogle.protobuf.Empty\tgoogle.protobuf.Int64Value\tGet the current miner growth time interval.\nAElf.Standards.ACS1\nACS1 Standard Methods​\nMethod Name\tRequest Type\tResponse Type\tDescription\nSetMethodFee\tacs1.MethodFees\tgoogle.protobuf.Empty\tSet the method fees for the specified method.\nChangeMethodFeeController\tAuthorityInfo\tgoogle.protobuf.Empty\tChange the method fee controller.\nGetMethodFee\tgoogle.protobuf.StringValue\tacs1.MethodFees\tQuery method fee information by method name.\nGetMethodFeeController\tgoogle.protobuf.Empty\tAuthorityInfo\tQuery the method fee controller.\nAElf.Contracts.Consensus.AEDPoS​\nAEDPoS contract​\n\nUsed for managing block producers and synchronizing data.\n\nImplement aelf Standards ACS1, ACS4, ACS6, ACS10, and ACS11.\n\nContract Methods​\nMethod Name\tRequest Type\tResponse Type\tDescription\nInitialAElfConsensusContract\tAEDPoS.InitialAElfConsensusContractInput\tgoogle.protobuf.Empty\tInitialize the consensus contract.\nFirstRound\tAEDPoS.Round\tgoogle.protobuf.Empty\tInitializes the consensus information in the first round.\nUpdateValue\tAEDPoS.UpdateValueInput\tgoogle.protobuf.Empty\tUpdate consensus information.\nNextRound\tAEDPoS.NextRoundInput\tgoogle.protobuf.Empty\tUpdate consensus information, create a new round.\nNextTerm\tAEDPoS.NextTermInput\tgoogle.protobuf.Empty\tUpdate consensus information, create a new term.\nUpdateTinyBlockInformation\tAEDPoS.TinyBlockInput\tgoogle.protobuf.Empty\tUpdate consensus tiny block information.\nSetMaximumMinersCount\tgoogle.protobuf.Int32Value\tgoogle.protobuf.Empty\tSet the maximum count of miners, by default, is unlimited. If you want to control the count of miners, you need to set it through parliament.\nChangeMaximumMinersCountController\tAuthorityInfo\tgoogle.protobuf.Empty\tThe authority information for SetMaximumMinersCount, by default, is governed by parliament.\nRecordCandidateReplacement\tAEDPoS.RecordCandidateReplacementInput\tgoogle.protobuf.Empty\tElection Contract can notify AEDPoS Contract to aware candidate replacement happened.\nGetCurrentMinerList\tgoogle.protobuf.Empty\tAEDPoS.MinerList\tGet the list of current miners.\nGetCurrentMinerPubkeyList\tgoogle.protobuf.Empty\tAEDPoS.PubkeyList\tGet the list of current miners (hexadecimal format).\nGetCurrentMinerListWithRoundNumber\tgoogle.protobuf.Empty\tAEDPoS.MinerListWithRoundNumber\tGet the list of current miners and current round number.\nGetRoundInformation\tgoogle.protobuf.Int64Value\tAEDPoS.Round\tGet information of the round according to round number.\nGetCurrentRoundNumber\tgoogle.protobuf.Empty\tgoogle.protobuf.Int64Value\tGet the current round number.\nGetCurrentRoundInformation\tgoogle.protobuf.Empty\tAEDPoS.Round\tGet the current round information.\nGetPreviousRoundInformation\tgoogle.protobuf.Empty\tAEDPoS.Round\tGet the previous round information.\nGetCurrentTermNumber\tgoogle.protobuf.Empty\tgoogle.protobuf.Int64Value\tGet the current term number.\nGetCurrentTermMiningReward\tgoogle.protobuf.Empty\tgoogle.protobuf.Int64Value\tGet the welfare reward the current term.\nGetMinerList\tAEDPoS.GetMinerListInput\tAEDPoS.MinerList\tGet the list of miners according to term number.\nGetPreviousMinerList\tgoogle.protobuf.Empty\tAEDPoS.MinerList\tGet the list of miner in previous term.\nGetMinedBlocksOfPreviousTerm\tgoogle.protobuf.Empty\tgoogle.protobuf.Int64Value\tGet the amount of mined blocks in previous term.\nGetNextMinerPubkey\tgoogle.protobuf.Empty\tgoogle.protobuf.StringValue\tGet the miner that produces the next block.\nIsCurrentMiner\taelf.Address\tgoogle.protobuf.BoolValue\tCheck to see if the account address is on the miner list for the current round.\nGetNextElectCountDown\tgoogle.protobuf.Empty\tgoogle.protobuf.Int64Value\tQuery the left time before the next election takes effects (seconds).\nGetPreviousTermInformation\tgoogle.protobuf.Int64Value\tAEDPoS.Round\tGet term information according term number.\nGetRandomHash\tgoogle.protobuf.Int64Value\taelf.Hash\tGet random hash (Keep this for compatibility).\nGetMaximumBlocksCount\tgoogle.protobuf.Empty\tgoogle.protobuf.Int32Value\tGet maximum tiny blocks produced by miner each round.\nGetMaximumMinersCount\tgoogle.protobuf.Empty\tgoogle.protobuf.Int32Value\tGet the maximum count of miners.\nGetMaximumMinersCountController\tgoogle.protobuf.Empty\tAuthorityInfo\tThe authority information for GetMaximumMinersCount, by default, is governed by parliament.\nGetMainChainCurrentMinerList\tgoogle.protobuf.Empty\tAEDPoS.MinerList\tGet the list of miners in main chain.\nGetPreviousTermMinerPubkeyList\tgoogle.protobuf.Empty\tAEDPoS.PubkeyList\tGet the list of miners in previous term.\nGetCurrentMiningRewardPerBlock\tgoogle.protobuf.Empty\tgoogle.protobuf.Int64Value\tQuery the current mining reward for each block.\nSetMinerIncreaseInterval\tgoogle.protobuf.Int64Value\tgoogle.protobuf.Empty\tSet the current miner growth time interval.\nGetMinerIncreaseInterval\tgoogle.protobuf.Empty\tgoogle.protobuf.Int64Value\tGet the current miner growth time interval.\nAElf.Standards.ACS4​\nACS4 Standard Methods​\nMethod Name\tRequest Type\tResponse Type\tDescription\nGetConsensusCommand\tgoogle.protobuf.BytesValue\tacs4.ConsensusCommand\tGenerate a consensus command based on the consensus contract state and the input public key.\nGetConsensusExtraData\tgoogle.protobuf.BytesValue\tgoogle.protobuf.BytesValue\tGenerate consensus extra data when a block is generated.\nGenerateConsensusTransactions\tgoogle.protobuf.BytesValue\tacs4.TransactionList\tGenerate consensus system transactions when a block is generated. Each block will contain only one consensus transaction, which is used to write the latest consensus information to the State database.\nValidateConsensusBeforeExecution\tgoogle.protobuf.BytesValue\tacs4.ValidationResult\tBefore executing the block, verify that the consensus information in the block header is correct.\nValidateConsensusAfterExecution\tgoogle.protobuf.BytesValue\tacs4.ValidationResult\tAfter executing the block, verify that the state information written to the consensus is correct.\nAElf.Standards.ACS6​\nACS6 Standard Methods​\nMethod Name\tRequest Type\tResponse Type\tDescription\nGetRandomBytes\tgoogle.protobuf.BytesValue\tgoogle.protobuf.BytesValue\tGet random number according to block height.\nAElf.Standards.ACS10​\nACS10 Standard Methods​\nMethod Name\tRequest Type\tResponse Type\tDescription\nDonate\tacs10.DonateInput\tgoogle.protobuf.Empty\tDonates tokens from the caller to the treasury. If the tokens are not native tokens in the current chain, they will be first converted to the native token.\nRelease\tacs10.ReleaseInput\tgoogle.protobuf.Empty\tRelease dividend pool according the period number.\nSetSymbolList\tacs10.SymbolList\tgoogle.protobuf.Empty\tSet the token symbols dividend pool supports.\nGetSymbolList\tgoogle.protobuf.Empty\tacs10.SymbolList\tQuery the token symbols dividend pool supports.\nGetUndistributedDividends\tgoogle.protobuf.Empty\tacs10.Dividends\tQuery the balance of undistributed tokens whose symbols are included in the symbol list.\nGetDividends\tgoogle.protobuf.Int64Value\tacs10.Dividends\tQuery the dividend information according to the height.\nAElf.Standards.ACS11​\nACS11 Standard Methods​\nMethod Name\tRequest Type\tResponse Type\tDescription\nUpdateInformationFromCrossChain\tgoogle.protobuf.BytesValue\tgoogle.protobuf.Empty\tUpdate the consensus information of the side chain.\nGetChainInitializationInformation\tgoogle.protobuf.BytesValue\tgoogle.protobuf.BytesValue\tGet the current miner list and consensus round information.\nCheckCrossChainIndexingPermission\taelf.Address\tgoogle.protobuf.BoolValue\tVerify that the input address is the current miner.\nContract Types\nAElf.Contracts.Consensus.AEDPoS​\nAEDPoS.AElfConsensusHeaderInformation​\nField\tType\tDescription\tLabel\nsender_pubkey\tbytes\tThe sender public key.\t\nround\tRound\tThe round information.\t\nbehaviour\tAElfConsensusBehaviour\tThe behaviour of consensus.\t\nAEDPoS.AElfConsensusHint​\nField\tType\tDescription\tLabel\nbehaviour\tAElfConsensusBehaviour\tThe behaviour of consensus.\t\nround_id\tint64\tThe round id.\t\nprevious_round_id\tint64\tThe previous round id.\t\nAEDPoS.AElfConsensusTriggerInformation​\nField\tType\tDescription\tLabel\npubkey\tbytes\tThe miner public key.\t\nin_value\taelf.Hash\tThe InValue for current round.\t\nprevious_in_value\taelf.Hash\tThe InValue for previous round.\t\nbehaviour\tAElfConsensusBehaviour\tThe behaviour of consensus.\t\nencrypted_pieces\tEncryptedPiecesEntry\tThe encrypted pieces of InValue.\trepeated\ndecrypted_pieces\tDecryptedPiecesEntry\tThe decrypted pieces of InValue.\trepeated\nrevealed_in_values\tRevealedInValuesEntry\tThe revealed InValues.\trepeated\nAEDPoS.AElfConsensusTriggerInformation.DecryptedPiecesEntry​\nField\tType\tDescription\tLabel\nkey\tstring\t\t\nvalue\tbytes\t\t\nAEDPoS.AElfConsensusTriggerInformation.EncryptedPiecesEntry​\nField\tType\tDescription\tLabel\nkey\tstring\t\t\nvalue\tbytes\t\t\nAEDPoS.AElfConsensusTriggerInformation.RevealedInValuesEntry​\nField\tType\tDescription\tLabel\nkey\tstring\t\t\nvalue\taelf.Hash\t\t\nAEDPoS.Candidates​\nField\tType\tDescription\tLabel\npubkeys\tbytes\tThe candidate public keys.\trepeated\nAEDPoS.ConsensusInformation​\nField\tType\tDescription\tLabel\nvalue\tbytes\t\t\nAEDPoS.GetMinerListInput​\nField\tType\tDescription\tLabel\nterm_number\tint64\tThe term number.\t\nAEDPoS.HashList​\nField\tType\tDescription\tLabel\nvalues\taelf.Hash\t\trepeated\nAEDPoS.InitialAElfConsensusContractInput​\nField\tType\tDescription\tLabel\nis_term_stay_one\tbool\tWhether not to change the term.\t\nis_side_chain\tbool\tIs a side chain.\t\nperiod_seconds\tint64\tThe number of seconds per term.\t\nminer_increase_interval\tint64\tThe interval second that increases miners.\t\nAEDPoS.IrreversibleBlockFound​\nField\tType\tDescription\tLabel\nirreversible_block_height\tint64\tThe irreversible block height found.\t\nAEDPoS.IrreversibleBlockHeightUnacceptable​\nField\tType\tDescription\tLabel\ndistance_to_irreversible_block_height\tint64\tDistance to the height of the last irreversible block.\t\nAEDPoS.LatestPubkeyToTinyBlocksCount​\nField\tType\tDescription\tLabel\npubkey\tstring\tThe miner public key.\t\nblocks_count\tint64\tThe count of blocks the miner produced.\t\nAEDPoS.MinerInRound​\nField\tType\tDescription\tLabel\norder\tint32\tThe order of the miner producing a block.\t\nis_extra_block_producer\tbool\tIs the extra block producer in the current round.\t\nin_value\taelf.Hash\tGenerated by secret sharing and used for validation between miners.\t\nout_value\taelf.Hash\tCalculated from the current in value.\t\nsignature\taelf.Hash\tCalculated from the current in value and signatures of the previous round.\t\nexpected_mining_time\tTimestamp\tThe expected mining time.\t\nproduced_blocks\tint64\tThe amount of produced blocks.\t\nmissed_time_slots\tint64\tThe amount of missed time slots.\t\npubkey\tstring\tThe public key of this miner.\t\nprevious_in_value\taelf.Hash\tThe InValue of the previous round.\t\nsupposed_order_of_next_round\tint32\tThe supposed order of mining for the next round.\t\nfinal_order_of_next_round\tint32\tThe final order of mining for the next round.\t\nactual_mining_times\tTimestamp\tThe actual mining time, miners must fill the actual mining time when they do the mining.\trepeated\nencrypted_pieces\tMinerInRound.EncryptedPiecesEntry\tThe encrypted pieces of InValue.\trepeated\ndecrypted_pieces\tMinerInRound.DecryptedPiecesEntry\tThe decrypted pieces of InValue.\trepeated\nproduced_tiny_blocks\tint64\tThe amount of produced tiny blocks.\t\nimplied_irreversible_block_height\tint64\tThe irreversible block height that the current miner recorded.\t\nAEDPoS.MinerInRound.DecryptedPiecesEntry​\nField\tType\tDescription\tLabel\nkey\tstring\t\t\nvalue\tbytes\t\t\nAEDPoS.MinerInRound.EncryptedPiecesEntry​\nField\tType\tDescription\tLabel\nkey\tstring\t\t\nvalue\tbytes\t\t\nAEDPoS.MinerList​\nField\tType\tDescription\tLabel\npubkeys\tbytes\tThe miners public key list.\trepeated\nAEDPoS.MinerListWithRoundNumber​\nField\tType\tDescription\tLabel\nminer_list\tMinerList\tThe list of miners.\t\nround_number\tint64\tThe round number.\t\nAEDPoS.MinerReplaced​\nField\tType\tDescription\tLabel\nnew_miner_pubkey\tstring\tThe new miner public key.\t\nAEDPoS.MiningInformationUpdated​\nField\tType\tDescription\tLabel\npubkey\tstring\tThe miner public key.\t\nmining_time\tgoogle.protobuf.Timestamp\tThe current block time.\t\nbehaviour\tstring\tThe behaviour of consensus.\t\nblock_height\tint64\tThe current block height.\t\nprevious_block_hash\taelf.Hash\tThe previous block hash.\t\nAEDPoS.MiningRewardGenerated​\nField\tType\tDescription\tLabel\nterm_number\tint64\tThe number of term the mining reward is generated.\t\namount\tint64\tThe amount of mining reward.\t\nAEDPoS.PubkeyList​\nField\tType\tDescription\tLabel\npubkeys\tstring\tThe miners public key list.\trepeated\nAEDPoS.RandomNumberRequestInformation​\nField\tType\tDescription\tLabel\ntarget_round_number\tint64\tThe random hash is likely generated during this round.\t\norder\tint64\t\t\nexpected_block_height\tint64\t\t\nAEDPoS.RecordCandidateReplacementInput​\nField\tType\tDescription\tLabel\nold_pubkey\tstring\t\t\nnew_pubkey\tstring\t\t\nAEDPoS.NextRoundInput​\nField\tType\tDescription\tLabel\nround_number\tint64\tThe round number.\t\nreal_time_miners_information\tRound.RealTimeMinersInformationEntry\tCurrent miner information, miner public key -> miner information.\trepeated\nmain_chain_miners_round_number\tint64\tThe round number on the main chain.\t\nblockchain_age\tint64\tThe time from chain start to current round (seconds).\t\nextra_block_producer_of_previous_round\tstring\tThe miner public key that produced the extra block in the previous round.\t\nterm_number\tint64\tThe current term number.\t\nconfirmed_irreversible_block_height\tint64\tThe height of the confirmed irreversible block.\t\nconfirmed_irreversible_block_round_number\tint64\tThe round number of the confirmed irreversible block.\t\nis_miner_list_just_changed\tbool\tIs miner list different from the the miner list in the previous round.\t\nround_id_for_validation\tint64\tThe round id, calculated by summing block producers’ expecting time (second).\t\nrandom_number\tbytes\tThe random number.\t\nAEDPoS.NextTermInput​\nField\tType\tDescription\tLabel\nround_number\tint64\tThe round number.\t\nreal_time_miners_information\tRound.RealTimeMinersInformationEntry\tCurrent miner information, miner public key -> miner information.\trepeated\nmain_chain_miners_round_number\tint64\tThe round number on the main chain.\t\nblockchain_age\tint64\tThe time from chain start to current round (seconds).\t\nextra_block_producer_of_previous_round\tstring\tThe miner public key that produced the extra block in the previous round.\t\nterm_number\tint64\tThe current term number.\t\nconfirmed_irreversible_block_height\tint64\tThe height of the confirmed irreversible block.\t\nconfirmed_irreversible_block_round_number\tint64\tThe round number of the confirmed irreversible block.\t\nis_miner_list_just_changed\tbool\tIs miner list different from the the miner list in the previous round.\t\nround_id_for_validation\tint64\tThe round id, calculated by summing block producers’ expecting time (second).\t\nrandom_number\tbytes\tThe random number.\t\nAEDPoS.Round.RealTimeMinersInformationEntry​\nField\tType\tDescription\tLabel\nkey\tstring\t\t\nvalue\tMinerInRound\t\t\nAEDPoS.SecretSharingInformation​\nField\tType\tDescription\tLabel\nprevious_round\tRound\tThe previous round information.\t\ncurrent_round_id\tint64\tThe current round id.\t\nprevious_round_id\tint64\tThe previous round id.\t\nAEDPoS.TermInfo​\nField\tType\tDescription\tLabel\nterm_number\tint64\t\t\nround_number\tint64\t\t\nAEDPoS.TermNumberLookUp​\nField\tType\tDescription\tLabel\nmap\tTermNumberLookUp.MapEntry\tTerm number -> Round number.\trepeated\nAEDPoS.TermNumberLookUp.MapEntry​\nField\tType\tDescription\tLabel\nkey\tint64\t\t\nvalue\tint64\t\t\nAEDPoS.TinyBlockInput​\nField\tType\tDescription\tLabel\nround_id\tint64\tThe round id.\t\nactual_mining_time\tgoogle.protobuf.Timestamp\tThe actual mining time.\t\nproduced_blocks\tint64\tCount of blocks produced.\t\nAEDPoS.UpdateValueInput​\nField\tType\tDescription\tLabel\nout_value\taelf.Hash\tCalculated from current in value.\t\nsignature\taelf.Hash\tCalculated from current in value and signatures of previous round.\t\nround_id\tint64\tTo ensure the values to update will apply to the correct round by comparing round id.\t\nprevious_in_value\taelf.Hash\tPublishes previous in value for validation of previous signature and previous out value.\t\nactual_mining_time\tgoogle.protobuf.Timestamp\tThe actual mining time; miners must fill actual mining time when they mine.\t\nsupposed_order_of_next_round\tint32\tThe supposed order of mining for the next round.\t\ntune_order_information\tUpdateValueInput.TuneOrderInformationEntry\tThe tuning order of mining for the next round, miner public key -> order.\trepeated\nencrypted_pieces\tUpdateValueInput.EncryptedPiecesEntry\tThe encrypted pieces of InValue.\trepeated\ndecrypted_pieces\tUpdateValueInput.DecryptedPiecesEntry\tThe decrypted pieces of InValue.\trepeated\nproduced_blocks\tint64\tThe amount of produced blocks.\t\nminers_previous_in_values\tUpdateValueInput.MinersPreviousInValuesEntry\tThe InValue in the previous round, miner public key -> InValue.\trepeated\nimplied_irreversible_block_height\tint64\tThe irreversible block height that the miner recorded.\t\nAEDPoS.UpdateValueInput.DecryptedPiecesEntry​\nField\tType\tDescription\tLabel\nkey\tstring\t\t\nvalue\tbytes\t\t\nAEDPoS.UpdateValueInput.EncryptedPiecesEntry​\nField\tType\tDescription\tLabel\nkey\tstring\t\t\nvalue\tbytes\t\t\nAEDPoS.UpdateValueInput.MinersPreviousInValuesEntr​\nField\tType\tDescription\tLabel\nkey\tstring\t\t\nvalue\taelf.Hash\t\t\nAEDPoS.UpdateValueInput.TuneOrderInformationEntry​\nField\tType\tDescription\tLabel\nkey\tstring\t\t\nvalue\tint32\t\t\nAEDPoS.VoteMinersCountInput​\nField\tType\tDescription\tLabel\nminers_count\tint32\t\t\namount\tint64\t\t\nAEDPoS.AElfConsensusBehaviour​\nName\tNumber\tDescription\nUPDATE_VALUE\t0\t\nNEXT_ROUND\t1\t\nNEXT_TERM\t2\t\nNOTHING\t3\t\nTINY_BLOCK\t4\t\nAElf.Standards.ACS1​\nacs1.MethodFee​\nField\tType\tDescription\tLabel\nsymbol\tstring\tThe token symbol of the method fee.\t\nbasic_fee\tint64\tThe amount of fees to be charged.\t\nacs1.MethodFees​\nField\tType\tDescription\tLabel\nmethod_name\tstring\tThe name of the method to be charged.\t\nfees\tMethodFee\tList of fees to be charged.\trepeated\nis_size_fee_free\tbool\tOptional based on the implementation of SetMethodFee method.\t\nAElf.Standards.ACS4​\nacs4.ConsensusCommand​\nField\tType\tDescription\tLabel\nlimit_milliseconds_of_mining_block\tint32\tTime limit of mining next block.\t\nhint\tbytes\tContext of Hint is diverse according to the consensus protocol we choose, so we use bytes.\t\narranged_mining_time\tgoogle.protobuf.Timestamp\tThe time of arrange mining.\t\nmining_due_time\tgoogle.protobuf.Timestamp\tThe expiration time of mining.\t\nacs4.TransactionList​\nField\tType\tDescription\tLabel\ntransactions\taelf.Transaction\tConsensus system transactions.\trepeated\nacs4.ValidationResult​\nField\tType\tDescription\tLabel\nsuccess\tbool\tIs successful.\t\nmessage\tstring\tThe error message.\t\nis_re_trigger\tbool\tWhether to trigger mining again.\t\nAElf.Standards.ACS10​\nacs10.Dividends​\nField\tType\tDescription\tLabel\nvalue\tDividends.ValueEntry\tThe dividends, symbol -> amount.\trepeated\nacs10.Dividends.ValueEntry​\nField\tType\tDescription\tLabel\nkey\tstring\t\t\nvalue\tint64\t\t\nacs10.DonateInput​\nField\tType\tDescription\tLabel\nsymbol\tstring\tThe token symbol to donate.\t\namount\tint64\tThe amount to donate.\t\nacs10.DonationReceived​\nField\tType\tDescription\tLabel\nfrom\taelf.Address\tThe address of donors.\t\npool_contract\taelf.Address\tThe address of dividend pool.\t\nsymbol\tstring\tThe token symbol Donated.\t\namount\tint64\tThe amount Donated.\t\nacs10.ReleaseInput​\nField\tType\tDescription\tLabel\nperiod_number\tint64\tThe period number to release.\t\nacs10.SymbolList​\nField\tType\tDescription\tLabel\nvalue\tstring\tThe token symbol list.\trepeated\nAElf.Standards.ACS11​\n\nAElf.Types\n\naelf.Address​\nField\tType\tDescription\tLabel\nvalue\tbytes\t\t\naelf.BinaryMerkleTree​\nField\tType\tDescription\tLabel\nnodes\tHash\tThe leaf nodes.\trepeated\nroot\tHash\tThe root node hash.\t\nleaf_count\tint32\tThe count of leaf node.\t\naelf.Hash​\nField\tType\tDescription\tLabel\nvalue\tbytes\t\t\naelf.LogEvent​\nField\tType\tDescription\tLabel\naddress\tAddress\tThe contract address.\t\nname\tstring\tThe name of the log event.\t\nindexed\tbytes\tThe indexed data.\trepeated\nnon_indexed\tbytes\tThe non indexed data.\t\naelf.MerklePath​\nField\tType\tDescription\tLabel\nmerkle_path_nodes\tMerklePathNode\tThe merkle path nodes.\trepeated\naelf.MerklePathNode​\nField\tType\tDescription\tLabel\nhash\tHash\tThe node hash.\t\nis_left_child_node\tbool\tWhether it is a left child node.\t\naelf.SInt32Value​\nField\tType\tDescription\tLabel\nvalue\tsint32\t\t\naelf.SInt64Value​\nField\tType\tDescription\tLabel\nvalue\tsint64\t\t\naelf.ScopedStatePath​\nField\tType\tDescription\tLabel\naddress\tAddress\tThe scope address, which will be the contract address.\t\npath\tStatePath\tThe path of contract state.\t\naelf.SmartContractRegistration​\nField\tType\tDescription\tLabel\ncategory\tsint32\tThe category of contract code (0: C#).\t\ncode\tbytes\tThe byte array of the contract code.\t\ncode_hash\tHash\tThe hash of the contract code.\t\nis_system_contract\tbool\tWhether it is a system contract.\t\nversion\tint32\tThe version of the current contract.\t\naelf.StatePath​\nField\tType\tDescription\tLabel\nparts\tstring\tThe partial path of the state path.\trepeated\naelf.Transaction​\nField\tType\tDescription\tLabel\nfrom\tAddress\tThe address of the sender of the transaction.\t\nto\tAddress\tThe address of the contract when calling a contract.\t\nref_block_number\tint64\tThe height of the referenced block hash.\t\nref_block_prefix\tbytes\tThe first four bytes of the referenced block hash.\t\nmethod_name\tstring\tThe name of a method in the smart contract at the To address.\t\nparams\tbytes\tThe parameters to pass to the smart contract method.\t\nsignature\tbytes\tWhen signing a transaction it’s actually a subset of the fields...\t\naelf.TransactionExecutingStateSet​\nField\tType\tDescription\tLabel\nwrites\tTransactionExecutingStateSet.WritesEntry\tThe changed states.\trepeated\nreads\tTransactionExecutingStateSet.ReadsEntry\tThe read states.\trepeated\ndeletes\tTransactionExecutingStateSet.DeletesEntry\tThe deleted states.\trepeated\naelf.TransactionExecutingStateSet.DeletesEntry​\nField\tType\tDescription\tLabel\nkey\tstring\t\t\nvalue\tbool\t\t\naelf.TransactionExecutingStateSet.ReadsEntry​\nField\tType\tDescription\tLabel\nkey\tstring\t\t\nvalue\tbool\t\t\naelf.TransactionExecutingStateSet.WritesEntry​\nField\tType\tDescription\tLabel\nkey\tstring\t\t\nvalue\tbytes\t\t\naelf.TransactionResult​\nField\tType\tDescription\tLabel\ntransaction_id\tHash\tThe transaction id.\t\nstatus\tTransactionResultStatus\tThe transaction result status.\t\nlogs\tLogEvent\tThe log events.\trepeated\nbloom\tbytes\tBloom filter for transaction logs.\t\nreturn_value\tbytes\tThe return value of the transaction execution.\t\nblock_number\tint64\tThe height of the block that packages the transaction.\t\nblock_hash\tHash\tThe hash of the block that packages the transaction.\t\nerror\tstring\tFailed execution error message.\t\naelf.TransactionResultStatus​\nName\tNumber\tDescription\nNOT_EXISTED\t0\tThe execution result of the transaction does not exist.\nPENDING\t1\tThe transaction is in the transaction pool waiting to be packaged.\nFAILED\t2\tTransaction execution failed.\nMINED\t3\tThe transaction was successfully executed and successfully...\nCONFLICT\t4\tWhen executed in parallel, there are conflicts with other...\nPENDING_VALIDATION\t5\tThe transaction is waiting for validation.\nNODE_VALIDATION_FAILED\t6\tTransaction validation failed.\nAuthorityInfo​\nField\tType\tDescription\tLabel\ncontract_address\taelf.Address\tThe contract address of the controller.\t\nowner_address\taelf.Address\tThe address of the owner of the contract.\t\nPrevious\nParliament Contract\nNext\nElection Contract\nAEDPoS contract\nContract Methods\nACS1 Standard Methods\nAElf.Contracts.Consensus.AEDPoS\nAEDPoS contract\nContract Methods\nAElf.Standards.ACS4\nACS4 Standard Methods\nAElf.Standards.ACS6\nACS6 Standard Methods\nAElf.Standards.ACS10\nACS10 Standard Methods\nAElf.Standards.ACS11\nACS11 Standard Methods\nAElf.Contracts.Consensus.AEDPoS\nAEDPoS.AElfConsensusHeaderInformation\nAEDPoS.AElfConsensusHint\nAEDPoS.AElfConsensusTriggerInformation\nAEDPoS.AElfConsensusTriggerInformation.DecryptedPiecesEntry\nAEDPoS.AElfConsensusTriggerInformation.EncryptedPiecesEntry\nAEDPoS.AElfConsensusTriggerInformation.RevealedInValuesEntry\nAEDPoS.Candidates\nAEDPoS.ConsensusInformation\nAEDPoS.GetMinerListInput\nAEDPoS.HashList\nAEDPoS.InitialAElfConsensusContractInput\nAEDPoS.IrreversibleBlockFound\nAEDPoS.IrreversibleBlockHeightUnacceptable\nAEDPoS.LatestPubkeyToTinyBlocksCount\nAEDPoS.MinerInRound\nAEDPoS.MinerInRound.DecryptedPiecesEntry\nAEDPoS.MinerInRound.EncryptedPiecesEntry\nAEDPoS.MinerList\nAEDPoS.MinerListWithRoundNumber\nAEDPoS.MinerReplaced\nAEDPoS.MiningInformationUpdated\nAEDPoS.MiningRewardGenerated\nAEDPoS.PubkeyList\nAEDPoS.RandomNumberRequestInformation\nAEDPoS.RecordCandidateReplacementInput\nAEDPoS.NextRoundInput\nAEDPoS.NextTermInput\nAEDPoS.Round.RealTimeMinersInformationEntry\nAEDPoS.SecretSharingInformation\nAEDPoS.TermInfo\nAEDPoS.TermNumberLookUp\nAEDPoS.TermNumberLookUp.MapEntry\nAEDPoS.TinyBlockInput\nAEDPoS.UpdateValueInput\nAEDPoS.UpdateValueInput.DecryptedPiecesEntry\nAEDPoS.UpdateValueInput.EncryptedPiecesEntry\nAEDPoS.UpdateValueInput.MinersPreviousInValuesEntr\nAEDPoS.UpdateValueInput.TuneOrderInformationEntry\nAEDPoS.VoteMinersCountInput\nAEDPoS.AElfConsensusBehaviour\nAElf.Standards.ACS1\nacs1.MethodFee\nacs1.MethodFees\nAElf.Standards.ACS4\nacs4.ConsensusCommand\nacs4.TransactionList\nacs4.ValidationResult\nAElf.Standards.ACS10\nacs10.Dividends\nacs10.Dividends.ValueEntry\nacs10.DonateInput\nacs10.DonationReceived\nacs10.ReleaseInput\nacs10.SymbolList\nAElf.Standards.ACS11\naelf.Address\naelf.BinaryMerkleTree\naelf.Hash\naelf.LogEvent\naelf.MerklePath\naelf.MerklePathNode\naelf.SInt32Value\naelf.SInt64Value\naelf.ScopedStatePath\naelf.SmartContractRegistration\naelf.StatePath\naelf.Transaction\naelf.TransactionExecutingStateSet\naelf.TransactionExecutingStateSet.DeletesEntry\naelf.TransactionExecutingStateSet.ReadsEntry\naelf.TransactionExecutingStateSet.WritesEntry\naelf.TransactionResult\naelf.TransactionResultStatus\nAuthorityInfo\nPlatform\nTechnology\nAudit Report\nPrivacy\nTerms of Use\nCookie Policy\nDeveloper Resources\nQuick Start\nLearn\nDocs\nTools\nResources\nEcosystem\nOverview\ndApps\naelf Ventures\nBlog\nConnect\nContact Us\nCopyright © 2024 aelf"
    },
    {
      "title": "AELF Docs",
      "url": "https://docs.aelf.com/docs/smart-contract-api/referendum-contract/",
      "html": "Skip to main content\nQuick Start\nLearn\nDocs\nTools\nResources\nBlog\nSearch\nDocs Reference\nSmart Contract API\nAssociation Contract\nReferendum Contract\nParliament Contract\nConsensus Contract\nElection Contract\nGenesis Contract\nMulti Token Contract\nProfit Contract\nCross Chain Contract\nTreasury Contract\nVote Contract\nToken Holder Contract\nEconomic Contract\nToken Converter Contract\nConfiguration Contract\nWeb API\nDocs ReferenceSmart Contract APIReferendum Contract\nReferendum\n\nProduction nodes or associations cannot determine all decisions. Some extremely important decisions, especially those involving user rights and interests, should involve all users and give full control to the user's voting for governance. The Referendum contract is built for this.\n\nImplement aelf Standards ACS1 and ACS3.\n\nContract Methods​\nMethod Name\tRequest Type\tResponse Type\tDescription\nReclaimVoteToken\taelf.Hash\tgoogle.protobuf.Empty\tUnlock the token used for voting according to proposal id.\nCreateOrganization\tReferendum.CreateOrganizationInput\taelf.Address\tCreate an organization and return its address.\nCreateOrganizationBySystemContract\tReferendum.CreateOrganizationBySystemContractInput\taelf.Address\tCreates an organization by system contract and return its address.\nGetOrganization\taelf.Address\tReferendum.Organization\tGet the organization according to the organization address.\nCalculateOrganizationAddress\tReferendum.CreateOrganizationInput\taelf.Address\tCalculate the input and return the organization address.\nGetProposalVirtualAddress\taelf.Hash\taelf.Address\tGet the virtual address of a proposal based on the proposal id.\nAElf.Standards.ACS1​\nMethod Name\tRequest Type\tResponse Type\tDescription\nSetMethodFee\tacs1.MethodFees\tgoogle.protobuf.Empty\tSet the method fees for the specified method. Note that this will override all fees of the method.\nChangeMethodFeeController\tAuthorityInfo\tgoogle.protobuf.Empty\tChange the method fee controller, the default is parliament and default organization.\nGetMethodFee\tgoogle.protobuf.StringValue\tacs1.MethodFees\tQuery method fee information by method name.\nGetMethodFeeController\tgoogle.protobuf.Empty\tAuthorityInfo\tQuery the method fee controller.\nAElf.Standards.ACS3​\nMethod Name\tRequest Type\tResponse Type\tDescription\nCreateProposal\tacs3.CreateProposalInput\taelf.Hash\tCreate a proposal for which organization members can vote. When the proposal is released, a transaction will be sent to the specified contract. Return id of the newly created proposal.\nApprove\taelf.Hash\tgoogle.protobuf.Empty\tApprove a proposal according to the proposal ID.\nReject\taelf.Hash\tgoogle.protobuf.Empty\tReject a proposal according to the proposal ID.\nAbstain\taelf.Hash\tgoogle.protobuf.Empty\tAbstain a proposal according to the proposal ID.\nRelease\taelf.Hash\tgoogle.protobuf.Empty\tRelease a proposal according to the proposal ID and send a transaction to the specified contract.\nChangeOrganizationThreshold\tacs3.ProposalReleaseThreshold\tgoogle.protobuf.Empty\tChange the thresholds associated with proposals. All fields will be overwritten by the input value and this will affect all current proposals of the organization. Note: only the organization can execute this through a proposal.\nChangeOrganizationProposerWhiteList\tacs3.ProposerWhiteList\tgoogle.protobuf.Empty\tChange the white list of organization proposer. This method overrides the list of whitelisted proposers.\nCreateProposalBySystemContract\tacs3.CreateProposalBySystemContractInput\taelf.Hash\tCreate a proposal by system contracts, and return id of the newly created proposal.\nClearProposal\taelf.Hash\tgoogle.protobuf.Empty\tRemove the specified proposal. If the proposal is in effect, the cleanup fails.\nGetProposal\taelf.Hash\tacs3.ProposalOutput\tGet the proposal according to the proposal ID.\nValidateOrganizationExist\taelf.Address\tgoogle.protobuf.BoolValue\tCheck the existence of an organization.\nValidateProposerInWhiteList\tacs3.ValidateProposerInWhiteListInput\tgoogle.protobuf.BoolValue\tCheck if the proposer is whitelisted.\nContract Types​\nAElf.Contracts.Referendum​\nReferendum.CreateOrganizationBySystemContractInput​\nField\tType\tDescription\tLabel\norganization_creation_input\tCreateOrganizationInput\tThe parameters of creating organization.\t\norganization_address_feedback_method\tstring\tThe organization address callback method which replies the organization address to caller contract.\t\nReferendum.CreateOrganizationInput​\nField\tType\tDescription\tLabel\ntoken_symbol\tstring\tThe token used during proposal operations.\t\nproposal_release_threshold\tacs3.ProposalReleaseThreshold\tThe threshold for releasing the proposal.\t\nproposer_white_list\tacs3.ProposerWhiteList\tThe proposer whitelist.\t\ncreation_token\taelf.Hash\tThe creation token is for organization address generation.\t\nReferendum.Organization​\nField\tType\tDescription\tLabel\nproposal_release_threshold\tacs3.ProposalReleaseThreshold\tThe threshold for releasing the proposal.\t\ntoken_symbol\tstring\tThe token used during proposal operations.\t\norganization_address\taelf.Address\tThe address of organization.\t\norganization_hash\taelf.Hash\tThe organization's id.\t\nproposer_white_list\tacs3.ProposerWhiteList\tThe proposer whitelist.\t\ncreation_token\taelf.Hash\tThe creation token is for organization address generation.\t\nReferendum.ProposalInfo​\nField\tType\tDescription\tLabel\nproposal_id\taelf.Hash\tThe proposal ID.\t\ncontract_method_name\tstring\tThe method that this proposal will call when being released.\t\nto_address\taelf.Address\tThe address of the target contract.\t\nparams\tbytes\tThe parameters of the release transaction.\t\nexpired_time\tgoogle.protobuf.Timestamp\tThe date at which this proposal will expire.\t\nproposer\taelf.Address\tThe address of the proposer of this proposal.\t\norganization_address\taelf.Address\tThe address of this proposal's organization.\t\napproval_count\tint64\tThe count of approved.\t\nrejection_count\tint64\tThe count of rejected.\t\nabstention_count\tint64\tThe count of abstained.\t\nproposal_description_url\tstring\tURL used for proposal describing.\t\nReferendum.Receipt​\nField\tType\tDescription\tLabel\namount\tint64\tThe amount of token locked.\t\ntoken_symbol\tstring\tThe symbol of token locked.\t\nlock_id\taelf.Hash\tThe lock ID.\t\nReferendum.ReferendumReceiptCreated​\nField\tType\tDescription\tLabel\nproposal_id\taelf.Hash\tThe ID of the proposal.\t\naddress\taelf.Address\tThe sender address.\t\nsymbol\tstring\tThe symbol of token locked.\t\namount\tint64\tThe amount of token locked.\t\nreceipt_type\tstring\tThe type of receipt (Approve, Reject, or Abstain).\t\ntime\tgoogle.protobuf.Timestamp\tThe timestamp of this method call.\t\norganization_address\taelf.Address\tThe address of the organization.\t\nAElf.Standards.ACS1​\nacs1.MethodFee​\nField\tType\tDescription\tLabel\nsymbol\tstring\tThe token symbol of the method fee.\t\nbasic_fee\tint64\tThe amount of fees to be charged.\t\nacs1.MethodFees​\nField\tType\tDescription\tLabel\nmethod_name\tstring\tThe name of the method to be charged.\t\nfees\tMethodFee\tList of fees to be charged.\trepeated\nis_size_fee_free\tbool\tOptional based on the implementation.\t\nAElf.Standards.ACS3​\nacs3.CreateProposalBySystemContractInput​\nField\tType\tDescription\tLabel\nproposal_input\tCreateProposalInput\tThe parameters of creating proposal.\t\norigin_proposer\taelf.Address\tThe actor that triggers the call.\t\nacs3.CreateProposalInput​\nField\tType\tDescription\tLabel\ncontract_method_name\tstring\tThe name of the method to call after release.\t\nto_address\taelf.Address\tThe address of the contract to call after release.\t\nparams\tbytes\tThe parameter of the method to be called after the release.\t\nexpired_time\tgoogle.protobuf.Timestamp\tThe timestamp at which this proposal will expire.\t\norganization_address\taelf.Address\tThe address of the organization.\t\nproposal_description_url\tstring\tURL used for proposal description.\t\ntoken\taelf.Hash\tThe token for proposal ID generation.\t\nacs3.OrganizationCreated​\nField\tType\tDescription\tLabel\norganization_address\taelf.Address\tThe address of the created organization.\t\nacs3.OrganizationHashAddressPair​\nField\tType\tDescription\tLabel\norganization_hash\taelf.Hash\tThe ID of the organization.\t\norganization_address\taelf.Address\tThe address of organization.\t\nacs3.OrganizationThresholdChanged​\nField\tType\tDescription\tLabel\norganization_address\taelf.Address\tThe organization address\t\nproposer_release_threshold\tProposalReleaseThreshold\tThe new release threshold.\t\nacs3.OrganizationWhiteListChanged​\nField\tType\tDescription\tLabel\norganization_address\taelf.Address\tThe organization address.\t\nproposer_white_list\tProposerWhiteList\tThe new proposer whitelist.\t\nacs3.ProposalCreated​\nField\tType\tDescription\tLabel\nproposal_id\taelf.Hash\tThe ID of the created proposal.\t\norganization_address\taelf.Address\tThe organization address of the created proposal.\t\nacs3.ProposalOutput​\nField\tType\tDescription\tLabel\nproposal_id\taelf.Hash\tThe ID of the proposal.\t\ncontract_method_name\tstring\tThe method that this proposal will call when being released.\t\nto_address\taelf.Address\tThe address of the target contract.\t\nparams\tbytes\tThe parameters of the release transaction.\t\nexpired_time\tgoogle.protobuf.Timestamp\tThe date at which this proposal will expire.\t\norganization_address\taelf.Address\tThe address of this proposal's organization.\t\nproposer\taelf.Address\tThe address of the proposer of this proposal.\t\nto_be_released\tbool\tIndicates if this proposal is releasable.\t\napproval_count\tint64\tApproval count for this proposal.\t\nrejection_count\tint64\tRejection count for this proposal.\t\nabstention_count\tint64\tAbstention count for this proposal.\t\nacs3.ProposalReleaseThreshold​\nField\tType\tDescription\tLabel\nminimal_approval_threshold\tint64\tThe value for the minimum approval threshold.\t\nmaximal_rejection_threshold\tint64\tThe value for the maximal rejection threshold.\t\nmaximal_abstention_threshold\tint64\tThe value for the maximal abstention threshold.\t\nminimal_vote_threshold\tint64\tThe value for the minimal vote threshold.\t\nAElf.Standards.ACS1​\nacs1.MethodFee​\nField\tType\tDescription\tLabel\nsymbol\tstring\tThe token symbol of the method fee.\t\nbasic_fee\tint64\tThe amount of fees to be charged.\t\nacs1.MethodFees​\nField\tType\tDescription\tLabel\nmethod_name\tstring\tThe name of the method to be charged.\t\nfees\tMethodFee\tList of fees to be charged.\trepeated\nis_size_fee_free\tbool\tOptional based on the implementation.\t\nAElf.Standards.ACS3​\nacs3.CreateProposalBySystemContractInput​\nField\tType\tDescription\tLabel\nproposal_input\tCreateProposalInput\tThe parameters of creating proposal.\t\norigin_proposer\taelf.Address\tThe actor that triggers the call.\t\nacs3.CreateProposalInput​\nField\tType\tDescription\tLabel\ncontract_method_name\tstring\tThe name of the method to call after release.\t\nto_address\taelf.Address\tThe address of the contract to call after release.\t\nparams\tbytes\tThe parameter of the method to be called after the release.\t\nexpired_time\tgoogle.protobuf.Timestamp\tThe timestamp at which this proposal will expire.\t\norganization_address\taelf.Address\tThe address of the organization.\t\nproposal_description_url\tstring\tURL used for proposal description.\t\ntoken\taelf.Hash\tThe token for proposal ID generation.\t\nacs3.OrganizationCreated​\nField\tType\tDescription\tLabel\norganization_address\taelf.Address\tThe address of the created organization.\t\nacs3.OrganizationHashAddressPair​\nField\tType\tDescription\tLabel\norganization_hash\taelf.Hash\tThe ID of organization.\t\norganization_address\taelf.Address\tThe address of organization.\t\nacs3.OrganizationThresholdChanged​\nField\tType\tDescription\tLabel\norganization_address\taelf.Address\tThe organization address\t\nproposer_release_threshold\tProposalReleaseThreshold\tThe new release threshold.\t\nacs3.OrganizationWhiteListChanged​\nField\tType\tDescription\tLabel\norganization_address\taelf.Address\tThe organization address.\t\nproposer_white_list\tProposerWhiteList\tThe new proposer whitelist.\t\nacs3.ProposalCreated​\nField\tType\tDescription\tLabel\nproposal_id\taelf.Hash\tThe ID of the created proposal.\t\norganization_address\taelf.Address\tThe organization address.\t\nacs3.ProposalOutput​\nField\tType\tDescription\tLabel\nproposal_id\taelf.Hash\tThe ID of the proposal.\t\ncontract_method_name\tstring\tThe method that this proposal will call when being released.\t\nto_address\taelf.Address\tThe address of the target contract.\t\nparams\tbytes\tThe parameters of the release transaction.\t\nexpired_time\tgoogle.protobuf.Timestamp\tThe date at which this proposal will expire.\t\norganization_address\taelf.Address\tThe address of this proposal's organization.\t\nproposer\taelf.Address\tThe address of the proposer of this proposal.\t\nto_be_released\tbool\tIndicates if this proposal is releasable.\t\napproval_count\tint64\tApproval count for this proposal.\t\nrejection_count\tint64\tRejection count for this proposal.\t\nabstention_count\tint64\tAbstention count for this proposal.\t\nacs3.ProposalReleaseThreshold​\nField\tType\tDescription\tLabel\nminimal_approval_threshold\tint64\tThe value for the minimum approval threshold.\t\nmaximal_rejection_threshold\tint64\tThe value for the maximal rejection threshold.\t\nmaximal_abstention_threshold\tint64\tThe value for the maximal abstention threshold.\t\nminimal_vote_threshold\tint64\tThe value for the minimal vote threshold.\t\nacs3.ProposalReleased​\nField\tType\tDescription\tLabel\nproposal_id\taelf.Hash\tThe id of the released proposal.\t\norganization_address\taelf.Address\tThe organization address of the released proposal.\t\nacs3.ProposerWhiteList​\nField\tType\tDescription\tLabel\nproposers\taelf.Address\tThe address of the proposers\trepeated\nacs3.ReceiptCreated​\nField\tType\tDescription\tLabel\nproposal_id\taelf.Hash\tThe id of the proposal.\t\naddress\taelf.Address\tThe sender address.\t\nreceipt_type\tstring\tThe type of receipt (Approve, Reject, or Abstain).\t\ntime\tgoogle.protobuf.Timestamp\tThe timestamp of this method call.\t\norganization_address\taelf.Address\tThe address of the organization.\t\nacs3.ValidateProposerInWhiteListInput​\nField\tType\tDescription\tLabel\nproposer\taelf.Address\tThe address to search/check.\t\norganization_address\taelf.Address\tThe address of the organization.\t\nAElf.Types​\naelf.Address​\nField\tType\tDescription\tLabel\nvalue\tbytes\t\t\naelf.BinaryMerkleTree​\nField\tType\tDescription\tLabel\nnodes\tHash\tThe leaf nodes.\trepeated\nroot\tHash\tThe root node hash.\t\nleaf_count\tint32\tThe count of leaf node.\t\naelf.Hash​\nField\tType\tDescription\tLabel\nvalue\tbytes\t\t\naelf.LogEvent​\nField\tType\tDescription\tLabel\naddress\tAddress\tThe contract address.\t\nname\tstring\tThe name of the log event.\t\nindexed\tbytes\tThe indexed data.\trepeated\nnon_indexed\tbytes\tThe non-indexed data.\t\naelf.MerklePath​\nField\tType\tDescription\tLabel\nmerkle_path_nodes\tMerklePathNode\tThe merkle path nodes.\trepeated\naelf.MerklePathNode​\nField\tType\tDescription\tLabel\nhash\tHash\tThe node hash.\t\nis_left_child_node\tbool\tWhether it is a left child node.\t\naelf.SInt32Value​\nField\tType\tDescription\tLabel\nvalue\tsint32\t\t\naelf.SInt64Value​\nField\tType\tDescription\tLabel\nvalue\tsint64\t\t\naelf.ScopedStatePath​\nField\tType\tDescription\tLabel\naddress\tAddress\tThe scope address.\t\npath\tStatePath\tThe path of contract state.\t\naelf.SmartContractRegistration​\nField\tType\tDescription\tLabel\ncategory\tsint32\tThe category of contract code(0: C#).\t\ncode\tbytes\tThe byte array of the contract code.\t\ncode_hash\tHash\tThe hash of the contract code.\t\nis_system_contract\tbool\tWhether it is a system contract.\t\nversion\tint32\tThe version of the current contract.\t\naelf.StatePath​\nField\tType\tDescription\tLabel\nparts\tstring\tThe partial path of the state path.\trepeated\naelf.Transaction​\nField\tType\tDescription\tLabel\nfrom\tAddress\tThe address of the sender of the transaction.\t\nto\tAddress\tThe address of the contract when calling a contract.\t\nref_block_number\tint64\tThe height of the referenced block hash.\t\nref_block_prefix\tbytes\tThe first four bytes of the referenced block hash.\t\nmethod_name\tstring\tThe name of a method in the smart contract at the To address.\t\nparams\tbytes\tThe parameters to pass to the smart contract method.\t\nsignature\tbytes\tWhen signing a transaction it’s actually a subset of the fields.\t\naelf.TransactionExecutingStateSet​\nField\tType\tDescription\tLabel\nwrites\tTransactionExecutingStateSet.WritesEntry\tThe changed states.\trepeated\nreads\tTransactionExecutingStateSet.ReadsEntry\tThe read states.\trepeated\ndeletes\tTransactionExecutingStateSet.DeletesEntry\tThe deleted states.\trepeated\naelf.TransactionExecutingStateSet.DeletesEntry​\nField\tType\tDescription\tLabel\nkey\tstring\t\t\nvalue\tbool\t\t\naelf.TransactionExecutingStateSet.ReadsEntry​\nField\tType\tDescription\tLabel\nkey\tstring\t\t\nvalue\tbool\t\t\naelf.TransactionExecutingStateSet.WritesEntry​\nField\tType\tDescription\tLabel\nkey\tstring\t\t\nvalue\tbytes\t\t\naelf.TransactionResult​\nField\tType\tDescription\tLabel\ntransaction_id\tHash\tThe transaction id.\t\nstatus\tTransactionResultStatus\tThe transaction result status.\t\nlogs\tLogEvent\tThe log events.\trepeated\nbloom\tbytes\tBloom filter for transaction logs.\t\nreturn_value\tbytes\tThe return value of the transaction execution.\t\nblock_number\tint64\tThe height of the block hat packages the transaction.\t\nblock_hash\tHash\tThe hash of the block hat packages the transaction.\t\nerror\tstring\tFailed execution error message.\t\naelf.TransactionResultStatus​\nName\tNumber\tDescription\nNOT_EXISTED\t0\tThe execution result of the transaction does not exist.\nPENDING\t1\tThe transaction is in the transaction pool waiting to be packaged.\nFAILED\t2\tTransaction execution failed.\nMINED\t3\tThe transaction was successfully executed and successfully packaged into a block.\nCONFLICT\t4\tWhen executed in parallel, there are conflicts with other transactions.\nPENDING_VALIDATION\t5\tThe transaction is waiting for validation.\nNODE_VALIDATION_FAILED\t6\tTransaction validation failed.\nAuthorityInfo​\nField\tType\tDescription\tLabel\ncontract_address\taelf.Address\tThe contract address of the controller.\t\nowner_address\taelf.Address\tThe address of the owner of the contract.\t\nPrevious\nAssociation Contract\nNext\nParliament Contract\nContract Methods\nAElf.Standards.ACS1\nAElf.Standards.ACS3\nContract Types\nAElf.Contracts.Referendum\nReferendum.CreateOrganizationBySystemContractInput\nReferendum.CreateOrganizationInput\nReferendum.Organization\nReferendum.ProposalInfo\nReferendum.Receipt\nReferendum.ReferendumReceiptCreated\nAElf.Standards.ACS1\nacs1.MethodFee\nacs1.MethodFees\nAElf.Standards.ACS3\nacs3.CreateProposalBySystemContractInput\nacs3.CreateProposalInput\nacs3.OrganizationCreated\nacs3.OrganizationHashAddressPair\nacs3.OrganizationThresholdChanged\nacs3.OrganizationWhiteListChanged\nacs3.ProposalCreated\nacs3.ProposalOutput\nacs3.ProposalReleaseThreshold\nAElf.Standards.ACS1\nacs1.MethodFee\nAElf.Standards.ACS3\nacs3.CreateProposalBySystemContractInput\nacs3.CreateProposalInput\nacs3.OrganizationCreated\nacs3.OrganizationHashAddressPair\nacs3.OrganizationThresholdChanged\nacs3.OrganizationWhiteListChanged\nacs3.ProposalCreated\nacs3.ProposalOutput\nacs3.ProposalReleaseThreshold\nacs3.ProposalReleased\nacs3.ProposerWhiteList\nacs3.ReceiptCreated\nacs3.ValidateProposerInWhiteListInput\nAElf.Types\naelf.Address\naelf.BinaryMerkleTree\naelf.Hash\naelf.LogEvent\naelf.MerklePath\naelf.MerklePathNode\naelf.SInt32Value\naelf.SInt64Value\naelf.ScopedStatePath\naelf.SmartContractRegistration\naelf.StatePath\naelf.Transaction\naelf.TransactionExecutingStateSet\naelf.TransactionExecutingStateSet.DeletesEntry\naelf.TransactionExecutingStateSet.ReadsEntry\naelf.TransactionExecutingStateSet.WritesEntry\naelf.TransactionResult\naelf.TransactionResultStatus\nAuthorityInfo\nPlatform\nTechnology\nAudit Report\nPrivacy\nTerms of Use\nCookie Policy\nDeveloper Resources\nQuick Start\nLearn\nDocs\nTools\nResources\nEcosystem\nOverview\ndApps\naelf Ventures\nBlog\nConnect\nContact Us\nCopyright © 2024 aelf"
    },
    {
      "title": "Association Contract | AELF Docs",
      "url": "https://docs.aelf.com/docs/smart-contract-api/association-contract/",
      "html": "Skip to main content\nQuick Start\nLearn\nDocs\nTools\nResources\nBlog\nSearch\nDocs Reference\nSmart Contract API\nAssociation Contract\nReferendum Contract\nParliament Contract\nConsensus Contract\nElection Contract\nGenesis Contract\nMulti Token Contract\nProfit Contract\nCross Chain Contract\nTreasury Contract\nVote Contract\nToken Holder Contract\nEconomic Contract\nToken Converter Contract\nConfiguration Contract\nWeb API\nDocs ReferenceSmart Contract APIAssociation Contract\nAssociation contract\n\nOrganizations established to achieve specific goals can use this contract to cooperatively handle transactions within the organization.\n\nImplements aelf Standards ACS1 and ACS3.\n\nContract Methods​\nMethod Name\tRequest Type\tResponse Type\tDescription\nCreateOrganization\tAssociation.CreateOrganizationInput\taelf.Address\tCreate an organization and return its address.\nCreateOrganizationBySystemContract\tAssociation.CreateOrganizationBySystemContractInput\taelf.Address\tCreates an organization by system contract and return its address.\nAddMember\taelf.Address\tgoogle.protobuf.Empty\tAdd organization members.\nRemoveMember\taelf.Address\tgoogle.protobuf.Empty\tRemove organization members.\nChangeMember\tAssociation.ChangeMemberInput\tgoogle.protobuf.Empty\tReplace organization member with a new member.\nGetOrganization\taelf.Address\tAssociation.Organization\tGet the organization according to the organization address.\nCalculateOrganizationAddress\tAssociation.CreateOrganizationInput\taelf.Address\tCalculate the input and return the organization address.\nAElf.Standards.ACS1​\nMethod Name\tRequest Type\tResponse Type\tDescription\nSetMethodFee\tacs1.MethodFees\tgoogle.protobuf.Empty\tSet the method fees for the specified method. Note that this will override all fees of the method.\nChangeMethodFeeController\tAuthorityInfo\tgoogle.protobuf.Empty\tChange the method fee controller, the default is parliament and default organization.\nGetMethodFee\tgoogle.protobuf.StringValue\tacs1.MethodFees\tQuery method fee information by method name.\nGetMethodFeeController\tgoogle.protobuf.Empty\tAuthorityInfo\tQuery the method fee controller.\nAElf.Standards.ACS3​\nMethod Name\tRequest Type\tResponse Type\tDescription\nCreateProposal\tacs3.CreateProposalInput\taelf.Hash\tCreate a proposal for which organization members can vote. When the proposal is released, a transaction will be sent to the specified contract. Return id of the newly created proposal.\nApprove\taelf.Hash\tgoogle.protobuf.Empty\tApprove a proposal according to the proposal ID.\nReject\taelf.Hash\tgoogle.protobuf.Empty\tReject a proposal according to the proposal ID.\nAbstain\taelf.Hash\tgoogle.protobuf.Empty\tAbstain a proposal according to the proposal ID.\nRelease\taelf.Hash\tgoogle.protobuf.Empty\tRelease a proposal according to the proposal ID and send a transaction to the specified contract.\nChangeOrganizationThreshold\tacs3.ProposalReleaseThreshold\tgoogle.protobuf.Empty\tChange the thresholds associated with proposals. All fields will be overwritten by the input value and this will affect all current proposals of the organization. Note: only the organization can execute this through a proposal.\nChangeOrganizationProposerWhiteList\tacs3.ProposerWhiteList\tgoogle.protobuf.Empty\tChange the white list of organization proposer. This method overrides the list of whitelisted proposers.\nCreateProposalBySystemContract\tacs3.CreateProposalBySystemContractInput\taelf.Hash\tCreate a proposal by system contracts, and return id of the newly created proposal.\nClearProposal\taelf.Hash\tgoogle.protobuf.Empty\tRemove the specified proposal. If the proposal is in effect, the cleanup fails.\nGetProposal\taelf.Hash\tacs3.ProposalOutput\tGet the proposal according to the proposal ID.\nValidateOrganizationExist\taelf.Address\tgoogle.protobuf.BoolValue\tCheck the existence of an organization.\nValidateProposerInWhiteList\tacs3.ValidateProposerInWhiteListInput\tgoogle.protobuf.BoolValue\tCheck if the proposer is whitelisted.\nContract Types\nAElf.Contracts.Association​\nAssociation.ChangeMemberInput​\nField\tType\tDescription\tLabel\nold_member\taelf.Address\tThe old member address.\t\nnew_member\taelf.Address\tThe new member address.\t\nAssociation.CreateOrganizationBySystemContractInput​\nField\tType\tDescription\tLabel\norganization_creation_input\tCreateOrganizationInput\tThe parameters of creating organization.\t\norganization_address_feedback_method\tstring\tThe organization address callback method which replies the organization address to caller contract.\t\nAssociation.CreateOrganizationInput​\nField\tType\tDescription\tLabel\norganization_member_list\tOrganizationMemberList\tInitial organization members.\t\nproposal_release_threshold\tacs3.ProposalReleaseThreshold\tThe threshold for releasing the proposal.\t\nproposer_white_list\tacs3.ProposerWhiteList\tThe proposer whitelist.\t\ncreation_token\taelf.Hash\tThe creation token is for organization address generation.\t\nAssociation.MemberAdded​\nField\tType\tDescription\tLabel\nmember\taelf.Address\tThe added member address.\t\norganization_address\taelf.Address\tThe organization address.\t\nAssociation.MemberChanged​\nField\tType\tDescription\tLabel\nold_member\taelf.Address\tThe old member address.\t\nnew_member\taelf.Address\tThe new member address.\t\norganization_address\taelf.Address\tThe organization address.\t\nAssociation.MemberRemoved​\nField\tType\tDescription\tLabel\nmember\taelf.Address\tThe removed member address.\t\norganization_address\taelf.Address\tThe organization address.\t\nAssociation.Organization​\nField\tType\tDescription\tLabel\norganization_member_list\tOrganizationMemberList\tThe organization members.\t\nproposal_release_threshold\tacs3.ProposalReleaseThreshold\tThe threshold for releasing the proposal.\t\nproposer_white_list\tacs3.ProposerWhiteList\tThe proposer whitelist.\t\norganization_address\taelf.Address\tThe address of organization.\t\norganization_hash\taelf.Hash\tThe organizations id.\t\ncreation_token\taelf.Hash\tThe creation token is for organization address generation.\t\nAssociation.OrganizationMemberList​\nField\tType\tDescription\tLabel\norganization_members\taelf.Address\tThe address of organization members.\trepeated\nAssociation.ProposalInfo\nField\tType\tDescription\tLabel\nproposal_id\taelf.Hash\tThe proposal ID.\t\ncontract_method_name\tstring\tThe method that this proposal will call when being released.\t\nto_address\taelf.Address\tThe address of the target contract.\t\nparams\tbytes\tThe parameters of the release transaction.\t\nexpired_time\tgoogle.protobuf.Timestamp\tThe date at which this proposal will expire.\t\nproposer\taelf.Address\tThe address of the proposer of this proposal.\t\norganization_address\taelf.Address\tThe address of this proposals organization.\t\napprovals\taelf.Address\tAddress list of approved.\trepeated\nrejections\taelf.Address\tAddress list of rejected.\trepeated\nabstentions\taelf.Address\tAddress list of abstained.\trepeated\nproposal_description_url\tstring\tUrl is used for proposal describing.\t\nACS1​\nacs1.MethodFee​\nField\tType\tDescription\tLabel\nsymbol\tstring\tThe token symbol of the method fee.\t\nbasic_fee\tint64\tThe amount of fees to be charged.\t\nacs1.MethodFees​\nField\tType\tDescription\tLabel\nmethod_name\tstring\tThe name of the method to be charged.\t\nfees\tMethodFee\tList of fees to be charged.\trepeated\nis_size_fee_free\tbool\tOptional based on the implementation of SetMethodFee method.\t\nACS3​\nacs3.CreateProposalBySystemContractInput​\nField\tType\tDescription\tLabel\nproposal_input\tCreateProposalInput\tThe parameters of creating proposal.\t\norigin_proposer\taelf.Address\tThe actor that trigger the call.\t\nacs3.CreateProposalInput​\nField\tType\tDescription\tLabel\ncontract_method_name\tstring\tThe name of the method to call after release.\t\nto_address\taelf.Address\tThe address of the contract to call after release.\t\nparams\tbytes\tThe parameter of the method to be called after the release.\t\nexpired_time\tgoogle.protobuf.Timestamp\tThe timestamp at which this proposal will expire.\t\norganization_address\taelf.Address\tThe address of the organization.\t\nproposal_description_url\tstring\tUrl is used for proposal describing.\t\ntoken\taelf.Hash\tThe token is for proposal id generation and with this token, proposal id can be calculated before proposing.\t\nac3.organizationCreated​\nField\tType\tDescription\tLabel\norganization_address\taelf.Address\tAddress of the created organization.\t\nac3.organizationHashAddressPair​\nField\tType\tDescription\tLabel\norganization_hash\taelf.Hash\tID of the organization.\t\norganization_address\taelf.Address\tAddress of the organization.\t\nac3.organizationThresholdChanged​\nField\tType\tDescription\tLabel\norganization_address\taelf.Address\tOrganization address\t\nproposer_release_threshold\tProposalReleaseThreshold\tNew release threshold.\t\nac3.organizationWhiteListChanged​\nField\tType\tDescription\tLabel\norganization_address\taelf.Address\tOrganization address\t\nproposer_white_list\tProposerWhiteList\tNew proposer whitelist.\t\nac3.proposalCreated​\nField\tType\tDescription\tLabel\nproposal_id\taelf.Hash\tID of the created proposal.\t\norganization_address\taelf.Address\tOrganization address of the created proposal.\t\nac3.proposalOutput​\nField\tType\tDescription\tLabel\nproposal_id\taelf.Hash\tID of the proposal.\t\ncontract_method_name\tstring\tMethod called when the proposal is released.\t\nto_address\taelf.Address\tAddress of the target contract.\t\nparams\tbytes\tParameters of the release transaction.\t\nexpired_time\tgoogle.protobuf.Timestamp\tExpiry date of the proposal.\t\norganization_address\taelf.Address\tOrganization's address for the proposal.\t\nproposer\taelf.Address\tAddress of the proposer.\t\nto_be_released\tbool\tIndicates if the proposal is releasable.\t\napproval_count\tint64\tNumber of approvals.\t\nrejection_count\tint64\tNumber of rejections.\t\nabstention_count\tint64\tNumber of abstentions.\t\nac3.proposalReleaseThreshold​\nField\tType\tDescription\tLabel\nminimal_approval_threshold\tint64\tMinimum approval threshold.\t\nmaximal_rejection_threshold\tint64\tMaximum rejection threshold.\t\nmaximal_abstention_threshold\tint64\tMaximum abstention threshold.\t\nminimal_vote_threshold\tint64\tMinimum vote threshold.\t\nac3.proposalReleased​\nField\tType\tDescription\tLabel\nproposal_id\taelf.Hash\tID of the released proposal.\t\norganization_address\taelf.Address\tOrganization's address of the released proposal.\t\nac3.proposerWhiteList​\nField\tType\tDescription\tLabel\nproposers\taelf.Address\tAddresses of the proposers.\trepeated\nac3.receiptCreated​\nField\tType\tDescription\tLabel\nproposal_id\taelf.Hash\tID of the proposal.\t\naddress\taelf.Address\tSender's address.\t\nreceipt_type\tstring\tType of receipt (Approve, Reject, or Abstain).\t\ntime\tgoogle.protobuf.Timestamp\tTimestamp of the method call.\t\norganization_address\taelf.Address\tOrganization's address.\t\nacs3.ValidateProposerInWhiteListInput​\nField\tType\tDescription\tLabel\nproposer\taelf.Address\tThe address to search/check.\t\norganization_address\taelf.Address\tThe address of the organization.\t\nAElf.Types​\naelf.Address​\nField\tType\tDescription\tLabel\nvalue\tbytes\t\t\naelf.BinaryMerkleTree​\nField\tType\tDescription\tLabel\nnodes\tHash\tThe leaf nodes.\trepeated\nroot\tHash\tThe root node hash.\t\nleaf_count\tint32\tThe count of leaf node.\t\naelf.Hash​\nField\tType\tDescription\tLabel\nvalue\tbytes\t\t\naelf.LogEvent​\nField\tType\tDescription\tLabel\naddress\tAddress\tThe contract address.\t\nname\tstring\tThe name of the log event.\t\nindexed\tbytes\tThe indexed data, used to calculate bloom.\trepeated\nnon_indexed\tbytes\tThe non indexed data.\t\naelf.MerklePath​\nField\tType\tDescription\tLabel\nmerkle_path_nodes\tMerklePathNode\tThe merkle path nodes.\trepeated\naelf.MerklePathNode​\nField\tType\tDescription\tLabel\nhash\tHash\tThe node hash.\t\nis_left_child_node\tbool\tWhether it is a left child node.\t\naelf.SInt32Value​\nField\tType\tDescription\tLabel\nvalue\tsint32\t\t\naelf.SInt64Value​\nField\tType\tDescription\tLabel\nvalue\tsint64\t\t\naelf.ScopedStatePath​\nField\tType\tDescription\tLabel\naddress\tAddress\tThe scope address, which will be the contract address.\t\npath\tStatePath\tThe path of contract state.\t\naelf.SmartContractRegistration​\nField\tType\tDescription\tLabel\ncategory\tsint32\tThe category of contract code(0: C#).\t\ncode\tbytes\tThe byte array of the contract code.\t\ncode_hash\tHash\tThe hash of the contract code.\t\nis_system_contract\tbool\tWhether it is a system contract.\t\nversion\tint32\tThe version of the current contract.\t\naelf.StatePath​\nField\tType\tDescription\tLabel\nparts\tstring\tThe partial path of the state path.\trepeated\naelf.Transaction​\nField\tType\tDescription\tLabel\nfrom\tAddress\tThe address of the sender of the transaction.\t\nto\tAddress\tThe address of the contract when calling a contract.\t\nref_block_number\tint64\tThe height of the referenced block hash.\t\nref_block_prefix\tbytes\tThe first four bytes of the referenced block hash.\t\nmethod_name\tstring\tThe name of a method in the smart contract at the To address.\t\nparams\tbytes\tThe parameters to pass to the smart contract method.\t\nsignature\tbytes\tWhen signing a transaction it’s actually a subset of the fields: from/to and the target method as well as the parameter that were given. It also contains the reference block number and prefix.\t\naelf.TransactionExecutingStateSet​\nField\tType\tDescription\tLabel\nwrites\tTransactionExecutingStateSet.WritesEntry\tThe changed states.\trepeated\nreads\tTransactionExecutingStateSet.ReadsEntry\tThe read states.\trepeated\ndeletes\tTransactionExecutingStateSet.DeletesEntry\tThe deleted states.\trepeated\naelf.TransactionExecutingStateSet.DeletesEntry​\nField\tType\tDescription\tLabel\nkey\tstring\t\t\nvalue\tbool\t\t\naelf.TransactionExecutingStateSet.ReadsEntry​\nField\tType\tDescription\tLabel\nkey\tstring\t\t\nvalue\tbool\t\t\naelf.TransactionExecutingStateSet.WritesEntry​\nField\tType\tDescription\tLabel\nkey\tstring\t\t\nvalue\tbytes\t\t\naelf.TransactionResult​\nField\tType\tDescription\tLabel\ntransaction_id\tHash\tThe transaction id.\t\nstatus\tTransactionResultStatus\tThe transaction result status.\t\nlogs\tLogEvent\tThe log events.\trepeated\nbloom\tbytes\tBloom filter for transaction logs.\t\nreturn_value\tbytes\tThe return value of the transaction execution.\t\nblock_number\tint64\tThe height of the block hat packages the transaction.\t\nblock_hash\tHash\tThe hash of the block hat packages the transaction.\t\nerror\tstring\tFailed execution error message.\t\naelf.TransactionResultStatus​\nName\tNumber\tDescription\nNOT_EXISTED\t0\tThe execution result of the transaction does not exist.\nPENDING\t1\tThe transaction is in the transaction pool waiting to be packaged.\nFAILED\t2\tTransaction execution failed.\nMINED\t3\tThe transaction was successfully executed and successfully packaged into a block.\nCONFLICT\t4\tWhen executed in parallel, there are conflicts with other transactions.\nPENDING_VALIDATION\t5\tThe transaction is waiting for validation.\nNODE_VALIDATION_FAILED\t6\tTransaction validation failed.\nAuthorityInfo​\nField\tType\tDescription\tLabel\ncontract_address\taelf.Address\tThe contract address of the controller.\t\nowner_address\taelf.Address\tThe address of the owner of the contract.\t\nPrevious\nSmart Contract API\nNext\nReferendum Contract\nContract Methods\nAElf.Standards.ACS1\nAElf.Standards.ACS3\nAElf.Contracts.Association\nAssociation.ChangeMemberInput\nAssociation.CreateOrganizationBySystemContractInput\nAssociation.CreateOrganizationInput\nAssociation.MemberAdded\nAssociation.MemberChanged\nAssociation.MemberRemoved\nAssociation.Organization\nAssociation.OrganizationMemberList\nACS1\nacs1.MethodFee\nacs1.MethodFees\nACS3\nacs3.CreateProposalBySystemContractInput\nacs3.CreateProposalInput\nac3.organizationCreated\nac3.organizationHashAddressPair\nac3.organizationThresholdChanged\nac3.organizationWhiteListChanged\nac3.proposalCreated\nac3.proposalOutput\nac3.proposalReleaseThreshold\nac3.proposalReleased\nac3.proposerWhiteList\nac3.receiptCreated\nacs3.ValidateProposerInWhiteListInput\nAElf.Types\naelf.Address\naelf.BinaryMerkleTree\naelf.Hash\naelf.LogEvent\naelf.MerklePath\naelf.MerklePathNode\naelf.SInt32Value\naelf.SInt64Value\naelf.ScopedStatePath\naelf.SmartContractRegistration\naelf.StatePath\naelf.Transaction\naelf.TransactionExecutingStateSet\naelf.TransactionExecutingStateSet.DeletesEntry\naelf.TransactionExecutingStateSet.ReadsEntry\naelf.TransactionExecutingStateSet.WritesEntry\naelf.TransactionResult\naelf.TransactionResultStatus\nAuthorityInfo\nPlatform\nTechnology\nAudit Report\nPrivacy\nTerms of Use\nCookie Policy\nDeveloper Resources\nQuick Start\nLearn\nDocs\nTools\nResources\nEcosystem\nOverview\ndApps\naelf Ventures\nBlog\nConnect\nContact Us\nCopyright © 2024 aelf"
    },
    {
      "title": "aelf C# Core | AELF Docs",
      "url": "https://docs.aelf.com/tools/contract-sdk/aelf-csharp-core/",
      "html": "Skip to main content\nQuick Start\nLearn\nDocs\nTools\nResources\nBlog\nSearch\nTools\nChain SDK\naelf Deploy Tool\naelf CLI\nSmart Contract\naelf Testnet Faucet\naelf Design\naelf Playground\nContract SDK\naelf SDK C#\naelf C# Core\nToolsContract SDKaelf C# Core\nAElf.CSharp.Core\nBuilder type​\n\nNamespace: AElf.CSharp.Core.ServerServiceDefinition\n\nBuilder class for ServerServiceDefinition.\n\nctor() constructor​\n\nCreates a new instance of builder.\n\nAddMethod``2(method, handler) method​\n\nAdds a definition for a single request - single response method.\n\nReturns:​\n\nThis builder instance.\n\nParameters:​\nName\tType\tDescription\nmethod\tAElf.CSharp.Core.Method\tThe method.\nhandler\tAElf.CSharp.Core.UnaryServerMethod\tThe method handler.\nBuild() method​\n\nCreates an immutable ServerServiceDefinition from this builder.\n\nReturns​\n\nThe ServerServiceDefinition object.\n\nEncodingHelper type​\n\nNamespace: AElf.CSharp.Core.Utils\n\nHelper class for serializing strings.\n\nEncodeUtf8(str) method​\n\nSerializes a UTF-8 string to a byte array.\n\nReturns​\n\nThe serialized string.\n\nParameters​\nName\tType\tDescription\nstr\tSystem.String\tThe string to encode.\nIMethod type​\n\nNamespace: AElf.CSharp.Core\n\nA non-generic representation of a remote method.\n\nFullName property​\n\nGets the fully qualified name of the method. On the server side, methods are dispatched based on this name.\n\nName property​\n\nGets the unqualified name of the method.\n\nServiceName property​\n\nGets the name of the service to which this method belongs.\n\nType property​\n\nGets the type of the method.\n\nMarshaller type​\n\nNamespace: AElf.CSharp.Core\n\nEncapsulates the logic for serializing and deserializing messages.\n\nctor(serializer, deserializer) constructor​\n\nInitializes a new marshaller from simple serialize/deserialize functions.\n\nParameters​\nName\tType\tDescription\nserializer\tSystem.Func\tFunction for serializing messages.\ndeserializer\tSystem.Func\tFunction for deserializing messages.\nDeserializer property​\n\nGets the deserializer function.\n\nSerializer property​\n\nGets the serializer function.\n\nMarshallers type​\n\nNamespace: AElf.CSharp.Core\n\nUtilities for creating marshallers.\n\nStringMarshaller property​\n\nReturns a marshaller for string type. Useful for testing.\n\nCreate() method​\n\nCreates a marshaller from specified serializer and deserializer.\n\nMethodType type​\n\nNamespace: AElf.CSharp.Core\n\nConstants for method types.\n\nAction constants​\n\nIndicates the method modifies the contract state.\n\nView constants​\n\nIndicates the method doesn't modify the contract state.\n\nMethod type​\n\nNamespace: AElf.CSharp.Core\n\nA description of a remote method.\n\nctor(type, serviceName, name, requestMarshaller, responseMarshaller) constructor​\n\nInitializes a new instance of the Method class.\n\nParameters​\nName\tType\tDescription\ntype\tAElf.CSharp.Core.Method\tType of method.\nserviceName\tSystem.String\tName of service this method belongs to.\nname\tSystem.String\tUnqualified name of the method.\nrequestMarshaller\tAElf.CSharp.Core.Marshaller\tMarshaller used for request messages.\nresponseMarshaller\tAElf.CSharp.Core.Marshaller\tMarshaller used for response messages.\nFullName property​\n\nGets the fully qualified name of the method. On the server side, methods are dispatched based on this name.\n\nName property​\n\nGets the unqualified name of the method.\n\nRequestMarshaller property​\n\nGets the marshaller used for request messages.\n\nResponseMarshaller property​\n\nGets the marshaller used for response messages.\n\nServiceName property​\n\nGets the name of the service to which this method belongs.\n\nType property​\n\nGets the type of the method.\n\nGetFullName() method​\n\nGets the full name of the method including the service name.\n\nPreconditions type​\n\nNamespace: AElf.CSharp.Core.Utils\n\nUtilities for checking preconditions.\n\nCheckNotNull(reference) method​\n\nThrows ArgumentNullException if reference is null.\n\nParameters​\nName\tType\tDescription\nreference\tAny\tThe reference.\nCheckNotNull(reference, paramName) method​\n\nThrows ArgumentNullException if reference is null.\n\nParameters​\nName\tType\tDescription\nreference\tAny\tThe reference.\nparamName\tSystem.String\tThe parameter name.\nSafeMath type​\n\nNamespace: AElf.CSharp.Core\n\nHelper methods for safe math operations that explicitly check for overflow.\n\nServerServiceDefinition type​\n\nNamespace: AElf.CSharp.Core\n\nStores mapping of methods to server call handlers. Normally, created by the BindService factory method.\n\nBindService() method​\n\nForwards all the previously stored AddMethod calls to the service binder.\n\nCreateBuilder() method​\n\nCreates a new builder object for ServerServiceDefinition.\n\nReturns​\n\nThe builder object.\n\nServiceBinderBase type​\n\nNamespace: AElf.CSharp.Core\n\nAllows binding server-side method implementations in alternative serving stacks.\n\nAddMethod(method, handler) method​\n\nAdds a definition for a single request - single response method.\n\nParameters​\nName\tType\tDescription\nmethod\tAElf.CSharp.Core.Method\tThe method.\nhandler\tAElf.CSharp.Core.UnaryServerMethod\tThe method handler.\nTimestampExtensions type​\n\nNamespace: AElf.CSharp.Core.Extension\n\nHelper methods for dealing with protobuf timestamps.\n\nAddDays(timestamp, days) method​\n\nAdds a given amount of days to a timestamp. Returns a new instance.\n\nReturns​\n\nA new timestamp instance.\n\nParameters​\nName\tType\tDescription\ntimestamp\tGoogle.Protobuf.WellKnownTypes.Timestamp\tThe timestamp.\ndays\tSystem.Int64\tThe amount of days.\nAddHours(timestamp, hours) method​\n\nAdds a given amount of hours to a timestamp. Returns a new instance.\n\nReturns​\n\nA new timestamp instance.\n\nParameters​\nName\tType\tDescription\ntimestamp\tGoogle.Protobuf.WellKnownTypes.Timestamp\tThe timestamp.\nhours\tSystem.Int64\tThe amount of hours.\nAddMilliseconds(timestamp, milliseconds) method​\n\nAdds a given amount of milliseconds to a timestamp. Returns a new instance.\n\nReturns​\n\nA new timestamp instance.\n\nParameters​\nName\tType\tDescription\ntimestamp\tGoogle.Protobuf.WellKnownTypes.Timestamp\tThe timestamp.\nmilliseconds\tSystem.Int64\tThe amount of milliseconds.\nAddMinutes(timestamp, minutes) method​\n\nAdds a given amount of minutes to a timestamp. Returns a new instance.\n\nReturns​\n\nA new timestamp instance.\n\nParameters​\nName\tType\tDescription\ntimestamp\tGoogle.Protobuf.WellKnownTypes.Timestamp\tThe timestamp.\nminutes\tSystem.Int64\tThe amount of minutes.\nAddSeconds(timestamp, seconds) method​\n\nAdds a given amount of seconds to a timestamp. Returns a new instance.\n\nReturns​\n\nA new timestamp instance.\n\nParameters​\nName\tType\tDescription\ntimestamp\tGoogle.Protobuf.WellKnownTypes.Timestamp\tThe timestamp.\nseconds\tSystem.Int64\tThe amount of seconds.\nMax(timestamp1, timestamp2) method​\n\nCompares two timestamps and returns the greater one.\n\nReturns​\n\nThe greater timestamp.\n\nParameters​\nName\tType\tDescription\ntimestamp1\tGoogle.Protobuf.WellKnownTypes.Timestamp\tThe first timestamp.\ntimestamp2\tGoogle.Protobuf.WellKnownTypes.Timestamp\tThe second timestamp.\nMilliseconds(duration) method​\n\nConverts a protobuf duration to long.\n\nReturns​\n\nThe duration represented as a long.\n\nParameters​\nName\tType\tDescription\nduration\tGoogle.Protobuf.WellKnownTypes.Duration\tThe duration to convert.\nUnaryServerMethod type​\n\nNamespace: AElf.CSharp.Core\n\nHandler for a contract method.\n\nGeneric Types​\nName\tDescription\nTRequest\tRequest message type for this method\nTResponse\tResponse message type for this method\nPrevious\naelf SDK C#\nBuilder type\nctor() constructor\nAddMethod``2(method, handler) method\nReturns:\nParameters:\nBuild() method\nReturns\nEncodingHelper type\nEncodeUtf8(str) method\nReturns\nParameters\nIMethod type\nFullName property\nName property\nServiceName property\nType property\nMarshaller type\nctor(serializer, deserializer) constructor\nParameters\nDeserializer property\nSerializer property\nMarshallers type\nStringMarshaller property\nCreate() method\nMethodType type\nAction constants\nView constants\nMethod type\nctor(type, serviceName, name, requestMarshaller, responseMarshaller) constructor\nParameters\nFullName property\nName property\nRequestMarshaller property\nResponseMarshaller property\nServiceName property\nType property\nGetFullName() method\nPreconditions type\nCheckNotNull(reference) method\nParameters\nCheckNotNull(reference, paramName) method\nParameters\nSafeMath type\nServerServiceDefinition type\nBindService() method\nCreateBuilder() method\nReturns\nServiceBinderBase type\nAddMethod(method, handler) method\nParameters\nTimestampExtensions type\nAddDays(timestamp, days) method\nReturns\nParameters\nAddHours(timestamp, hours) method\nReturns\nParameters\nAddMilliseconds(timestamp, milliseconds) method\nReturns\nParameters\nAddMinutes(timestamp, minutes) method\nReturns\nParameters\nAddSeconds(timestamp, seconds) method\nReturns\nParameters\nMax(timestamp1, timestamp2) method\nReturns\nParameters\nMilliseconds(duration) method\nReturns\nParameters\nUnaryServerMethod type\nGeneric Types\nPlatform\nTechnology\nAudit Report\nPrivacy\nTerms of Use\nCookie Policy\nDeveloper Resources\nQuick Start\nLearn\nDocs\nTools\nResources\nEcosystem\nOverview\ndApps\naelf Ventures\nBlog\nConnect\nContact Us\nCopyright © 2024 aelf"
    },
    {
      "title": "AELF Docs",
      "url": "https://docs.aelf.com/tools/contract-sdk/aelf-sdk-csharp/",
      "html": "Skip to main content\nQuick Start\nLearn\nDocs\nTools\nResources\nBlog\nSearch\nTools\nChain SDK\naelf Deploy Tool\naelf CLI\nSmart Contract\naelf Testnet Faucet\naelf Design\naelf Playground\nContract SDK\naelf SDK C#\naelf C# Core\nToolsContract SDKaelf SDK C#\nAElf.Sdk.CSharp\nBoolState type​\n\nNamespace: AElf.Sdk.CSharp.State\n\nWrapper for boolean values in smart contract state.\n\nBytesState type​\n\nNamespace: AElf.Sdk.CSharp.State\n\nWrapper for byte arrays in smart contract state.\n\nCSharpSmartContractContext type​\n\nNamespace: AElf.Sdk.CSharp\n\nRepresents the transaction execution context in a smart contract. Available in the base class for smart contracts (Context property). Provides access to properties and methods useful for implementing smart contract logic.\n\nChainId property​\n\nThe chain ID of the chain where the contract runs.\n\nCurrentBlockTime property​\n\nThe time included in the current block's header.\n\nCurrentHeight property​\n\nThe height of the block containing the currently executing transaction.\n\nOrigin property​\n\nThe address of the sender (signer) of the transaction. This value is constant, even for nested inline calls. It represents the entity that created the transaction (user or smart contract).\n\nPreviousBlockHash property​\n\nThe hash of the block preceding the current one in the blockchain.\n\nSelf property​\n\nThe address of the contract currently being executed. This changes with every transaction and inline transaction.\n\nSender property​\n\nThe sender of the currently executing transaction.\n\nStateProvider property​\n\nProvides access to the underlying state provider.\n\nTransactionId property​\n\nThe ID of the currently executing transaction.\n\nVariables property​\n\nProvides access to variables of the bridge.\n\nTransaction property​\n\nIncludes transaction info.\n\nCall(fromAddress, toAddress, methodName, args) method​\n\nCalls a method on another contract.\n\nReturns:\nThe result of the call.\n\nParameters:\n\nName\tType\tDescription\nfromAddress\tAElf.Types.Address\tThe address to use as sender.\ntoAddress\tAElf.Types.Address\tThe address of the contract you’re seeking to interact with.\nmethodName\tSystem.String\tThe name of the method you want to call.\nargs\tGoogle.Protobuf.ByteString\tThe input arguments for calling that method. This is usually generated from the protobuf definition of the input type.\n\nGeneric Types:\n\nName\tDescription\nT\tThe type of the return message\nConvertHashToInt64(hash, start, end) method​\n\nConverts the input hash to a 64-bit signed integer.\n\nReturns​\n\nThe 64-bit signed integer.\n\nParameters​\nName\tType\tDescription\nhash\tAElf.Types.Hash\tThe hash.\nstart\tSystem.Int64\tInclusive lower bound of the number returned.\nend\tSystem.Int64\tExclusive upper bound of the number returned.\nExceptions​\nName\tDescription\nSystem.ArgumentException\tstartValue is less than 0 or greater than endValue.\nConvertVirtualAddressToContractAddress(virtualAddress) method​\n\nConverts a virtual address to a contract address.\n\nReturns​\n\nThe converted address.\n\nParameters​\nName\tType\tDescription\nvirtualAddress\tAElf.Types.Hash\tThe virtual address to convert.\nConvertVirtualAddressToContractAddress(virtualAddress, contractAddress) method​\n\nConverts a virtual address to a contract address with the contract address.\n\nReturns​\n\nThe converted address.\n\nParameters​\nName\tType\tDescription\nvirtualAddress\tAElf.Types.Hash\tThe virtual address to convert.\ncontractAddress\tAElf.Types.Address\tThe contract address.\nConvertVirtualAddressToContractAddressWithContractHashName(virtualAddress) method​\n\nConverts a virtual address to a contract address with the current contract hash name.\n\nReturns​\n\nThe converted address.\n\nParameters​\nName\tType\tDescription\nvirtualAddress\tAElf.Types.Hash\tThe virtual address to convert.\nConvertVirtualAddressToContractAddressWithContractHashName(virtualAddress, contractAddress) method​\n\nConverts a virtual address to a contract address with the contract hash name.\n\nReturns​\n\nThe converted address.\n\nParameters​\nName\tType\tDescription\nvirtualAddress\tAElf.Types.Hash\tThe virtual address to convert.\ncontractAddress\tAElf.Types.Address\tThe contract address.\nDeployContract(address, registration, name) method​\n\nDeploy a new smart contract (only the genesis contract can call it).\n\nParameters​\nName\tType\tDescription\naddress\tAElf.Types.Address\tThe address of the new smart contract.\nregistration\tAElf.Types.SmartContractRegistration\tThe registration of the new smart contract.\nname\tAElf.Types.Hash\tThe hash value of the smart contract name.\nFireLogEvent(logEvent) method​\n\nThis method is used to produce logs that can be found in the transaction result after execution.\n\nParameters​\nName\tType\tDescription\nlogEvent\tAElf.Types.LogEvent\tThe event to fire.\nGenerateId(contractAddress, bytes) method​\n\nGenerate a hash type id based on the contract address and the bytes.\n\nReturns​\n\nThe generated hash type id.\n\nParameters​\nName\tType\tDescription\ncontractAddress\tAElf.Types.Address\tThe contract address for id generation.\nbytes\tSystem.Collections.Generic.IEnumerable<Byte>\tThe bytes for id generation.\nGetContractAddressByName(hash) method​\n\nGet the address of a system contract by its name hash. These hashes are in the SmartContractConstants.cs file.\n\nReturns​\n\nThe address of the system contract.\n\nParameters​\nName\tType\tDescription\nhash\tAElf.Types.Hash\tThe hash of the name.\nGetPreviousBlockTransactions() method​\n\nReturns the transactions included in the previous block.\n\nReturns​\n\nA list of transactions.\n\nGetRandomHash(fromHash) method​\n\nGets a random hash based on the input hash.\n\nReturns​\n\nRandom hash.\n\nParameters​\nName\tType\tDescription\nfromHash\tAElf.Types.Hash\tHash.\nGetSystemContractNameToAddressMapping() method​\n\nGet the mapping of system contract addresses to their name hashes.\n\nReturns​\n\nThe addresses with their hashes.\n\nGetZeroSmartContractAddress() method​\n\nReturns the address of the Genesis contract (smart contract zero) of the current chain.\n\nReturns​\n\nThe address of the genesis contract.\n\nGetZeroSmartContractAddress(chainId) method​\n\nReturns the address of the Genesis contract (smart contract zero) of the specified chain.\n\nReturns​\n\nThe address of the genesis contract for the given chain.\n\nParameters​\nName\tType\tDescription\nchainId\tSystem.Int32\tThe chain’s ID.\nLogDebug(func) method​\n\nLogs information for debugging. Visible only when the node is in debug mode.\n\nParameters​\nName\tType\tDescription\nfunc\tSystem.Func<System.String>\tThe logic for logging purposes.\nRecoverPublicKey() method​\n\nRecovers the public key of the transaction sender.\n\nReturns​\n\nA byte array representing the public key.\n\nSendInline(toAddress, methodName, args) method​\n\nSends an inline transaction to another contract.\n\nParameters​\nName\tType\tDescription\ntoAddress\tAElf.Types.Address\tThe address of the contract to interact with.\nmethodName\tSystem.String\tThe name of the method to call.\nargs\tGoogle.Protobuf.ByteString\tThe input arguments, usually generated from protobuf.\nSendVirtualInline(fromVirtualAddress, toAddress, methodName, args) method​\n\nSends a virtual inline transaction to another contract.\n\nParameters​\nName\tType\tDescription\nfromVirtualAddress\tAElf.Types.Hash\tThe hash for generating the virtual address.\ntoAddress\tAElf.Types.Address\tThe address of the contract to interact with.\nmethodName\tSystem.String\tThe name of the method to call.\nargs\tGoogle.Protobuf.ByteString\tThe input arguments, usually generated from protobuf.\nSendVirtualInline(fromVirtualAddress, toAddress, methodName, args, logTransaction) method​\n\nSends a virtual inline transaction to another contract and logs the transaction.\n\nParameters​\nName\tType\tDescription\nfromVirtualAddress\tAElf.Types.Hash\tThe hash for generating the virtual address.\ntoAddress\tAElf.Types.Address\tThe address of the contract to interact with.\nmethodName\tSystem.String\tThe name of the method to call.\nargs\tGoogle.Protobuf.ByteString\tThe input arguments, usually generated from protobuf.\nlogTransaction\tSystem.Boolean\tWhether to log the inline transaction.\nSendVirtualInlineBySystemContract(fromVirtualAddress, toAddress, methodName, args) method​\n\nSends a virtual inline transaction using a system smart contract.\n\nParameters​\nName\tType\tDescription\nfromVirtualAddress\tAElf.Types.Hash\tThe hash for generating the virtual address.\ntoAddress\tAElf.Types.Address\tThe address of the contract to interact with.\nmethodName\tSystem.String\tThe name of the method to call.\nargs\tGoogle.Protobuf.ByteString\tThe input arguments, usually generated from protobuf.\nSendVirtualInlineBySystemContract(fromVirtualAddress, toAddress, methodName, args, logTransaction) method​\n\nSends a virtual inline transaction using a system smart contract and logs the transaction.\n\nParameters​\nName\tType\tDescription\nfromVirtualAddress\tAElf.Types.Hash\tThe hash for generating the virtual address.\ntoAddress\tAElf.Types.Address\tThe address of the contract to interact with.\nmethodName\tSystem.String\tThe name of the method to call.\nargs\tGoogle.Protobuf.ByteString\tThe input arguments, usually generated from protobuf.\nlogTransaction\tSystem.Boolean\tWhether to log the inline transaction.\nUpdateContract(address, registration, name) method​\n\nUpdates a smart contract (only the genesis contract can call it).\n\nParameters​\nName\tType\tDescription\naddress\tAElf.Types.Address\tThe address of the smart contract.\nregistration\tAElf.Types.SmartContractRegistration\tThe registration of the contract.\nname\tAElf.Types.Hash\tThe hash value of the contract name.\nValidateStateSize(obj) method​\n\nVerifies that the state size is within the valid limit.\n\nReturns​\n\nThe state.\n\nParameters​\nName\tType\tDescription\nobj\tSystem.Object\tThe state.\nExceptions​\nName\tDescription\nAElf.Kernel.SmartContract.StateOverSizeException\tThe state size exceeds the limit.\nVerifySignature(tx) method​\n\nChecks if the transaction is well-formed and the signature is correct.\n\nReturns​\n\nThe verification result.\n\nParameters​\nName\tType\tDescription\ntx\tAElf.Types.Transaction\tThe transaction to verify.\nCheckContractVersion(previousContractVersion, registration) method​\n\nChecks the contract version when updating the contract (only the genesis contract can call it).\n\nReturns​\nName\tType\tDescription\nIsSubsequentVersion\tSystem.Boolean\tWhether the contract version is subsequent.\nParameters​\nName\tType\tDescription\npreviousContractVersion\tSystem.String\tThe previous contract version.\nregistration\tAElf.Types.SmartContractRegistration\tThe registration of the contract.\nDeploySmartContract(address, registration, name) method​\n\nDeploys a new smart contract with a version (only the genesis contract can call it).\n\nReturns​\nName\tType\tDescription\nContractVersion\tSystem.String\tThe version of the smart contract.\nIsSubsequentVersion\tSystem.Boolean\tWhether the contract version is subsequent.\nParameters​\nName\tType\tDescription\naddress\tAElf.Types.Address\tThe address of the new smart contract.\nregistration\tAElf.Types.SmartContractRegistration\tThe registration of the contract.\nname\tAElf.Types.Hash\tThe hash value of the contract name.\nUpdateSmartContract(address, registration, name, previousContractVersion) method​\n\nUpdates a smart contract with a version (only the genesis contract can call it).\n\nReturns​\nName\tType\tDescription\nContractVersion\tSystem.String\tThe version of the smart contract.\nIsSubsequentVersion\tSystem.Boolean\tWhether the contract version is subsequent.\nParameters​\nName\tType\tDescription\naddress\tAElf.Types.Address\tThe address of the smart contract.\nregistration\tAElf.Types.SmartContractRegistration\tThe registration of the contract.\nname\tAElf.Types.Hash\tThe hash value of the contract name.\npreviousContractVersion\tSystem.String\tThe previous contract version.\nECVrfVerify(pubKey, alpha, pi, beta) method​\n\nVerifies the ECVrf proof.\n\nReturns​\n\nThe verification result and the VRF hash output.\n\nParameters​\nName\tType\tDescription\npubKey\tbyte[]\tThe public key.\nalpha\tbyte[]\tThe VRF hash input.\npi\tbyte[]\tThe proof to be verified.\nbeta\tbyte[]\tThe VRF hash output.\nCSharpSmartContract type​\n\nNamespace: AElf.Sdk.CSharp\n\nBase class for contracts written in C#. Generated code from protobuf definitions inherits from this class.\n\nGeneric Types​\nName\tDescription\nTContractState\tType of the state class defined by the contract author.\nContext property​\n\nRepresents the transaction execution context in a smart contract. Provides access to properties and methods for implementing the contract logic.\n\nState property​\n\nProvides access to the State class instance.\n\nContractState type​\n\nNamespace: AElf.Sdk.CSharp.State\n\nBase class for the state class in smart contracts.\n\nInt32State type​\n\nNamespace: AElf.Sdk.CSharp.State\n\nWrapper around 32-bit integer values for use in smart contract state.\n\nInt64State type​\n\nNamespace: AElf.Sdk.CSharp.State\n\nWrapper around 64-bit integer values for use in smart contract state.\n\nMappedState type​\n\nNamespace: AElf.Sdk.CSharp.State\n\nKey-value pair data structure used for representing state in contracts.\n\nGeneric Types​\nName\tDescription\nTKey\tThe type of the key.\nTEntity\tThe type of the value.\nSingletonState type​\n\nNamespace: AElf.Sdk.CSharp.State\n\nRepresents single values of a given type for use in smart contract state.\n\nSmartContractBridgeContextExtensions type​\n\nNamespace: AElf.Sdk.CSharp\n\nExtension methods to interact with the smart contract execution context.\n\nCall(context, address, methodName, message) method​\n\nCalls a method on another contract.\n\nReturns:​\n\nThe result of the call.\n\nParameters:​\nName\tType\tDescription\ncontext\tAElf.Kernel.SmartContract.ISmartContractBridgeContext\tThe virtual address to use as sender.\naddress\tAElf.Types.Address\tThe contract address to interact with.\nmethodName\tSystem.String\tThe name of the method to call.\nmessage\tGoogle.Protobuf.ByteString\tThe input arguments for the method.\nGeneric Types:​\nName\tDescription\nT\tThe return type of the call.\nCall(context, address, methodName, message) method​\n\nCalls a method on another contract.\n\nReturns:​\n\nThe result of the call.\n\nParameters:​\nName\tType\tDescription\ncontext\tAElf.Sdk.CSharp.CSharpSmartContractContext\tAn instance of ISmartContractBridgeContext.\naddress\tAElf.Types.Address\tThe contract address to interact with.\nmethodName\tSystem.String\tThe name of the method to call.\nmessage\tGoogle.Protobuf.ByteString\tThe input arguments for the method.\nGeneric Types:​\nName\tDescription\nT\tThe return type of the call.\nCall(context, fromAddress, toAddress, methodName, message) method​\n\nCalls a method on another contract.\n\nReturns:​\n\nThe result of the call.\n\nParameters:​\nName\tType\tDescription\ncontext\tAElf.Sdk.CSharp.CSharpSmartContractContext\tAn instance of ISmartContractBridgeContext.\nfromAddress\tAElf.Types.Address\tThe address to use as sender.\ntoAddress\tAElf.Types.Address\tThe contract address to interact with.\nmethodName\tSystem.String\tThe name of the method to call.\nmessage\tGoogle.Protobuf.ByteString\tThe input arguments for the method.\nGeneric Types:​\nName\tDescription\nT\tThe return type of the call.\nConvertToByteString(message) method​\n\nSerializes a protobuf message to a ByteString.\n\nReturns:​\n\nByteString.Empty if the message is null.\n\nParameters:​\nName\tType\tDescription\nmessage\tGoogle.Protobuf.IMessage\tThe message to serialize.\nConvertVirtualAddressToContractAddress(this, virtualAddress) method​\n\nConverts a virtual address to a contract address.\n\nParameters​\nName\tType\tDescription\nthis\tAElf.Kernel.SmartContract.ISmartContractBridgeContext\tAn instance of ISmartContractBridgeContext.\nvirtualAddress\tAElf.Types.Hash Address\tThe virtual address to convert.\nConvertVirtualAddressToContractAddressWithContractHashName(this, virtualAddress) method​\n\nConverts a virtual address to a contract address with the current contract address.\n\nParameters:​\nName\tType\tDescription\nthis\tAElf.Kernel.SmartContract.ISmartContractBridgeContext\tAn instance of ISmartContractBridgeContext.\nvirtualAddress\tAElf.Types.Hash Address\tThe virtual address to convert.\nFire(context, eventData) method​\n\nLogs an event during a transaction.\n\nParameters:​\nName\tType\tDescription\ncontext\tAElf.Sdk.CSharp.CSharpSmartContractContext\tAn instance of ISmartContractBridgeContext.\neventData\t\tThe event to log.\nGeneric Types:​\nName\tDescription\nT\tThe type of the event.\nGenerateId(this, bytes) method​\n\nGenerates a hash type ID based on the current contract address and the bytes.\n\nReturns: The generated hash type ID.​\nParameters:​\nName\tType\tDescription\nthis\tAElf.Kernel.SmartContract.ISmartContractBridgeContext\tAn instance of ISmartContractBridgeContext.\nbytes\tSystem.Collections.Generic.IEnumerable{System.Byte}\tThe bytes for ID generation.\nGenerateId(this, token) method​\n\nGenerates a hash type ID based on the current contract address and the token.\n\nReturns:​\n\nThe generated hash type ID.\n\nParameters:​\nName\tType\tDescription\nthis\tAElf.Kernel.SmartContract.ISmartContractBridgeContext\tAn instance of ISmartContractBridgeContext.\ntoken\tSystem.String\tThe token for ID generation.\nGenerateId(this, token) method​\n\nGenerates a hash type ID based on the current contract address and the hash type token.\n\nReturns: The generated hash type ID.​\nParameters:​\nName\tType\tDescription\nthis\tAElf.Kernel.SmartContract.ISmartContractBridgeContext\tAn instance of ISmartContractBridgeContext.\ntoken\tAElf.Types.Hash\tThe hash type token for ID generation.\nGenerateId(this) method​\n\nGenerates a hash type ID based on the current contract address.\n\nReturns: The generated hash type ID.​\nParameters:​\nName\tType\tDescription\nthis\tAElf.Kernel.SmartContract.ISmartContractBridgeContext\tAn instance of ISmartContractBridgeContext.\nGenerateId(this, address, token) method​\n\nGenerates a hash type ID based on the address and the bytes.\n\nReturns:​\n\nThe generated hash type ID.\n\nParameters:​\nName\tType\tDescription\nthis\tAElf.Kernel.SmartContract.ISmartContractBridgeContext\tAn instance of ISmartContractBridgeContext.\naddress\tAElf.Types.Address\tThe address for ID generation.\ntoken\tAElf.Types.Hash\tThe hash type token for ID generation.\nSendInline(context, toAddress, methodName, message) method​\n\nSends an inline transaction to another contract.\n\nParameters:​\nName\tType\tDescription\ncontext\tAElf.Kernel.SmartContract.ISmartContractBridgeContext\tAn instance of ISmartContractBridgeContext.\ntoAddress\tAElf.Types.Address\tThe contract address to interact with.\nmethodName\tSystem.String\tThe name of the method to call.\nmessage\tGoogle.Protobuf.ByteString\tThe input arguments for the method.\nSendInline(context, toAddress, methodName, message) method​\n\nSends a virtual inline transaction to another contract.\n\nParameters:​\nName\tType\tDescription\ncontext\tAElf.Kernel.SmartContract.ISmartContractBridgeContext\tAn instance of ISmartContractBridgeContext.\ntoAddress\tAElf.Types.Address\tThe contract address to interact with.\nmethodName\tSystem.String\tThe name of the method to call.\nmessage\tGoogle.Protobuf.ByteString\tThe input arguments for the method.\nSendVirtualInline(context, fromVirtualAddress, toAddress, methodName, message) method​\n\nSends a virtual inline transaction to another contract.\n\nParameters:​\nName\tType\tDescription\ncontext\tAElf.Kernel.SmartContract.ISmartContractBridgeContext\tAn instance of ISmartContractBridgeContext.\nfromVirtualAddress\tAElf.Types.Hash\tThe virtual address to use as sender.\ntoAddress\tAElf.Types.Address\tThe contract address to interact with.\nmethodName\tSystem.String\tThe name of the method to call.\nmessage\tGoogle.Protobuf.ByteString\tThe input arguments for the method.\nSmartContractConstants type​\n\nNamespace: AElf.Sdk.CSharp\n\nStatic class containing the hashes built from contract names.\n\nStringState type​\n\nNamespace: AElf.Sdk.CSharp.State\n\nWrapper around string values for use in smart contract state.\n\nUInt32State type​\n\nNamespace: AElf.Sdk.CSharp.State\n\nWrapper around unsigned 32-bit integer values for use in smart contract state.\n\nUInt64State type​\n\nNamespace: AElf.Sdk.CSharp.State\n\nWrapper around unsigned 64-bit integer values for use in smart contract state.\n\nPrevious\nContract SDK\nNext\naelf C# Core\nBoolState type\nBytesState type\nCSharpSmartContractContext type\nChainId property\nCurrentBlockTime property\nCurrentHeight property\nOrigin property\nPreviousBlockHash property\nSelf property\nSender property\nStateProvider property\nTransactionId property\nVariables property\nTransaction property\nCall(fromAddress, toAddress, methodName, args) method\nConvertHashToInt64(hash, start, end) method\nReturns\nParameters\nExceptions\nConvertVirtualAddressToContractAddress(virtualAddress) method\nReturns\nParameters\nConvertVirtualAddressToContractAddress(virtualAddress, contractAddress) method\nReturns\nParameters\nConvertVirtualAddressToContractAddressWithContractHashName(virtualAddress) method\nReturns\nParameters\nConvertVirtualAddressToContractAddressWithContractHashName(virtualAddress, contractAddress) method\nReturns\nParameters\nDeployContract(address, registration, name) method\nParameters\nFireLogEvent(logEvent) method\nParameters\nGenerateId(contractAddress, bytes) method\nReturns\nParameters\nGetContractAddressByName(hash) method\nReturns\nParameters\nGetPreviousBlockTransactions() method\nReturns\nGetRandomHash(fromHash) method\nReturns\nParameters\nGetSystemContractNameToAddressMapping() method\nReturns\nGetZeroSmartContractAddress() method\nReturns\nGetZeroSmartContractAddress(chainId) method\nReturns\nParameters\nLogDebug(func) method\nParameters\nRecoverPublicKey() method\nReturns\nSendInline(toAddress, methodName, args) method\nParameters\nSendVirtualInline(fromVirtualAddress, toAddress, methodName, args) method\nParameters\nSendVirtualInline(fromVirtualAddress, toAddress, methodName, args, logTransaction) method\nParameters\nSendVirtualInlineBySystemContract(fromVirtualAddress, toAddress, methodName, args) method\nParameters\nSendVirtualInlineBySystemContract(fromVirtualAddress, toAddress, methodName, args, logTransaction) method\nParameters\nUpdateContract(address, registration, name) method\nParameters\nValidateStateSize(obj) method\nReturns\nParameters\nExceptions\nVerifySignature(tx) method\nReturns\nParameters\nCheckContractVersion(previousContractVersion, registration) method\nReturns\nParameters\nDeploySmartContract(address, registration, name) method\nReturns\nParameters\nUpdateSmartContract(address, registration, name, previousContractVersion) method\nReturns\nParameters\nECVrfVerify(pubKey, alpha, pi, beta) method\nReturns\nParameters\nCSharpSmartContract type\nGeneric Types\nContext property\nState property\nContractState type\nInt32State type\nInt64State type\nMappedState type\nGeneric Types\nSingletonState type\nSmartContractBridgeContextExtensions type\nCall(context, address, methodName, message) method\nReturns:\nParameters:\nGeneric Types:\nCall(context, address, methodName, message) method\nReturns:\nParameters:\nGeneric Types:\nCall(context, fromAddress, toAddress, methodName, message) method\nReturns:\nParameters:\nGeneric Types:\nConvertToByteString(message) method\nReturns:\nParameters:\nConvertVirtualAddressToContractAddress(this, virtualAddress) method\nParameters\nConvertVirtualAddressToContractAddressWithContractHashName(this, virtualAddress) method\nParameters:\nFire(context, eventData) method\nParameters:\nGeneric Types:\nGenerateId(this, bytes) method\nReturns: The generated hash type ID.\nParameters:\nGenerateId(this, token) method\nReturns:\nParameters:\nGenerateId(this, token) method\nReturns: The generated hash type ID.\nParameters:\nGenerateId(this) method\nReturns: The generated hash type ID.\nParameters:\nGenerateId(this, address, token) method\nReturns:\nParameters:\nSendInline(context, toAddress, methodName, message) method\nParameters:\nSendInline(context, toAddress, methodName, message) method\nParameters:\nSendVirtualInline(context, fromVirtualAddress, toAddress, methodName, message) method\nParameters:\nSmartContractConstants type\nStringState type\nUInt32State type\nUInt64State type\nPlatform\nTechnology\nAudit Report\nPrivacy\nTerms of Use\nCookie Policy\nDeveloper Resources\nQuick Start\nLearn\nDocs\nTools\nResources\nEcosystem\nOverview\ndApps\naelf Ventures\nBlog\nConnect\nContact Us\nCopyright © 2024 aelf"
    },
    {
      "title": "AELF Docs",
      "url": "https://docs.aelf.com/tools/smart-contract-templates/deploying-contracts-without-bp-approval/",
      "html": "Skip to main content\nQuick Start\nLearn\nDocs\nTools\nResources\nBlog\nSearch\nTools\nChain SDK\naelf Deploy Tool\naelf CLI\nSmart Contract\nSmart Contracts Overview\nDevelopment Environment\nDeveloping Smart Contracts\nDeploying Contract with BP Approval\nDeploying Contract without BP Approval\naelf Testnet Faucet\naelf Design\naelf Playground\nContract SDK\nToolsSmart ContractDeploying Contract without BP Approval\nDeploying Contracts without BP Approval\n\nContracts can be deployed/updated via aelf explorer or aelf-command. Ensure npm and aelf-command are installed before starting. Follow the Deployment Environment guide if needed.\n\nOverview​\n\nIn these 6 cases, BP approval is not needed for contract deployment/updates:\n\nDeploying user contracts on shared SideChains (initiated by users or BPs).\nUpdating user contracts on shared SideChains (initiated by contract creators).\nDeploying user contracts on exclusive SideChains (initiated by SideChain creators).\nUpdating user contracts on exclusive SideChains (initiated by contract creators).\nDeploying user contracts on MainChain (initiated by BPs, recommended on SideChains).\nUpdating user contracts on MainChain (initiated by contract creators).\n\nUser contracts are non-system contracts. Contracts must implement ACS12 standards. No BP approval is needed; developers initiate 1 transaction to deploy/update contracts.\n\nContracts Deployment/Update Procedure​\nDeveloper: DeployUserSmartContract / UpdateUserSmartContract​\n\nContract Deployment\n\nDeveloper initiates DeployUserSmartContract.\nA CodeCheck proposal is created for BP code review.\nTransaction returns CodeHash of the contract deployment.\n\nContract Update\n\nDeveloper initiates UpdateUserSmartContract.\nA CodeCheck proposal is created for BP code review.\nBP: Parliament.ApproveMultiProposals (Automatic)​\n\nBPs automatically complete the code check. If it passes, an ApproveMultiProposals transaction is initiated, approving the CodeCheck proposal.\n\nBP: ReleaseApprovedUserSmartContract (Automatic)​\n\nOnce 2/3 (rounding down) + 1 BPs approve the code check, they release the CodeCheck proposal by initiating the ReleaseApprovedUserSmartContract transaction, completing the deployment/update.\n\nIf the code check fails, the process stops.\n\nDeveloper: GetSmartContractRegistrationByCodeHash​\n\nTo get the deployed/updated contract address:\n\nUse the CodeHash from DeployUserSmartContract/UpdateUserSmartContract to check the address via GetSmartContractRegistrationByCodeHash.\n\nThe result is available after at least one round of block production.\n\nIf there are errors, the transaction will fail, and error info can be obtained from the transaction results. If the address is not available after 10 minutes, check:\n\nIf the contract implements ACS12 standards.\nIf the contract development scaffold is the latest version.\nPrevious\nDeploying Contract with BP Approval\nNext\naelf Testnet Faucet\nOverview\nContracts Deployment/Update Procedure\nDeveloper: DeployUserSmartContract / UpdateUserSmartContract\nBP: Parliament.ApproveMultiProposals (Automatic)\nBP: ReleaseApprovedUserSmartContract (Automatic)\nDeveloper: GetSmartContractRegistrationByCodeHash\nPlatform\nTechnology\nAudit Report\nPrivacy\nTerms of Use\nCookie Policy\nDeveloper Resources\nQuick Start\nLearn\nDocs\nTools\nResources\nEcosystem\nOverview\ndApps\naelf Ventures\nBlog\nConnect\nContact Us\nCopyright © 2024 aelf"
    },
    {
      "title": "AELF Docs",
      "url": "https://docs.aelf.com/tools/smart-contract-templates/deploying-contracts-with-bp-approval/",
      "html": "Skip to main content\nQuick Start\nLearn\nDocs\nTools\nResources\nBlog\nSearch\nTools\nChain SDK\naelf Deploy Tool\naelf CLI\nSmart Contract\nSmart Contracts Overview\nDevelopment Environment\nDeveloping Smart Contracts\nDeploying Contract with BP Approval\nDeploying Contract without BP Approval\naelf Testnet Faucet\naelf Design\naelf Playground\nContract SDK\nToolsSmart ContractDeploying Contract with BP Approval\nDeploying Contract with BP Approval\n\nContracts can be deployed or updated via two methods: aelf explorer or aelf-command. Ensure npm and aelf-command are installed before starting. Follow the Deployment Environment guide if needed.\n\nOverview​\n\nIn these cases, BP approval is needed for contract updates:\n\nUpgrading system contracts on MainChain.\nUpgrading system contracts on exclusive SideChains.\nUpgrading system contracts on shared SideChains.\n\nSystem contracts can only be deployed in the Genesis block. After launch, only updates are supported. This guide focuses on contract deployment on aelf Mainnet with ContractDeploymentAuthorityRequired set to true.\n\nDeploy / Update through aelf Explorer​\n\nTo deploy/update contracts on AElf Mainnet with ContractDeploymentAuthorityRequired true, create an AElf wallet and have around 100 ELF. When ContractDeploymentAuthorityRequired is false, use DeploySmartContract and UpdateSmartContract in Contract Zero.\n\nLearn how to deploy contracts through aelf Explorer\n\nDeploy / Update through aelf-command​\n\nContracts Deployment/Update Procedure​\nDeveloper: ProposeNewContract / ProposeUpdateContract​\n\nContract Deployment\n\nDeveloper initiates ProposeNewContract.\nA ProposeContractCodeCheck proposal is created for BP code review.\nIf 2/3 (rounding down) + 1 BPs approve, the developer releases the approved proposal, triggering an automatic CodeCheck proposal. If denied, deployment stops.\n\nContract Update\n\nDeveloper initiates ProposeUpdateContract.\nA ProposeContractCodeCheck proposal is created for BP code review.\nIf 2/3 (rounding down) + 1 BPs approve, the developer releases the approved proposal, triggering an automatic CodeCheck proposal. If denied, the update stops.\nBP: Parliament.Approve​\n\nBPs approve the ProposeContractCodeCheck proposal:\n\n2/3 (rounding down) + 1 votes in favor.\nNo more than 10% votes against.\nNo more than 10% abstentions.\nAt least 80% BP participation.\nDeveloper: ReleaseApprovedContract​\n\nIf 2/3 (rounding down) + 1 BPs approve, the developer initiates ReleaseApprovedContract to release the proposal, creating a CodeCheck proposal for automatic code check.\n\nBP: Parliament.ApproveMultiProposals (Automatic)​\n\nBPs complete the code check. If it passes, an ApproveMultiProposals transaction is initiated automatically, approving the CodeCheck proposal. If it fails, the process stops.\n\nDeveloper: ReleaseCodeCheckedContract​\n\nThe developer initiates ReleaseCodeCheckedContract to release the CodeCheck proposal. The DeploySmartContract or UpdateSmartContract method is executed, completing the deployment/update.\n\nPrevious\nDeveloping Smart Contracts\nNext\nDeploying Contract without BP Approval\nOverview\nDeploy / Update through aelf Explorer\nDeploy / Update through aelf-command\nContracts Deployment/Update Procedure\nPlatform\nTechnology\nAudit Report\nPrivacy\nTerms of Use\nCookie Policy\nDeveloper Resources\nQuick Start\nLearn\nDocs\nTools\nResources\nEcosystem\nOverview\ndApps\naelf Ventures\nBlog\nConnect\nContact Us\nCopyright © 2024 aelf"
    },
    {
      "title": "Developing Smart Contracts | AELF Docs",
      "url": "https://docs.aelf.com/tools/smart-contract-templates/developing-smart-contracts/",
      "html": "Skip to main content\nQuick Start\nLearn\nDocs\nTools\nResources\nBlog\nSearch\nTools\nChain SDK\naelf Deploy Tool\naelf CLI\nSmart Contract\nSmart Contracts Overview\nDevelopment Environment\nDeveloping Smart Contracts\nDeploying Contract with BP Approval\nDeploying Contract without BP Approval\naelf Testnet Faucet\naelf Design\naelf Playground\nContract SDK\nToolsSmart ContractDeveloping Smart Contracts\nDeveloping Smart Contracts\n\nThis guide shows how to develop a smart contract using the GreeterContract as an example. You’ll learn to create your own basic contract.\n\nSteps for Developing Smart Contracts​\nInstall template: Install the aelf smart contract templates using the dotnet command.\nInitialize project: Create the project structure and base contract code.\nDefine the contract: Use a protobuf file to define methods and types.\nImplement contract code: Write the logic for the contract methods.\nTest smart contracts: Create unit tests for the contracts.\n\nThe Greeter contract includes an AddGreeters method to add a new greeter and a GetGreeters method to list all greeters.\n\nInstall Template​\nTo install the template, run:\ndotnet new --install AElf.ContractTemplates\n\nVerify installation with:\ndotnet new uninstall\n\nInitialize Project​\nCreate a project named GreeterContract with:\ndotnet new aelf -n GreeterContract -N AElf.Contracts.Greeter\n\n\nThis generates the following structure:\n\n.\n├── src\n│   ├── GreeterContract.cs\n│   ├── GreeterContract.csproj\n│   ├── GreeterContractState.cs\n│   └── Protobuf\n│       ├── contract\n│       │   └── hello_world_contract.proto\n│       └── message\n│           └── authority_info.proto\n└── test\n    ├── GreeterContract.Tests.csproj\n    ├── GreeterContractTests.cs\n    ├── Protobuf\n    │   ├── message\n    │   │   └── authority_info.proto\n    │   └── stub\n    │       └── hello_world_contract.proto\n    └── _Setup.cs\n\nDefine the Contract Create a greeter_contract.proto file to define the contract:\nsyntax = \"proto3\";\n\nimport \"aelf/options.proto\";\nimport \"google/protobuf/empty.proto\";\nimport \"google/protobuf/wrappers.proto\";\noption csharp_namespace = \"AElf.Contracts.Greeter\";\n\nservice GreeterContract {\n  option (aelf.csharp_state) = \"AElf.Contracts.Greeter.GreeterContractState\";\n\n  rpc AddGreeters (google.protobuf.StringValue) returns (google.protobuf.Empty) {}\n  rpc GetGreeters (google.protobuf.Empty) returns (GreeterList) {\n    option (aelf.is_view) = true;\n  }\n}\n\nmessage GreeterList {\n  repeated string greeter = 1;\n}\n\nImplement Contract Code Run dotnet build in the src folder to compile the proto files. Implement the contract logic in GreeterContract.cs:\nusing AElf.Sdk.CSharp;\nusing Google.Protobuf.WellKnownTypes;\n\nnamespace AElf.Contracts.Greeter\n{\n    public class GreeterContract : GreeterContractContainer.GreeterContractBase\n    {\n        public override Empty AddGreeters(StringValue input)\n        {\n            Assert(!string.IsNullOrWhiteSpace(input.Value), \"Invalid name.\");\n\n            var greeterList = State.GreeterList.Value ?? new GreeterList();\n            if (!greeterList.Greeter.Contains(input.Value))\n            {\n                greeterList.Greeter.Add(input.Value);\n            }\n            State.GreeterList.Value = greeterList;\n\n            return new Empty();\n        }\n\n        public override GreeterList GetGreeters(Empty input)\n        {\n            return State.GreeterList.Value ?? new GreeterList();\n        }\n    }\n}\n\nDefine the contract state in GreeterContractState.cs:\nusing AElf.Sdk.CSharp.State;\n\nnamespace AElf.Contracts.Greeter\n{\n    public class GreeterContractState : ContractState\n    {\n        public SingletonState<GreeterList> GreeterList { get; set; }\n    }\n}\n\n\nTest Smart Contracts Use the AElf.ContractTestKit for testing. The test folder contains the necessary files for unit testing.\n\nSetup the testing context in _Setup.cs:\n\nusing AElf.Cryptography.ECDSA;\nusing AElf.Testing.TestBase;\n\nnamespace AElf.Contracts.Greeter\n{\n    public class Module : ContractTestModule<GreeterContract> { }\n\n    public class TestBase : ContractTestBase<Module>\n    {\n        internal readonly GreeterContractContainer.GreeterContractStub GreeterContractStub;\n        private ECKeyPair DefaultKeyPair => Accounts[0].KeyPair;\n\n        public TestBase()\n        {\n            GreeterContractStub = GetGreeterContractContractStub(DefaultKeyPair);\n        }\n\n        private GreeterContractContainer.GreeterContractStub GetGreeterContractContractStub(ECKeyPair senderKeyPair)\n        {\n            return GetTester<GreeterContractContainer.GreeterContractStub>(ContractAddress, senderKeyPair);\n        }\n    }\n}\n\nWrite unit tests in GreeterContractTests.cs:\nusing System.Threading.Tasks;\nusing Google.Protobuf.WellKnownTypes;\nusing Shouldly;\nusing Xunit;\n\nnamespace AElf.Contracts.Greeter\n{\n    public class GreeterContractTests : TestBase\n    {\n        [Fact]\n        public async Task AddGreetersTest()\n        {\n            var user1 = new StringValue { Value = \"Tom\" };\n            var user2 = new StringValue { Value = \"Jerry\" };\n            var expectList = new GreeterList();\n            expectList.Greeter.Add(user1.Value);\n            expectList.Greeter.Add(user2.Value);\n\n            await GreeterContractStub.AddGreeters.SendAsync(user1);\n            await GreeterContractStub.AddGreeters.SendAsync(user2);\n\n            var greeterList = await GreeterContractStub.GetGreeters.CallAsync(new Empty());\n            greeterList.ShouldBe(expectList);\n        }\n    }\n}\n\nPrevious\nDevelopment Environment\nNext\nDeploying Contract with BP Approval\nSteps for Developing Smart Contracts\nInstall Template\nInitialize Project\nPlatform\nTechnology\nAudit Report\nPrivacy\nTerms of Use\nCookie Policy\nDeveloper Resources\nQuick Start\nLearn\nDocs\nTools\nResources\nEcosystem\nOverview\ndApps\naelf Ventures\nBlog\nConnect\nContact Us\nCopyright © 2024 aelf"
    },
    {
      "title": "Development Environment | AELF Docs",
      "url": "https://docs.aelf.com/tools/smart-contract-templates/development-environment/",
      "html": "Skip to main content\nQuick Start\nLearn\nDocs\nTools\nResources\nBlog\nSearch\nTools\nChain SDK\naelf Deploy Tool\naelf CLI\nSmart Contract\nSmart Contracts Overview\nDevelopment Environment\nDeveloping Smart Contracts\nDeploying Contract with BP Approval\nDeploying Contract without BP Approval\naelf Testnet Faucet\naelf Design\naelf Playground\nContract SDK\nToolsSmart ContractDevelopment Environment\nDevelopment Environment\nDevelopment Environment​\nBefore You Start​\n\nTo develop smart contracts, you need to install the .NET SDK. Other tools for starting aelf nodes and publishing contracts are optional.\n\nmacOS Setup​\n\nRequirements:\n\nmacOS 10.7 or higher\n2GHz processor (3GHz recommended)\n8 GB RAM (16 GB recommended)\n10 GB free space\nBroadband internet\n\nApple M1 Support: Install Rosetta:\n\n/usr/sbin/softwareupdate --install-rosetta --agree-to-license\n\n\nInstall Homebrew:\n\n/bin/bash -c \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)\"\nbrew --version\nbrew update\n\n\nInstall Git:\n\nbrew install git\ngit --version\n\n\nInstall .NET SDK:\n\nbrew install --cask dotnet-sdk\ndotnet --version\n\n\nInstall protoBuf:\n\nbrew install protobuf\nprotoc --version\n\n\nInstall Redis:\n\nbrew install redis\nredis-server\n\n\nInstall Node.js:\n\nbrew install node\nnpm --version\n\n\nInstall aelf-command:\n\nnpm i aelf-command -g\n\n\nCreate an aelf Account:\n\naelf-command create\n\n\nSimilar Output:\n\nAElf [Info]: Your wallet info is :\nAElf [Info]: Mnemonic            : mirror among battle muffin cattle plunge tuition buzz hip mad surround recall\nAElf [Info]: Private Key         : 4bf625afea60e21aa5afcab5ea682b3dfb614941245698632d72a09ae13*****\nAElf [Info]: Public Key          : 04f9bb56a9eca921bd494e677307f0279c98f1d2ed6bdeaa6dd256878272eabd14e91ec61469d2a32ce5e63205930dabdc0b9f13fc80c1f4e31760618d182*****\nAElf [Info]: Address             : 21qciGwcaowwBttKMjMk86AW6WajhcodSHytY1vCyZb7p*****\n\nLinux Setup​\n\nRequirements:\n\nUbuntu 18.04\nBroadband internet\n\nUpdate Environment:\n\nsudo apt-get update\n\n\nInstall Git:\n\nsudo apt-get install git -y\ngit --version\n\n\nInstall .NET SDK:\n\nwget https://packages.microsoft.com/config/ubuntu/22.04/packages-microsoft-prod.deb -O packages-microsoft-prod.deb\nsudo dpkg -i packages-microsoft-prod.deb\nsudo apt-get update\nsudo apt-get install -y dotnet-sdk-6.0\ndotnet --version\n\n\nInstall protoBuf:\n\ncurl -OL https://github.com/google/protobuf/releases/download/v21.9/protoc-21.9-linux-x86_64.zip\nunzip protoc-21.9-linux-x86_64.zip -d protoc3\nsudo mv protoc3/bin/* /usr/local/bin/\nsudo mv protoc3/include/* /usr/local/include/\nprotoc --version\n\n\nInstall Redis:\n\nsudo apt-get install redis -y\nredis-server\n\n\nInstall Node.js:\n\ncurl -fsSL https://deb.nodesource.com/setup_14.x | sudo -E bash -\nsudo apt-get install -y nodejs\nnpm --version\n\n\nInstall aelf-command:\n\nnpm i aelf-command -g\n\n\nCreate an aelf Account:\n\naelf-command create\n\nWindows Setup​\n\nRequirements:\n\nWindows 10 or higher\nBroadband internet\n\nInstall Chocolatey:\n\nSet-ExecutionPolicy Bypass -Scope Process -Force; [System.Net.ServicePointManager]::SecurityProtocol = [System.Net.ServicePointManager]::SecurityProtocol -bor 3072; iex ((New-Object System.Net.WebClient).DownloadString('https://chocolatey.org/install.ps1'))\nchoco\n\n\nInstall Git:\n\nchoco install git -y\ngit --version\n\n\nInstall .NET SDK:\n\nchoco install dotnetcore-sdk -y\ndotnet --version\n\n\nInstall protoBuf:\n\nchoco install protoc -y\nprotoc --version\n\n\nInstall Redis:\n\nchoco install redis-64 -y\nredis-server\n\n\nInstall Node.js:\n\nchoco install nodejs -y\nnpm --version\n\n\nInstall aelf-command:\n\nnpm i aelf-command -g\n\n\nCreate an aelf Account:\n\naelf-command create\n\nCodespaces Setup​\n\nOpen Codespaces: \n\nVisit the aelfProject repo.\n\nClick \"Code\" > \"Codespaces\" > \"+\" to create a new codespace. \n\nCheck Installed Versions:\n\ngit --version\nnpm --version\n\n\nUpdate Environment:\n\nsudo apt-get update\n\n\nInstall .NET SDK:\n\nwget https://packages.microsoft.com/config/ubuntu/22.04/packages-microsoft-prod.deb -O packages-microsoft-prod.deb\nsudo dpkg -i packages-microsoft-prod.deb\nsudo apt-get update\nsudo apt-get install -y dotnet-sdk-6.0\ndotnet --version\n\n\nInstall protoBuf:\n\ncurl -OL https://github.com/google/protobuf/releases/download/v21.9/protoc-21.9-linux-x86_64.zip\nunzip protoc-21.9-linux-x86_64.zip -d protoc3\nsudo mv protoc3/bin/* /usr/local/bin/\nsudo mv protoc3/include/* /usr/local/include/\nprotoc --version\n\n\nInstall Redis:\n\nsudo apt-get install redis -y\nredis-server\n\n\nInstall aelf-command:\n\nnpm i aelf-command -g\n\n\nCreate an aelf Account:\n\naelf-command create\n\nPrevious\nSmart Contracts Overview\nNext\nDeveloping Smart Contracts\nDevelopment Environment\nBefore You Start\nmacOS Setup\nLinux Setup\nWindows Setup\nCodespaces Setup\nPlatform\nTechnology\nAudit Report\nPrivacy\nTerms of Use\nCookie Policy\nDeveloper Resources\nQuick Start\nLearn\nDocs\nTools\nResources\nEcosystem\nOverview\ndApps\naelf Ventures\nBlog\nConnect\nContact Us\nCopyright © 2024 aelf"
    },
    {
      "title": "AELF Docs",
      "url": "https://docs.aelf.com/tools/aelf-cli/commands/",
      "html": "Skip to main content\nQuick Start\nLearn\nDocs\nTools\nResources\nBlog\nSearch\nTools\nChain SDK\naelf Deploy Tool\naelf CLI\nIntroduction to CLI\nCommands\nSmart Contract\naelf Testnet Faucet\naelf Design\naelf Playground\nContract SDK\nToolsaelf CLICommands\nCommands Overview\nCommon Options​\n\ndatadir: Directory containing aelf-command files, including encrypted account info keyStore files. Default: {home}/.local/share/aelf\n\nendpoint: The RPC service endpoint.\n\naccount: The account used to interact with the blockchain endpoint.\n\npassword: The password to unlock the given account.\n\nYou can set these options in several ways, in order of priority from low to high:\n\nEnvironment Variables\n\n# Set datadir\n$ export AELF_CLI_DATADIR=/Users/{you}/.local/share/aelf\n\n# Set endpoint\n$ export AELF_CLI_ENDPOINT=http://127.0.0.1:8000\n\n# Set account\n$ export AELF_CLI_ACCOUNT=2Ue31YTuB5Szy7c...gtGi5uMQBYarYUR5oGin1sys6H\n\n\nGlobal Config File\n\nThe global config file is located in <datadir>/.aelfrc. Avoid modifying this file manually.\nUse the aelf-command config to modify the global config file.\nConfig Command​\n\nset: Save configuration in the global .aelfrc file.\n\n$ aelf-command config set endpoint http://127.0.0.1:8000\n✔ Succeed!\n\n\nget: Retrieve a value from the global .aelfrc file.\n\n$ aelf-command config get endpoint\nhttp://127.0.0.1:8000\n\n\ndelete: Remove a key-value pair from the global .aelfrc file.\n\n$ aelf-command config delete endpoint\n✔ Succeed!\n\n\nlist: List all configurations stored in the global .aelfrc file.\n\n$ aelf-command config list\nendpoint=http://127.0.0.1:8000\npassword=password\n\n\nUsage:\n\n$ aelf-command config -h\nUsage: aelf-command config [options] <flag> [key] [value]\n\nOptions:\n  -h, --help  output usage information\n  \nExamples:\n\naelf-command config get <key>\naelf-command config set <key> <value>\naelf-command config delete <key>\naelf-command config list\n\nWorking Directory Config File​\n\nThe current working directory can also have a .aelfrc file. The format is the same as the global .aelfrc file:\n\nendpoint http://127.0.0.1:8000\npassword yourpassword\n\n\nEach line contains a <key, value> pair separated by a whitespace.\n\nCLI Parameters​\n\nYou can pass common options directly as CLI parameters:\n\n$ aelf-command console -a sadaf -p password -e http://127.0.0.1:8000\n\n\nOptions given in higher priority (e.g., CLI parameters) will overwrite those with lower priority (e.g., environment variables).\n\nCreate a New Account​\n\nUse the create command to create a new account.\n\n$ aelf-command create -h\nUsage: aelf-command create [options] [save-to-file]\n\nOptions:\n  -c, --cipher [cipher]  Cipher algorithm to use (default: aes-128-ctr)\n  -h, --help             Output usage information\n\n\nExamples:\n\n$ aelf-command create\n$ aelf-command create <save-to-file>\n$ aelf-command create -c aes-128-cbc\n\n\nBy following this guide, you should be able to easily set up and use aelf for your Web3 applications. For more detailed information, please refer to the full aelf documentation.\n\nLoad - Load an Account by a Given Private Key or Mnemonic​\n\nThis command allows you to load an account from a backup.\n\nLoad from Mnemonic​\n$ aelf-command load 'great mushroom loan crisp ... door juice embrace'\n\nLoad from Private Key​\n$ aelf-command load 'e038eea7e151eb451ba2901f7...b08ba5b76d8f288'\n\nLoad from Prompting​\n$ aelf-command load\n? Enter a private key or mnemonic › e038eea7e151eb451ba2901f7...b08ba5b76d8f288\n\nWallet - Show Wallet Details​\n\nThis command allows you to print wallet information, including the private key, address, public key, and mnemonic.\n\n$ aelf-command wallet -a C91b1SF5mMbenHZTfdfbJSkJcK7HMjeiuw...8qYjGsESanXR\nAElf [Info]: \nPrivate Key         : 97ca9fbece296231f26bee0e493500810f...cbd984f69a8dc22ec9ec89ebb00\nPublic Key          : 04c30dd0c3b5abfc85a11b15dabd0de926...74fe04e92eaebf2e4fef6445d9b9b11efe6f4b70c8e86644b72621f9987dc00bb1eab44a9bd7512ea53f93937a5d0\nAddress             : C91b1SF5mMbenHZTfdfbJSkJcK7HMjeiuw...8qYjGsESanXR\n\nProposal - Create a Proposal​\n\nThere are three types of proposal contracts in aelf:\n\nAElf.ContractNames.Parliament\nAElf.ContractNames.Referendum\nAElf.ContractNames.Association\n\nDepending on your needs, you can choose one and create a proposal.\n\nGet an Organization Address or Create One​\n\nGet the Default Organization's Address with the Parliament Contract\n\n$ aelf-command call AElf.ContractNames.Parliament GetDefaultOrganizationAddress\n✔ Fetching contract successfully!\n✔ Calling method successfully!\nAElf [Info]:\nResult:\n\"BkcXRkykRC2etHp9hgFfbw2ec1edx7ERBxYtbC97z3Q2bNCwc\"\n✔ Succeed!\n\n\nBkcXRkykRC2etHp9hgFfbw2ec1edx7ERBxYtbC97z3Q2bNCwc is the default organization address.\n\nThe default organization includes all miners; every proposal under AElf.ContractNames.Parliament requires over 2/3 miner approval to be released.\n\nCreate an Organization with the Referendum Contract\n\n$ aelf-command send AElf.ContractNames.Referendum\n✔ Fetching contract successfully!\n? Pick up a contract method: CreateOrganization\n\nIf you need to pass file contents as a parameter, you can enter the relative or absolute path of the file.\n\nEnter the params one by one, type `Enter` to skip optional parameters:\n? Enter the required param <tokenSymbol>: ELF\n? Enter the required param <proposalReleaseThreshold.minimalApprovalThreshold>: 666\n? Enter the required param <proposalReleaseThreshold.maximalRejectionThreshold>: 666\n? Enter the required param <proposalReleaseThreshold.maximalAbstentionThreshold>: 666\n? Enter the required param <proposalReleaseThreshold.minimalVoteThreshold>: 666\n? Enter the required param <proposerWhiteList.proposers>: [\"2hxkDg6Pd2d4yU1A16PTZVMMrEDYEPR8oQojMDwWdax5LsBaxX\"]\nThe params you entered is:\n{\n  \"tokenSymbol\": \"ELF\",\n  \"proposalReleaseThreshold\": {\n    \"minimalApprovalThreshold\": 666,\n    \"maximalRejectionThreshold\": 666,\n    \"maximalAbstentionThreshold\": 666,\n    \"minimalVoteThreshold\": 666\n  },\n  \"proposerWhiteList\": {\n    \"proposers\": [\n      \"2hxkDg6Pd2d4yU1A16PTZVMMrEDYEPR8oQojMDwWdax5LsBaxX\"\n    ]\n  }\n}\n✔ Succeed!\nAElf [Info]:\nResult:\n{\n  \"TransactionId\": \"273285c7e8825a0af5291dd5d9295f746f2bb079b30f915422564de7a64fc874\"\n}\n✔ Succeed!\n\nCreate a Proposal​\n$ aelf-command proposal\n? Pick up a contract name to create a proposal: AElf.ContractNames.Parliament\n? Enter an organization address: BkcXRkykRC2etHp9hgFfbw2ec1edx7ERBxYtbC97z3Q2bNCwc\n? Select the expired time for this proposal: 2022/09/23 22:06\n? Optional, input a URL for proposal description:\n? Enter a contract address or name: AElf.ContractNames.Token\n✔ Fetching contract successfully!\n? Pick up a contract method: Transfer\n\nIf you need to pass file contents to the contract method, you can enter the relative or absolute path of the file instead.\n\nEnter required params one by one:\n? Enter the required param <to>: 2hxkDg6Pd2d4yU1A16PTZVMMrEDYEPR8oQojMDwWdax5LsBaxX\n? Enter the required param <symbol>: ELF\n? Enter the required param <amount>: 100000000\n? Enter the required param <memo>: test\nAElf [Info]:\n { TransactionId:\n   '09c8c824d2e3aea1d6cd15b7bb6cefe4e236c5b818d6a01d4f7ca0b60fe99535' }\n✔ loading proposal id...\nAElf [Info]: Proposal id: \"bafe83ca4ec5b2a2f1e8016d09b21362c9345954a014379375f1a90b7afb43fb\".\n✔ Succeed!\n\n\nYou can get the proposal id, then get the proposal’s status.\n\nGet Proposal Status​\n$ aelf-command call AElf.ContractNames.Parliament GetProposal bafe83ca4ec5b2a2f1e8016d09b21362c9345954a014379375f1a90b7afb43fb\n{\n  ...\n  \"expiredTime\": {\n    \"seconds\": \"1663942010\",\n    \"nanos\": 496000\n  },\n  \"organizationAddress\": \"BkcXRkykRC2etHp9hgFfbw2ec1edx7ERBxYtbC97z3Q2bNCwc\",\n  \"proposer\": \"2tj7Ea67fuQfVAtQZ3WBmTv7AAJ8S9D2L4g6PpRRJei6JXk7RG\",\n  \"toBeReleased\": false\n}\n✔ Succeed!\n\n\ntoBeReleased indicates whether you can release this proposal. By default, a proposal needs over 2/3 BP nodes' approval.\n\nRelease a Proposal​\n\nYou can release a proposal when it gets approved.\n\n$ aelf-command send AElf.ContractNames.Parliament Release bafe83ca4ec5b2a2f1e8016d09b21362c9345954a014379375f1a90b7afb43fb\nAElf [Info]:\n { TransactionId:\n   '09c8c824d2e3aea1d...cefe4e236c5b818d6a01d4f7ca0b60fe99535' }\n\nGet the Transaction Result​\n\nUse the get-tx-result command to retrieve the details of the transaction:\n\n$ aelf-command get-tx-result 09c8c824d2e3aea1d...cefe4e236c5b818d6a01d4f7ca0b60fe99535\nAElf [Info]: {\n  \"TransactionId\": \"09c8c824d2e3aea1d...cefe4e236c5b818d6a01d4f7ca0b60fe99535\",\n  \"Status\": \"MINED\",\n  \"Logs\": [\n    {\n    \"Address\": \"25CecrU94dmMdbhC3LWMKxtoaL4Wv8PChGvVJM6PxkHAyvXEhB\",\n    \"Name\": \"Transferred\",\n    \"Indexed\": [\n      \"CiIKIJTPGZ24g4eHwSVNLit8jgjFJeeYCEEYLDpFiCeCT0Bf\",\n      \"EiIKIO0jJRxjHdRQmUTby8klRVSqYpwhOyUsnXYV3IrQg8N1\",\n      \"GgNFTEY=\"\n    ],\n    \"NonIndexed\": \"IICgt4fpBSomVC00MzFkMjc0Yi0zNWJjLTRjYzgtOGExZC1iODhhZTgxYzU2Zjc=\"\n    }\n  ],\n  \"Bloom\": \"AAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACAAAAAAAAAAAAAAAACAAAAAAAAAAACAAAAAAAAAAAgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAIAAAAAQAAA==\",\n  \"BlockNumber\": 28411,\n  \"BlockHash\": \"fa22e4eddff12a728895a608db99d40a4b21894f7c07df1a4fa8f0625eb914a2\",\n  \"Transaction\": {\n    \"From\": \"2tj7Ea67fuQfVAtQZ3WBmTv7AAJ8S9D2L4g6PpRRJei6JXk7RG\",\n    \"To\": \"29RDBXTqwnpWPSPHGatYsQXW2E17YrQUCj7QhcEZDnhPb6ThHW\",\n    \"RefBlockNumber\": 28410,\n    \"RefBlockPrefix\": \"0P+eTw==\",\n    \"MethodName\": \"Release\",\n    \"Params\": \"\\\"ad868c1e0d74127dd746ccdf3443a09459c55cf07d247df053ddf718df258c86\\\"\",\n    \"Signature\": \"DQcv55EBWunEFPXAbqZG20OLO5T0Sq/s0A+/iuwv1TdQqIV4318HrqFLsGpx9m3+sp5mzhAnMlrG7CSxM6EuIgA=\"\n  },\n  \"ReturnValue\": \"\",\n  \"Error\": null\n}\n\n\nThe command outputs detailed information about the transaction, including its status, logs, and related block information.\n\nDecode the Logs for Readable Result​\n$ aelf-command event 09c8c824d2e3aea1d...cefe4e236c5b818d6a01d4f7ca0b60fe99535\n\n\nThis command provides a readable format of the events logged by the transaction. The output includes details such as the address, event name, indexed data, non-indexed data, and a decoded result.\n\nExample Breakdown​\n\nHere is a sample output from the get-tx-result command:\n\n{\n  \"TransactionId\": \"09c8c824d2e3aea1d...cefe4e236c5b818d6a01d4f7ca0b60fe99535\",\n  \"Status\": \"MINED\",\n  \"Logs\": [\n    {\n      \"Address\": \"25CecrU94dmMdbhC3LWMKxtoaL4Wv8PChGvVJM6PxkHAyvXEhB\",\n      \"Name\": \"Transferred\",\n      \"Indexed\": [\n        \"CiIKIJTPGZ24g4eHwSVNLit8jgjFJeeYCEEYLDpFiCeCT0Bf\",\n        \"EiIKIO0jJRxjHdRQmUTby8klRVSqYpwhOyUsnXYV3IrQg8N1\",\n        \"GgNFTEY=\"\n      ],\n      \"NonIndexed\": \"IICgt4fpBSomVC00MzFkMjc0Yi0zNWJjLTRjYzgtOGExZC1iODhhZTgxYzU2Zjc=\"\n    }\n  ],\n  \"BlockNumber\": 28411,\n  \"BlockHash\": \"fa22e4eddff12a728895a608db99d40a4b21894f7c07df1a4fa8f0625eb914a2\",\n  \"Transaction\": {\n    \"From\": \"2tj7Ea67fuQfVAtQZ3WBmTv7AAJ8S9D2L4g6PpRRJei6JXk7RG\",\n    \"To\": \"29RDBXTqwnpWPSPHGatYsQXW2E17YrQUCj7QhcEZDnhPb6ThHW\",\n    \"RefBlockNumber\": 28410,\n    \"RefBlockPrefix\": \"0P+eTw==\",\n    \"MethodName\": \"Release\",\n    \"Params\": \"\\\"ad868c1e0d74127dd746ccdf3443a09459c55cf07d247df053ddf718df258c86\\\"\",\n    \"Signature\": \"DQcv55EBWunEFPXAbqZG20OLO5T0Sq/s0A+/iuwv1TdQqIV4318HrqFLsGpx9m3+sp5mzhAnMlrG7CSxM6EuIgA=\"\n  },\n  \"ReturnValue\": \"\",\n  \"Error\": null\n}\n\nUnderstand the Decoded Event​\n\nAfter running the event command, the decoded event output is as follows:\n\n{\n  \"Address\": \"25CecrU94dmMdbhC3LWMKxtoaL4Wv8PChGvVJM6PxkHAyvXEhB\",\n  \"Name\": \"Transferred\",\n  \"Indexed\": [\n    \"CiIKIJTPGZ24g4eHwSVNLit8jgjFJeeYCEEYLDpFiCeCT0Bf\",\n    \"EiIKIO0jJRxjHdRQmUTby8klRVSqYpwhOyUsnXYV3IrQg8N1\",\n    \"GgNFTEY=\"\n  ],\n  \"NonIndexed\": \"IICgt4fpBSomVC00MzFkMjc0Yi0zNWJjLTRjYzgtOGExZC1iODhhZTgxYzU2Zjc=\",\n  \"Result\": {\n    \"from\": \"28Y8JA1i2cN6oHvdv7EraXJr9a1gY6D1PpJXw9QtRMRwKcBQMK\",\n    \"to\": \"2oSMWm1tjRqVdfmrdL8dgrRvhWu1FP8wcZidjS6wPbuoVtxhEz\",\n    \"symbol\": \"ELF\",\n    \"amount\": \"200000000000\",\n    \"memo\": \"T-431d274b-35bc-4cc8-8a1d-b88ae81c56f7\"\n  }\n}\n\nSummary of Decoded Event​\n\nFrom Address: 28Y8JA1i2cN6oHvdv7EraXJr9a1gY6D1PpJXw9QtRMRwKcBQMK To Address: 2oSMWm1tjRqVdfmrdL8dgrRvhWu1FP8wcZidjS6wPbuoVtxhEz Symbol: ELF Amount: 200000000000 Memo: T-431d274b-35bc-4cc8-8a1d-b88ae81c56f7\n\nThese steps and commands will help you retrieve and decode the transaction results on the ealf blockchain.\n\nFor more details, check the descriptions of aelf-command event.\n\nDeploy a smart contract\n\nNote: The deploy command has been deprecated. Please use aelf-command send or aelf-command proposal instead.\n\nExample Workflow​\n1.Check Chain Status​\n$ aelf-command get-chain-status\n✔ Succeed\n{\n  \"ChainId\": \"AELF\",\n  \"Branches\": {\n    \"41a8a1ebf037197b7e2f10a67d81f741d46a6af41775bcc4e52ab855c58c4375\": 8681551,\n    \"ed4012c21a2fbf810db52e9869ef6a3fb0629b36d23c9be2e3692a24703b3112\": 8681597,\n    \"13476b902ef137ed63a4b52b2902bb2b2fa5dbe7c256fa326c024a73dc63bcb3\": 8681610\n  },\n  \"NotLinkedBlocks\": {},\n  \"LongestChainHeight\": 8681610,\n  \"LongestChainHash\": \"13476b902ef137ed63a4b52b2902bb2b2fa5dbe7c256fa326c024a73dc63bcb3\",\n  \"GenesisBlockHash\": \"cd5ce1bfa0cd97a1dc34f735c57bea2fcb9d88fc8f76bece2592fe7d82d5660c\",\n  \"GenesisContractAddress\": \"2gaQh4uxg6tzyH1ADLoDxvHA14FMpzEiMqsQ6sDG5iHT8cmjp8\",\n  \"LastIrreversibleBlockHash\": \"4ab84cdfe0723b191eedcf4d2ca86b0f64e57105e61486c21d98d562b14f2ab0\",\n  \"LastIrreversibleBlockHeight\": 8681483,\n  \"BestChainHash\": \"0dbc2176aded950020577552c92c82e66504ea109d4d6588887502251b7e932b\",\n  \"BestChainHeight\": 8681609\n}\n\n2. Deploy Smart Contract​\n\nUse the Genesis Contract Address (GenesisContractAddress) as a parameter with aelf-command send.\n\n$ aelf-command send 2gaQh4uxg6tzyH1ADLoDxvHA14FMpzEiMqsQ6sDG5iHT8cmjp8 DeploySmartContract\n✔ Fetching contract successfully!\n\nIf you need to pass file contents as a parameter, you can enter the relative or absolute path of the file\n\nEnter the params one by one, type `Enter` to skip optional param:\n? Enter the required param <category>: 0\n? Enter the required param <code>: /Users/test/contract.dll\n...\n\n\n3. Propose New Contract​\n\nUse aelf-command send with ProposeNewContract method if required by the chain.\n\n$ aelf-command send 2gaQh4uxg6tzyH1ADLoDxvHA14FMpzEiMqsQ6sDG5iHT8cmjp8 ProposeNewContract\n✔ Fetching contract successfully!\n\nIf you need to pass file contents as a parameter, you can enter the relative or absolute path of the file\n\nEnter the params one by one, type `Enter` to skip optional param:\n? Enter the required param <category>: 0\n? Enter the required param <code>: /Users/test/contract.dll\n...\n\nYou must input contract method parameters in the prompting way. Note that you can input a relative or absolute path of a contract file to pass a file to `aelf-command`. It will read the file content and encode it as a base64 string.\n\nAfter calling `ProposeNewContract`, you can get the proposal id and `proposedContractInputHash` later by running:\n\n$ aelf-command event 34184cbc27c95bbc0a1bd676192c3afc380740ab61626e5d428ae17faf9ea984\n[Info]:\nThe results returned by Transaction: 34184cbc27c95bbc0a1bd676192c3afc380740ab61626e5d428ae17faf9ea984 is:\n[\n  {\n    \"Address\": \"pykr77ft9UUKJZLVq15wCH8PinBSjVRQ12sD1Ayq92mKFsJ1i\",\n    \"Name\": \"ContractProposed\",\n    \"Indexed\": [],\n    \"NonIndexed\": \"CiIKIK0dKXkwu/HDpZUf/tzjJSfcZ5XznUrE/C0XMtp4liqo\",\n    \"Result\": {\n      \"proposedContractInputHash\": \"ad1d297930bbf1c3a5951ffedce32527dc6795f39d4ac4fc2d1732da78962aa8\"\n    }\n  },\n  {\n    \"Address\": \"2JT8xzjR5zJ8xnBvdgBZdSjfbokFSbF5hDdpUCbXeWaJfPDmsK\",\n    \"Name\": \"ProposalCreated\",\n    \"Indexed\": [\n      \"EiIKIEknWCUo4/KJS/vDAf7u1R6JmLEfAcapRY1BZ9yogawl\"\n    ],\n    \"NonIndexed\": \"CiIKIFb/RK9tR/SjJn0z7d4AjUvw288KCwTRyXSYMMryQuC2\",\n    \"Result\": {\n      \"organizationAddress\": \"ZDcYStbBRACaEQh6K1nqPb2SHKPCTggB9E66onthFoGrVnkfi\",\n      \"proposalId\": \"56ff44af6d47f4a3267d33edde008d4bf0dbcf0a0b04d1c9749830caf242e0b6\"\n    }\n  }\n]\n\nWait for the organization members to approve your proposal, and you can release your proposal by calling `ReleaseApprovedContract`.\n\n\n4. Release Approved Contract​\n$ aelf-command send 2gaQh4uxg6tzyH1ADLoDxvHA14FMpzEiMqsQ6sDG5iHT8cmjp8\n✔ Fetching contract successfully!\n? Pick up a contract method: ReleaseApprovedContract\n\nIf you need to pass file contents as a parameter, you can enter the relative or absolute path of the file\n\nEnter the params one by one, type `Enter` to skip optional param:\n? Enter the required param <proposalId>: proposalId\n? Enter the required param <proposedContractInputHash>: proposedContractInputHash\n\nThe params you entered are:\n{\n  \"proposalId\": proposalNewContract proposalId,\n  \"proposedContractInputHash\": proposedContractInputHash\n}\n✔ Succeed!\n\nAnd then you can get the code check proposal id from the event of `ReleaseApprovedContract` transaction.\n\n...\n\n{\n  \"Address\": \"2JT8xzjR5zJ8xnBvdgBZdSjfbokFSbF5hDdpUCbXeWaJfPDmsK\",\n  \"Name\": \"ProposalCreated\",\n  \"Indexed\": [\n    \"EiIKIEknWCUo4/KJS/vDAf7u1R6JmLEfAcapRY1BZ9yogawl\"\n  ],\n  \"NonIndexed\": \"CiIKIAfOf/a3zIillggQjSl2N0Y3aEh8bRGK5ppBrc14CKSn\",\n  \"Result\": {\n    \"organizationAddress\": \"ZDcYStbBRACaEQh6K1nqPb2SHKPCTggB9E66onthFoGrVnkfi\",\n    \"proposalId\": \"07ce7ff6b7cc88a59608108d297637463768487c6d118ae69a41adcd7808a4a7\"\n  }\n}\n\nWait for the code check to pass, then you can release the code check proposal by calling `ReleaseCodeCheck`.\n\n\n5. Release Code-Checked Contract​\n$ aelf-command send 2gaQh4uxg6tzyH1ADLoDxvHA14FMpzEiMqsQ6sDG5iHT8cmjp8 -a 28Y8JA1i2cN6oHvdv7EraXJr9a1gY6D1PpJXw9QtRMRwKcBQMK -p 123\n✔ Fetching contract successfully!\n? Pick up a contract method: ReleaseCodeCheckedContract\n\nIf you need to pass file contents as a parameter, you can enter the relative or absolute path of the file\n\nEnter the params one by one, type `Enter`\n\nevent - Deserialize Transaction Result​\n\nTo view details from a transaction, including events triggered by contract methods, you can use the aelf-command event tool. Here’s how:\n\n$ aelf-command event fe1974fde291e44e16c55db666f2c747323cdc584d616de05c88c8bae18ecceb\n\n[Info]:\nThe results returned by\nTransaction: fe1974fde291e44e16c55db666f2c747323cdc584d616de05c88c8bae18ecceb is:\n[\n  {\n    \"Address\": \"2gaQh4uxg6tzyH1ADLoDxvHA14FMpzEiMqsQ6sDG5iHT8cmjp8\",\n    \"Name\": \"ContractDeployed\",\n    \"Indexed\": [\n      \"CiIKIN2O6lDDGWbgbkomYr6+9+2B0JpHsuses3KfLwzHgSmu\",\n      \"EiIKIDXZGwZLKqm78WpYDXuBlyd6Dv+RMjrgOUEnwamfIA/z\"\n    ],\n    \"NonIndexed\": \"GiIKIN2O6lDDGWbgbkomYr6+9+2B0JpHsuses3KfLwzHgSmu\",\n    \"Result\": {\n      \"author\": \"2gaQh4uxg6tzyH1ADLoDxvHA14FMpzEiMqsQ6sDG5iHT8cmjp8\",\n      \"codeHash\": \"35d91b064b2aa9bbf16a580d7b8197277a0eff91323ae0394127c1a99f200ff3\",\n      \"address\": \"2gaQh4uxg6tzyH1ADLoDxvHA14FMpzEiMqsQ6sDG5iHT8cmjp8\"\n    }\n  }\n]\n✔ Succeed!\n\nExplanation:​\n\nWhen you execute this command, you'll get details about the transaction with ID fe1974fde291e44e16c55db666f2c747323cdc584d616de05c88c8bae18ecceb. Here's what the output means:\n\nAddress: The contract address where the event occurred.\nName: The name of the event triggered by a contract method.\nIndexed: Additional data related to the event, encoded in base64 format.\nNonIndexed: Further details about the event, also in base64.\nResult: Decoded information from the event, providing readable details such as author, code hash, and address.\n\nThis command helps you understand what happened during a transaction, especially useful when dealing with events triggered by smart contracts.\n\nsend - Send a transaction​\n1. Enter aelf Node URI:​\n$ aelf-command send\n✔ Enter the URI of an AElf node … http://13.231.179.27:8000\n\n\nYou need to specify the URI of an aelf blockchain node to which you will connect.\n\n2. Enter Wallet Address and Password:​\n✔ Enter a valid wallet address, if you do not have, create one by aelf-command create … D3vSjRYL8MpeRpvUDy85ktXijnBe2tHn8NTACsggUVteQCNGP\n✔ Enter the password you typed when creating a wallet … ********\n\n\nProvide your wallet address and the password associated with it. This is necessary to sign transactions.\n\n3. Enter Contract Information:​\n✔ Enter contract name (System contracts only) or the address of contract … AElf.ContractNames.Token\n✔ Fetching contract successfully!\n\n\nSpecify the contract name or address. In this example, AElf.ContractNames.Token refers to the Token contract.\n\n4. Select Contract Method:​\n? Pick up a contract method: Transfer\n\n\nChoose the specific method of the contract you want to invoke. Here, Transfer is selected.\n\n5. Enter Method Parameters:​\nEnter the params one by one, type `Enter` to skip optional param:\n? Enter the required param <to>: C91b1SF5mMbenHZTfdfbJSkJcK7HMjeiuwfQu8qYjGsESanXR\n? Enter the required param <symbol>: ELF\n? Enter the required param <amount>: 100000000\n? Enter the required param <memo>: 'test command'\n\n\nInput the required parameters for the Transfer method: recipient address (to), token symbol (symbol), amount (amount), and an optional memo (memo).\n\n6. Confirmation and Execution:​\nThe params you entered is:\n{\n  \"to\": \"C91b1SF5mMbenHZTfdfbJSkJcK7HMjeiuwfQu8qYjGsESanXR\",\n  \"symbol\": \"ELF\",\n  \"amount\": 100000000,\n  \"memo\": \"'test command'\"\n}\n✔ Succeed!\n\n\nConfirm the parameters you entered and proceed with the transaction.\n\n7. Transaction Result:​\nAElf [Info]:\nResult:\n{\n  \"TransactionId\": \"85d4684cb6e4721a63893240f73f675ac53768679c291abeb54974ff4e063bb5\"\n}\n✔ Succeed!\n\n\nThe transaction is executed successfully, and you receive the TransactionId as confirmation.\n\nBy following these steps, you can effectively send transactions on the aelf blockchain using the aelf-command send interface. Adjust parameters and contract names as necessary for different contract methods or system contracts within AElf.\n\ncall - Call a read-only method on a contract​\n$ aelf-command call\n✔ Enter the the URI of an AElf node … http://13.231.179.27:8000\n✔ Enter a valid wallet address, if you do not have, create one by aelf-command create … D3vSjRYL8MpeRpvUDy85ktXijnBe2tHn8NTACsggUVteQCNGP\n✔ Enter the password you typed when creating a wallet … ********\n✔ Enter contract name (System contracts only) or the address of contract … AElf.ContractNames.Token\n✔ Fetching contract successfully!\n? Pick up a contract method: GetTokenInfo\n\nIf you need to pass file contents as a parameter, you can enter the relative or absolute path of the file\n\nEnter the params one by one, type `Enter` to skip optional param:\n? Enter the required param <symbol>: ELF\nThe params you entered is:\n{\n  \"symbol\": \"ELF\"\n}\n✔ Calling method successfully!\nAElf [Info]:\nResult:\n{\n  \"symbol\": \"ELF\",\n  \"tokenName\": \"Native Token\",\n  \"supply\": \"99732440917954549\",\n  \"totalSupply\": \"100000000000000000\",\n  \"decimals\": 8,\n  \"issuer\": \"FAJcKnSpbViZfAufBFzX4nC8HtuT93rxUS4VCMACUwXWYurC2\",\n  \"isBurnable\": true,\n  \"issueChainId\": 9992731,\n  \"burned\": \"267559132045477\"\n}\n✔ Succeed!\n\naelf-command call AElf.ContractNames.Token GetTokenInfo '{\"symbol\":\"ELF\"}'\n\nget-chain-status - Get the current status of the block chain​\n$ aelf-command get-chain-status\n✔ Succeed\n{\n  \"ChainId\": \"AELF\",\n  \"Branches\": {\n    \"59937e3c16860dedf0c80955f4995a5604ca43ccf39cd52f936fb4e5a5954445\": 4229086\n  },\n  \"NotLinkedBlocks\": {},\n  \"LongestChainHeight\": 4229086,\n  \"LongestChainHash\": \"59937e3c16860dedf0c80955f4995a5604ca43ccf39cd52f936fb4e5a5954445\",\n  \"GenesisBlockHash\": \"da5e200259320781a1851081c99984fb853385153991e0f00984a0f5526d121c\",\n  \"GenesisContractAddress\": \"2gaQh4uxg6tzyH1ADLoDxvHA14FMpzEiMqsQ6sDG5iHT8cmjp8\",\n  \"LastIrreversibleBlockHash\": \"497c24ff443f5cbd33da24a430f5c6c5e0be2f31651bd89f4ddf2790bcbb1906\",\n  \"LastIrreversibleBlockHeight\": 4229063,\n  \"BestChainHash\": \"59937e3c16860dedf0c80955f4995a5604ca43ccf39cd52f936fb4e5a5954445\",\n  \"BestChainHeight\": 4229086\n}\n\nget-tx-result - Get a transaction result​\n$ aelf-command get-tx-result\n✔ Enter the the URI of an AElf node … http://13.231.179.27:8000\n✔ Enter a valid transaction id in hex format … 7b620a49ee9666c0c381fdb33f94bd31e1b5eb0fdffa081463c3954e9f734a02\n✔ Succeed!\n{ TransactionId:\n   '7b620a49ee9666c0c381fdb33f94bd31e1b5eb0fdffa081463c3954e9f734a02',\n  Status: 'MINED',\n  Logs: null,\n  Bloom:\n   'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA==',\n  BlockNumber: 7900508,\n  BlockHash:\n   'a317c5ecf4a22a481f88ab08b8214a8e8c24da76115d9ddcef4afc9531d01b4b',\n  Transaction:\n   { From: 'D3vSjRYL8MpeRpvUDy85ktXijnBe2tHn8NTACsggUVteQCNGP',\n     To: 'WnV9Gv3gioSh3Vgaw8SSB96nV8fWUNxuVozCf6Y14e7RXyGaM',\n     RefBlockNumber: 7900503,\n     RefBlockPrefix: 'Q6WLSQ==',\n     MethodName: 'GetTokenInfo',\n     Params: '{ \"symbol\": \"ELF\" }',\n     Signature:\n      'JtSpWbMX13tiJD0klMSJQyPBa0aRNFY4hTh3hltdWqhBpv4IRTbjjZfQj39lbBSCOy68vnLg6rUerEcyCsqwfgE=' },\n  ReadableReturnValue:\n   '{ \"symbol\": \"ELF\", \"tokenName\": \"elf token\", \"supply\": \"1000000000\", \"totalSupply\": \"1000000000\", \"decimals\": 2, \"issuer\": \"2gaQh4uxg6tzyH1ADLoDxvHA14FMpzEiMqsQ6sDG5iHT8cmjp8\", \"isBurnable\": true }',\n  Error: null }\n\nget-blk-height - Get the block height​\n$ aelf-command get-blk-height\n✔ Enter the the URI of an AElf node … http://13.231.179.27:8000\n> 7902091\n\nget-blk-info - Get the block info by a block height or a block hash​\n\nEither a block height or a block hash can be provided as an argument to this sub-command.\n\n$ aelf-command get-blk-info\n✔ Enter the the URI of an AElf node: http://13.231.179.27:8000\n✔ Enter a valid height or block hash: 123\n✔ Include transactions whether or not: no / yes\n{ BlockHash:\n   '6034db3e02e283d3b81a4528442988d28997d3828f87cca1a89457b294517372',\n  Header:\n   { PreviousBlockHash:\n      '9d6bcc588c0bc10942899e7ec4536665c86f23286029ed45287babf22c582f5a',\n     MerkleTreeRootOfTransactions:\n      '7ceb349715787ececa647ad48576467d294de6dcc44d14e19f60c4a91a7a9536',\n     MerkleTreeRootOfWorldState:\n      'b529e2775283edc39cd4e3f685616085b18bd5521a87ea7904ad99cd2dc50910',\n     Extra:\n      '[ \"CkEEJT3FEw+k9cuqv7uruq1fEwQwEjKtYxbXK86wUGrAOH7BgCVkMendLkQZmpEpMgzcz+JXnaVpWtFt3AJcGmGycxL+DggIEvIDCoIBMDQyNTNkYzUxMzBmYTRmNWNiYWFiZmJiYWJiYWFkNWYxMzA0MzAxMjMyYWQ2MzE2ZDcyYmNlYjA1MDZhYzAzODdlYzE4MDI1NjQzMWU5ZGQyZTQ0MTk5YTkxMjkzMjBjZGNjZmUyNTc5ZGE1Njk1YWQxNmRkYzAyNWMxYTYxYjI3MxLqAggCIiIKIOAP2QU8UpM4u9Y3OxdKdI5Ujm3DSyQ4JaRNf7q5ka5mKiIKIH5yNJs87wb/AkWcIrCxvCX/Te3fGHVXFxE8xsnfT1HtMgwIoJro6AUQjOa1pQE4TkqCATA0MjUzZGM1MTMwZmE0ZjVjYmFhYmZiYmFiYmFhZDVmMTMwNDMwMTIzMmFkNjMxNmQ3MmJjZWIwNTA2YWMwMzg3ZWMxODAyNTY0MzFlOWRkMmU0NDE5OWE5MTI5MzIwY2RjY2ZlMjU3OWRhNTY5NWFkMTZkZGMwMjVjMWE2MWIyNzNiIgogHY83adsNje+EtL0lLEte8KfT6X/836zXZTbntbqyjgtoBHAEegwIoJro6AUQzOybpgF6DAigmujoBRCk8MG1AnoLCKGa6OgFEOCvuBF6CwihmujoBRCg/JhzegwIoZro6AUQ9Lml1wF6DAihmujoBRDYyOO7AnoMCKGa6OgFEKy+ip8DkAEOEp8CCoIBMDQ4MWMyOWZmYzVlZjI5NjdlMjViYTJiMDk0NGVmODQzMDk0YmZlOTU0NWFhZGFjMGQ3Nzk3MWM2OTFjZTgyMGQxYjNlYzQxZjNjMDllNDZjNmQxMjM2NzA5ZTE1ZTEyY2U5N2FhZGNjYTBmZGU4NDY2M2M3OTg0OWZiOGYwM2RkMhKXAQgEMgwIpJro6AUQjOa1pQE4IkqCATA0ODFjMjlmZmM1ZWYyOTY3ZTI1YmEyYjA5NDRlZjg0MzA5NGJmZTk1NDVhYWRhYzBkNzc5NzFjNjkxY2U4MjBkMWIzZWM0MWYzYzA5ZTQ2YzZkMTIzNjcwOWUxNWUxMmNlOTdhYWRjY2EwZmRlODQ2NjNjNzk4NDlmYjhmMDNkZDISnwIKggEwNDFiZTQwMzc0NjNjNTdjNWY1MjgzNTBhNjc3ZmRkZmEzMzcxOWVlZjU5NDMwNDY5ZTlmODdkY2IyN2Y0YTQ1NjY0OTI4NmZhNzIxYzljOWVjZDMxMmY0YjdlZDBmZGE4OTJmZTNlZDExZWFjYTBmMzcxOTBkMjAzYTczYTA2YjFmEpcBCAYyDAiomujoBRCM5rWlATgySoIBMDQxYmU0MDM3NDYzYzU3YzVmNTI4MzUwYTY3N2ZkZGZhMzM3MTllZWY1OTQzMDQ2OWU5Zjg3ZGNiMjdmNGE0NTY2NDkyODZmYTcyMWM5YzllY2QzMTJmNGI3ZWQwZmRhODkyZmUzZWQxMWVhY2EwZjM3MTkwZDIwM2E3M2EwNmIxZhKfAgqCATA0OTMzZmYzNDRhNjAxMTdmYzRmYmRmMDU2ODk5YTk0NDllNjE1MzA0M2QxYzE5MWU4NzlkNjlkYzEzZmIyMzM2NWJmNTQxZWM1NTU5MWE2MTQ3YmM1Y2M3ZjUzMjQ0OTY2ZGE5NzA2ZWZmNzZiY2Y2ZjViY2EyOTYzNmVmODNkYzYSlwEICjIMCLCa6OgFEIzmtaUBOCJKggEwNDkzM2ZmMzQ0YTYwMTE3ZmM0ZmJkZjA1Njg5OWE5NDQ5ZTYxNTMwNDNkMWMxOTFlODc5ZDY5ZGMxM2ZiMjMzNjViZjU0MWVjNTU1OTFhNjE0N2JjNWNjN2Y1MzI0NDk2NmRhOTcwNmVmZjc2YmNmNmY1YmNhMjk2MzZlZjgzZGM2EpUDCoIBMDRiNmMwNzcxMWJjMzBjZGY5OGM5ZjA4MWU3MDU5MWY5OGYyYmE3ZmY5NzFlNWExNDZkNDcwMDlhNzU0ZGFjY2ViNDY4MTNmOTJiYzgyYzcwMDk3MWFhOTM5NDVmNzI2YTk2ODY0YTJhYTM2ZGE0MDMwZjA5N2Y4MDZiNWFiZWNhNBKNAggIEAEyDAismujoBRCM5rWlATgwQAJKggEwNGI2YzA3NzExYmMzMGNkZjk4YzlmMDgxZTcwNTkxZjk4ZjJiYTdmZjk3MWU1YTE0NmQ0NzAwOWE3NTRkYWNjZWI0NjgxM2Y5MmJjODJjNzAwOTcxYWE5Mzk0NWY3MjZhOTY4NjRhMmFhMzZkYTQwMzBmMDk3ZjgwNmI1YWJlY2E0egwInJro6AUQjOa1pQF6DAicmujoBRCkz+mjAnoMCJya6OgFEIj8yfECegwInJro6AUQ7KiH0wN6CwidmujoBRCko6hXegwInZro6AUQ6LTNugF6DAidmujoBRCY4NObAnoMCJ2a6OgFEMzWv+oCkAEQIFg6ggEwNGI2YzA3NzExYmMzMGNkZjk4YzlmMDgxZTcwNTkxZjk4ZjJiYTdmZjk3MWU1YTE0NmQ0NzAwOWE3NTRkYWNjZWI0NjgxM2Y5MmJjODJjNzAwOTcxYWE5Mzk0NWY3MjZhOTY4NjRhMmFhMzZkYTQwMzBmMDk3ZjgwNmI1YWJlY2E0QAIYBQ==\", \"\" ]',\n     Height: 123,\n     Time: '2019-07-01T13:39:45.8704899Z',\n     ChainId: 'AELF',\n     Bloom:\n      '00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000',\n     SignerPubkey:\n      '04253dc5130fa4f5cbaabfbbabbaad5f1304301232ad6316d72bceb0506ac0387ec180256431e9dd2e44199a9129320cdccfe2579da5695ad16ddc025c1a61b273' },\n  Body:\n   { TransactionsCount: 1,\n     Transactions:\n      [ 'a365a682caf3b586cbd167b81b167979057246a726c7282530554984ec042625' ] } }\n\naelf-command get-blk-info ca61c7c8f5fc1bc8af0536bc9b51c61a94f39641a93a748e72802b3678fea4a9 true\n\nconsole - Open an interactive console​\n$ aelf-command console\n✔ Enter the the URI of an AElf node … http://13.231.179.27:8000\n✔ Enter a valid wallet address, if you do not have, create one by aelf-command create … 2Ue31YTuB5Szy7cnr3SCEGU2gtGi5uMQBYarYUR5oGin1sys6H\n✔ Enter the password you typed when creating a wallet … ********\n✔ Succeed!\nWelcome to aelf interactive console. Ctrl + C to terminate the program. Double tap Tab to list objects\n\n   ╔═══════════════════════════════════════════════════════════╗\n   ║                                                           ║\n   ║   NAME       | DESCRIPTION                                ║\n   ║   AElf       | imported from aelf-sdk                     ║\n   ║   aelf       | instance of aelf-sdk, connect to           ║\n   ║              | http://13.231.179.27:8000                  ║\n   ║   _account   | instance of AElf wallet, wallet address    ║\n   ║              | is                                         ║\n   ║              | 2Ue31YTuB5Szy7cnr3SCEGU2gtGi5uMQBYarYUR…   ║\n   ║              | 5oGin1sys6H                                ║\n   ║                                                           ║\n   ╚═══════════════════════════════════════════════════════════╝\n\ndapp-server - Start a socket.io server for supplying services for dApps​\n\nAre you developing a dApp and need an environment to manage wallet information and connect to the AElf chain? You can easily start a local development server using this sub-command.\n\n$ aelf-command dapp-server\nAElf [Info]: DApp server is listening on port 35443\n\n\nAlternatively, you can specify a different port:\n\n$ aelf-command dapp-server --port 40334\nAElf [Info]: DApp server is listening on port 40334\n\n\nThis server uses Socket.io to listen on the specified local port. You can use aelf-bridge to connect to this server with the following code:\n\nimport AElfBridge from 'aelf-bridge';\n\nconst bridgeInstance = new AElfBridge({\n  proxyType: 'SOCKET.IO',\n  socketUrl: 'http://localhost:35443',\n  channelType: 'ENCRYPT'\n});\n\n// Connect to dapp-server\nbridgeInstance.connect().then(console.log).catch(console.error);\n\n\nFor more details, check out the aelf-bridge and aelf-bridge-demo.\n\nPrevious\nIntroduction to CLI\nNext\nSmart Contract\nCommon Options\nConfig Command\nWorking Directory Config File\nCLI Parameters\nCreate a New Account\nLoad - Load an Account by a Given Private Key or Mnemonic\nLoad from Mnemonic\nLoad from Private Key\nLoad from Prompting\nWallet - Show Wallet Details\nProposal - Create a Proposal\nGet an Organization Address or Create One\nCreate a Proposal\nGet Proposal Status\nRelease a Proposal\nGet the Transaction Result\nDecode the Logs for Readable Result\nUnderstand the Decoded Event\nevent - Deserialize Transaction Result\nsend - Send a transaction\ncall - Call a read-only method on a contract\nget-chain-status - Get the current status of the block chain\nget-tx-result - Get a transaction result\nget-blk-height - Get the block height\nget-blk-info - Get the block info by a block height or a block hash\nconsole - Open an interactive console\ndapp-server - Start a socket.io server for supplying services for dApps\nPlatform\nTechnology\nAudit Report\nPrivacy\nTerms of Use\nCookie Policy\nDeveloper Resources\nQuick Start\nLearn\nDocs\nTools\nResources\nEcosystem\nOverview\ndApps\naelf Ventures\nBlog\nConnect\nContact Us\nCopyright © 2024 aelf"
    },
    {
      "title": "AELF Docs",
      "url": "https://docs.aelf.com/tools/chain-sdk/python-sdk/",
      "html": "Skip to main content\nQuick Start\nLearn\nDocs\nTools\nResources\nBlog\nSearch\nTools\nChain SDK\nJavascript SDK\nC# SDK\nGo SDK\nJAVA SDK\nPHP SDK\nPython SDK\naelf Deploy Tool\naelf CLI\nSmart Contract\naelf Testnet Faucet\naelf Design\naelf Playground\nContract SDK\nToolsChain SDKPython SDK\naelf-sdk.py - aelf Python API\nIntroduction​\n\nThe aelf-sdk.py is the Python equivalent of web3.js for Ethereum. It is a collection of libraries that allow you to interact with a local or remote aelf node using an HTTP connection.\n\nThis documentation will guide you through the installation and usage of aelf-sdk.py, providing detailed API references with examples. For more information, you can check out the aelf-sdk.py repository.\n\nAdding aelf-sdk.py​\n\nTo start using aelf-sdk.py in your project, you need to install the package. This can be done using pip:\n\npip install aelf-sdk\n\n\nAfter installation, you need to create an instance of AElf using a node’s URL:\n\nfrom aelf import AElf\n\nchain = AElf('http://127.0.0.1:8000')\n\nExamples​\n\nYou can find more examples in the ./test directory of the repository.\n\n1. Create an Instance​\n\nTo create a new instance of AElf and connect to an aelf chain node, use the following code. With this instance, you can call various APIs on aelf.\n\nfrom aelf import AElf\n\n# Create a new instance of AElf\naelf = AElf('http://127.0.0.1:8000')\n\n2. Get a System Contract Address​\n\nTo get a system contract address, for example, the AElf.ContractNames.Token, use the following code:\n\nfrom aelf import AElf\n\naelf = AElf('http://127.0.0.1:8000')\n\n# Get the genesis contract address\ngenesis_contract_address = aelf.get_genesis_contract_address_string()\n\n# Get the contract address\n# The get_system_contract_address method calls 'GetContractAddressByName' in the genesis contract to get other contracts' addresses\nmulti_token_contract_address = aelf.get_system_contract_address('AElf.ContractNames.Token')\n\n3. Send a Transaction​\n\nTo send a transaction, first get the contract address and then use the following steps:\n\nfrom aelf import AElf, PrivateKey, CrossChainTransferInput\n\nurl = 'http://127.0.0.1:8000'\n\n# Create a new instance of AElf\naelf = AElf(url)\n\n# Generate the private key\nprivate_key_string = 'b344570eb80043d7c5ae9800c813b8842660898bf03cbd41e583b4e54af4e7fa'\nprivate_key = PrivateKey(bytes(bytearray.fromhex(private_key_string)))\n\n# Create input, the type is generated by protoc\ncross_chain_transfer_input = CrossChainTransferInput()\n\n# Generate the transaction\ntransaction = aelf.create_transaction(to_address, method_name, params.SerializeToString())\n\n# Sign the transaction with the user's private key\naelf.sign_transaction(private_key, transaction)\n\n# Execute the transaction\naelf.execute_transaction(transaction)\n\n\nBy following these instructions, you can effectively interact with the aelf blockchain using the aelf-sdk.py library. For more detailed examples and information, please refer to the aelf-sdk.py repository.\n\nWeb API​\n\nYou can view how the Web API of the node works at http://{chainAddress}/swagger/index.html.\n\nFor example, if your local address is http://127.0.0.1:1235, you can access it at http://127.0.0.1:1235/swagger/index.html.\n\nBefore using these methods, make sure you have an AElf instance. If not, create one as shown below:\n\nfrom aelf import AElf\n\n# Create a new instance of AElf, change the URL if needed\naelf = AElf('http://127.0.0.1:8000')\n\n1. Get Chain Status​\n\nWeb API Path: /api/blockChain/chainStatus\n\nParameters: None\n\nReturns:\n\nJSON\n\nChainId - String\nBranches - JSON\nNotLinkedBlocks - JSON\nLongestChainHeight - Number\nLongestChainHash - String\nGenesisBlockHash - String\nGenesisContractAddress - String\nLastIrreversibleBlockHash - String\nLastIrreversibleBlockHeight - Number\nBestChainHash - String\nBestChainHeight - Number\n\nExample:\n\naelf = AElf(url)\nchain_status = aelf.get_chain_status()\nprint('# get_chain_status', chain_status)\n\n2. Get Block Height​\n\nWeb API Path: /api/blockChain/blockHeight\n\nParameters: None\n\nReturns: Number\n\nExample:\n\naelf = AElf(url)\nblock_height = aelf.get_block_height()\nprint('# get_block_height', block_height)\n\n3. Get Block​\n\nWeb API Path: /api/blockChain/block\n\nParameters: None\n\nblock_hash - String\ninclude_transactions - Boolean (true to include transaction IDs list, false otherwise)\n\nReturns:\n\nJSON\n\nBlockHash - String\n\nHeader - JSON\n\nPreviousBlockHash - String\nMerkleTreeRootOfTransactions - String\nMerkleTreeRootOfWorldState - String\nExtra - List\nHeight - Number\nTime - JSON\nChainId - String\nBloom - String\nSignerPubkey - String\n\nBody - JSON\n\nTransactionsCount - Number\nTransactions - List\ntransactionId - String\n\nExample:\n\naelf = AElf(url)\nblock = aelf.get_block(blockHash)\nprint('# get_block', block)\n\n4. Get Block by Height​\n\nWeb API Path: /api/blockChain/blockByHeight\n\nParameters:\n\nblock_height - Number\ninclude_transactions - Boolean (true to include transaction IDs list, false otherwise)\n\nReturns:\n\nJSON\n\nBlockHash - String\n\nHeader - JSON\n\nPreviousBlockHash - String\nMerkleTreeRootOfTransactions - String\nMerkleTreeRootOfWorldState - String\nExtra - List\nHeight - Number\nTime - JSON\nChainId - String\nBloom - String\nSignerPubkey - String\n\nBody - JSON\n\nTransactionsCount - Number\nTransactions - List\ntransactionId - String\n\nExample:\n\naelf = AElf(url)\nblock_by_height = aelf.get_block_by_height(12, False)\nprint('# get_block_by_height', block_by_height)\n\n5. Get Transaction Result​\n\nWeb API Path: /api/blockChain/transactionResult\n\nParameters:\n\ntransactionId - String\n\nReturns:\n\nJSON\n\nTransactionId - String\nStatus - String\nLogs - List\nAddress - String\nName - String\nIndexed - List\nNonIndexed - String\nBloom - String\nBlockNumber - Number\nTransaction - List\nFrom - Number\nTo - Number\nRefBlockNumber - Number\nRefBlockPrefix - String\nMethodName - String\nParams - JSON\nSignature - String\nReadableReturnValue - JSON\nError - String\n\nExample:\n\naelf = AElf(url)\ntransaction_result = aelf.get_transaction_result(transactionId)\nprint('# get_transaction_result', transaction_result)\n\n6. Get Transaction Results​\n\nWeb API Path: /api/blockChain/transactionResults\n\nParameters:\n\nblockHash - String\noffset - Number\nlimit - Number\n\nReturns: List of transaction result objects\n\nExample:\n\naelf = AElf(url)\ntransaction_results = aelf.get_transaction_results(blockHash, 0, 2)\nprint('# get_transaction_results', transaction_results)\n\n7. Get Transaction Pool Status​\n\nWeb API Path: /api/blockChain/transactionPoolStatus\n\nExample:\n\naelf = AElf(url)\ntx_pool_status = aelf.get_transaction_pool_status()\nprint('# get_transaction_pool_status', tx_pool_status)\n\n8. Send Transaction​\n\nWeb API Path: /api/blockChain/sendTransaction\n\nMethod: POST\n\nParameters:\n\ntransaction - String (serialized data)\n\nExample:\n\naelf = AElf(url)\ncurrent_height = aelf.get_block_height()\nblock = aelf.get_block_by_height(current_height, include_transactions=False)\ntransaction = Transaction()\ntransaction.to_address.CopyFrom(aelf.get_system_contract_address(\"AElf.ContractNames.Consensus\"))\ntransaction.ref_block_number = current_height\ntransaction.ref_block_prefix = bytes.fromhex(block['BlockHash'])[0:4]\ntransaction.method_name = 'GetCurrentMinerList'\ntransaction = aelf.sign_transaction(private_key, transaction)\nresult = aelf.send_transaction(transaction.SerializePartialToString().hex())\nprint('# send_transaction', result)\n\n9. Send Transactions​\n\nWeb API Path: /api/blockChain/sendTransaction\n\nMethod: POST\n\nParameters:\n\ntransactions - String (serialized data)\n\nExample:\n\naelf = AElf(url)\ncurrent_height = aelf.get_block_height()\nblock = aelf.get_block_by_height(current_height, include_transactions=False)\ntransaction1 = Transaction().SerializePartialToString().hex()\ntransaction2 = Transaction().SerializePartialToString().hex()\nresult = aelf.send_transaction(transaction1 + ',' + transaction2)\nprint('# send_transactions', result)\n\n10. Get Peers​\n\nWeb API Path: /api/net/peers\n\nExample:\n\naelf = AElf(url)\npeers = aelf.get_peers()\nprint('# get_peers', peers)\n\n11. Add Peer​\n\nWeb API Path: /api/net/peers\n\nMethod: POST\n\nParameters:\n\npeer_address - String (peer’s endpoint)\n\nExample:\n\naelf = AElf(url)\nadd_peer = aelf.add_peer(endpoint)\nprint('# add_peer', add_peer)\n\n12. Remove Peer​\n\nWeb API Path: /api/net/peer?address=\n\nMethod: POST\n\nParameters:\n\npeer_address - String (peer’s endpoint)\n\nExample:\n\naelf = AElf(url)\nremove_peer = aelf.remove_peer(address)\nprint('# remove_peer', remove_peer)\n\n13. Create Raw Transaction​\n\nWeb API Path: /api/blockchain/rawTransaction\n\nMethod: POST\n\nParameters:\n\ntransaction - JSON format transaction\n\nReturns:\n\nJSON\nRawTransaction - hex string bytes generated by transaction information\n\nExample:\n\naelf = AElf(url)\ntransaction = {\n    \"From\": aelf.get_address_string_from_public_key(public_key),\n    \"To\": aelf.get_system_contract_address_string(\"AElf.ContractNames.Consensus\"),\n    \"RefBlockNumber\": 0,\n    \"RefBlockHash\": \"b344570eb80043d7c5ae9800c813b8842660898bf03cbd41e583b4e54af4e7fa\",\n    \"MethodName\": \"GetCurrentMinerList\",\n    \"Params\": '{}'\n}\nraw_transaction = aelf.create_raw_transaction(transaction)\nprint('# create_raw_transaction', raw_transaction)\n\n14. Send Raw Transaction​\n\nWeb API Path: /api/blockchain/sendRawTransaction\n\nMethod: POST\n\nParameters:\n\nTransaction - raw transaction\nSignature - signature\nReturnTransaction - indicates whether to return the transaction\n\nExample:\n\naelf = AElf(url)\n\n# Create the raw transaction\nraw_transaction = aelf.create_raw_transaction({\n    \"From\": aelf.get_address_string_from_public_key(public_key),\n    \"To\": aelf.get_system_contract_address_string(\"AElf.ContractNames.Consensus\"),\n    \"RefBlockNumber\": 0,\n    \"RefBlockHash\": \"b344570eb80043d7c5ae9800c813b8842660898bf03cbd41e583b4e54af4e7fa\",\n    \"MethodName\": \"GetCurrentMinerList\",\n    \"Params\": '{}'\n})\n\n# Sign the raw transaction\nsignature = private_key.sign_recoverable(bytes.fromhex(raw_transaction['RawTransaction']))\n\n# Create the transaction payload\ntransaction_2 = {\n    \"Transaction\": raw_transaction['RawTransaction'],\n    'Signature': signature.hex(),\n    'ReturnTransaction': True\n}\n\n# Send the raw transaction\nresult = aelf.send_raw_transaction(transaction_2)\nprint('# send_raw_transaction', result)\n\n15. Execute Raw Transaction​\n\nWeb API Path: /api/blockchain/executeRawTransaction\n\nMethod: POST\n\nParameters:\n\nRawTransaction - raw transaction\nSignature - signature\n\nExample:\n\naelf = AElf(url)\n\n# Create the raw transaction\nraw_transaction = aelf.create_raw_transaction({\n    \"From\": aelf.get_address_string_from_public_key(public_key),\n    \"To\": aelf.get_system_contract_address_string(\"AElf.ContractNames.Consensus\"),\n    \"RefBlockNumber\": 0,\n    \"RefBlockHash\": \"b344570eb80043d7c5ae9800c813b8842660898bf03cbd41e583b4e54af4e7fa\",\n    \"MethodName\": \"GetCurrentMinerList\",\n    \"Params\": '{}'\n})\n\n# Sign the raw transaction\nsignature = private_key.sign_recoverable(bytes.fromhex(raw_transaction['RawTransaction']))\n\n# Create the transaction payload\ntransaction_1 = {\n    \"RawTransaction\": raw_transaction['RawTransaction'],\n    \"Signature\": signature.hex()\n}\n\n# Execute the raw transaction\nresult = aelf.execute_raw_transaction(transaction_1)\nprint('# execute_raw_transaction', result)\n\n16. Get Merkle Path​\n\nWeb API Path: /api/blockchain/merklePathByTransactionId?transactionId=\n\nMethod: POST\n\nParameters:\n\ntransactionId - String\n\nExample:\n\naelf = AElf(url)\n\ntransaction_id = \"your-transaction-id\"\nmerkle_path = aelf.get_merkle_path(transaction_id)\nprint('# get_merkle_path', merkle_path)\n\n17. Calculate Transaction Fee​\n\nWeb API Path: /api/blockchain/calculateTransactionFee\n\nMethod: POST\n\nParameters:\n\nCalculateTransactionFeeInput - JSON with the following structure:\nRawTransaction - String\n\nReturns:\n\nCalculateTransactionFeeOutput - json - The json with the following structure :\nSuccess - Boolean\nTransactionFee - Array\nResourceFee - Array\n\nExample:\n\naelf = AElf(url)\n\ncalculate_transaction_fee_input = {\n    \"RawTransaction\": raw_transaction['RawTransaction']\n}\n\ncalculate_transaction_fee_output = aelf.calculate_transaction_fee(calculate_transaction_fee_input)\nprint('# calculate_transaction_fee', calculate_transaction_fee_output)\n\n18. Get Network Info​\n\nWeb API Path: /api/net/networkInfo\n\nMethod: POST\n\nExample:\n\naelf = AElf(url)\n\nnetwork_info = aelf.get_network_info()\nprint('# get_network_info', network_info)\n\nAElf.client​\n\nUse the API to see detailed results.\n\n1. get_genesis_contract_address_string​\n\nReturns the zero contract address.\n\nExample:\n\naelf = AElf(url)\n\ngenesis_contract_address = aelf.get_genesis_contract_address_string()\n\n2. get_system_contract_address​\n\nParameters:\n\ncontract_name - String: system contract’s name\n\nReturns:\n\nAddress: system contract’s address\n\nExample:\n\naelf = AElf(url)\n\nmulti_token_contract_address = aelf.get_system_contract_address('AElf.ContractNames.Token')\n\n3. get_system_contract_address_string​\n\nParameters:\n\ncontract_name - String: system contract’s name\n\nReturns:\n\nString: system contract’s address\n\nExample:\n\naelf = AElf(url)\n\nmulti_token_contract_address_string = aelf.get_system_contract_address_string('AElf.ContractNames.Token')\n\n4. create_transaction​\n\nParameters:\n\nto_address - Address or String: target contract’s address\nmethod_name - String: method name\nparams - String: serialize parameters into String\n\nExample:\n\naelf = AElf(url)\n\nparams = Hash()\nparams.value = hashlib.sha256(contract_name.encode('utf8')).digest()\ntransaction = aelf.create_transaction(genesisContractAddress, 'GetContractAddressByName', params.SerializeToString())\n\n5. sign_transaction​\n\nSign a transaction with the user’s private key.\n\nParameters:\n\nprivate_key - String: user’s private key\ntransaction - Transaction: transaction\n\nExample:\n\naelf = AElf(url)\n\nto_address_string = aelf.get_genesis_contract_address_string()\nparams = Hash()\nparams.value = hashlib.sha256(contract_name.encode('utf8')).digest()\ntransaction = aelf.create_transaction(to_address_string, 'GetContractAddressByName', params.SerializeToString())\ntransaction = aelf.sign_transaction(private_key, transaction)\n\n6. get_address_from_public_key​\n\nGenerate an address from a public key.\n\nParameters:\n\npublic_key - bytes: user’s public key\n\nReturns:\n\nAddress\n\nExample:\n\naelf = AElf(url)\naddress = aelf.get_address_from_public_key(public_key)\n\n7. get_address_string_from_public_key​\n\nGenerate an address string from a public key.\n\nParameters:\n\npublic_key - bytes: user’s public key\n\nReturns:\n\nString\n\nExample:\n\naelf = AElf(url)\naddress = aelf.get_address_string_from_public_key(public_key)\n\n8. get_chain_id​\n\nReturns:\n\nNumber\n\nExample:\n\naelf = AElf(url)\n\nchain_id = aelf.get_chain_id()\nprint('# get_chain_id', chain_id)\n\n9. get_formatted_address​\n\nParameters:\n\naddress - Address: address\n\nReturns:\n\nString\n\nExample:\n\naelf = AElf(url)\naddress = aelf.chain.get_system_contract_address(\"AElf.ContractNames.Consensus\")\nformatted_address = aelf.get_formatted_address(address)\nprint('formatted address', formatted_address)\n\n9. is_connected​\n\nCheck whether the node is connected.\n\nExample:\n\naelf = AElf(url)\nis_connected = aelf.is_connected()\n\nTookkits.py​\n\nAElfToolkit Encapsulate AElf and user’s private key. It simplifies the procedures of sending some transactions. You can find it in src/aelf/toolkits.py.\n\nCreate a Toolkit​\n\nCreate a Toolkit with AElfToolkit.\n\nfrom aelf import AElfToolkit\n\n# generate the private key\nprivate_key_string = 'b344570eb80043d7c5ae9800c813b8842660898bf03cbd41e583b4e54af4e7fa'\nprivate_key = PrivateKey(bytes(bytearray.fromhex(private_key_string)))\n\n# create a toolkit\ntoolkit = AElfToolkit('http://127.0.0.1:8000', private_key)\n\nSend a Transaction​\n\nSend a CrossChainTransfer transaction using AElfToolkit.\n\nfrom aelf import AElfToolkit\n\n# generate the private key\nprivate_key_string = 'b344570eb80043d7c5ae9800c813b8842660898bf03cbd41e583b4e54af4e7fa'\nprivate_key = PrivateKey(bytes(bytearray.fromhex(private_key_string)))\n\n# create input, the type is generated by protoc\ncross_chain_transfer_input = CrossChainTransferInput()\n\n# AElfToolkit simplifies this transaction execution.\n# create a toolkit\ntoolkit = AElfToolkit('http://127.0.0.1:8000', private_key)\ntoolkit.cross_chain_transfer(to_address_string, symbol, amount, memo, to_chain_id)\n\nRequirements​\nPython\nDocker\nSupport​\nNode\nAbout Contributing​\n\nRead out [contributing guide].\n\nAbout Version​\n\nhttps://semver.org/\n\nPrevious\nPHP SDK\nNext\naelf Deploy Tool\nIntroduction\nAdding aelf-sdk.py\nExamples\n1. Create an Instance\n2. Get a System Contract Address\n3. Send a Transaction\nWeb API\n1. Get Chain Status\n2. Get Block Height\n3. Get Block\n4. Get Block by Height\n5. Get Transaction Result\n6. Get Transaction Results\n7. Get Transaction Pool Status\n8. Send Transaction\n9. Send Transactions\n10. Get Peers\n11. Add Peer\n12. Remove Peer\n13. Create Raw Transaction\n14. Send Raw Transaction\n15. Execute Raw Transaction\n16. Get Merkle Path\n17. Calculate Transaction Fee\n18. Get Network Info\nAElf.client\n1. get_genesis_contract_address_string\n2. get_system_contract_address\n3. get_system_contract_address_string\n4. create_transaction\n5. sign_transaction\n6. get_address_from_public_key\n7. get_address_string_from_public_key\n8. get_chain_id\n9. get_formatted_address\n9. is_connected\nTookkits.py\nCreate a Toolkit\nSend a Transaction\nRequirements\nSupport\nAbout Contributing\nAbout Version\nPlatform\nTechnology\nAudit Report\nPrivacy\nTerms of Use\nCookie Policy\nDeveloper Resources\nQuick Start\nLearn\nDocs\nTools\nResources\nEcosystem\nOverview\ndApps\naelf Ventures\nBlog\nConnect\nContact Us\nCopyright © 2024 aelf"
    },
    {
      "title": "Smart Contracts Overview | AELF Docs",
      "url": "https://docs.aelf.com/tools/smart-contract-templates/overview/",
      "html": "Skip to main content\nQuick Start\nLearn\nDocs\nTools\nResources\nBlog\nSearch\nTools\nChain SDK\naelf Deploy Tool\naelf CLI\nSmart Contract\nSmart Contracts Overview\nDevelopment Environment\nDeveloping Smart Contracts\nDeploying Contract with BP Approval\nDeploying Contract without BP Approval\naelf Testnet Faucet\naelf Design\naelf Playground\nContract SDK\nToolsSmart ContractSmart Contracts Overview\nSmart Contracts Overview\nSmart Contracts Overview​\n\nThis section helps you learn to write smart contracts. It will take about 40 minutes to complete. Follow the steps and examples to set up your development environment using C# and AElf-developer-tools. You'll learn to develop, test, and deploy/update smart contracts.\n\nThere are two types of smart contract deployment/update:\n\nRequires approval from a BP.\nDoes not require approval.\n\nThe tutorials explain when to use each type.\n\nBlockchain platforms are like a shared database storing the status of all deployed smart contracts. Each smart contract gets a unique address upon deployment. This address is used to check the contract's execution status and acts as an identifier for queries and updates. The contract code details how to verify permissions and complete operations.\n\nDevelopment Steps​\nSet up the development environment.\nDevelop the smart contract.\nTest the smart contract.\nDeploy or update the smart contract.\nDeployment/Update Types​\nWith BP Approval: Needed in certain scenarios.\nWithout BP Approval: Used in other scenarios.\n\nThis overview provides a basic understanding to get started with smart contracts on the AElf platform.\n\nPrevious\nSmart Contract\nNext\nDevelopment Environment\nSmart Contracts Overview\nDevelopment Steps\nDeployment/Update Types\nPlatform\nTechnology\nAudit Report\nPrivacy\nTerms of Use\nCookie Policy\nDeveloper Resources\nQuick Start\nLearn\nDocs\nTools\nResources\nEcosystem\nOverview\ndApps\naelf Ventures\nBlog\nConnect\nContact Us\nCopyright © 2024 aelf"
    },
    {
      "title": "AELF Docs",
      "url": "https://docs.aelf.com/tools/chain-sdk/php-sdk/",
      "html": "Skip to main content\nQuick Start\nLearn\nDocs\nTools\nResources\nBlog\nSearch\nTools\nChain SDK\nJavascript SDK\nC# SDK\nGo SDK\nJAVA SDK\nPHP SDK\nPython SDK\naelf Deploy Tool\naelf CLI\nSmart Contract\naelf Testnet Faucet\naelf Design\naelf Playground\nContract SDK\nToolsChain SDKPHP SDK\naelf-sdk.php - aelf PHP API\nIntroduction​\n\naelf-sdk.php for aelf is similar to web.js for Ethereum. It consists of libraries that enable interaction with a local or remote aelf node via HTTP.\n\nThis documentation will guide you through the installation and usage of aelf-sdk.php, with examples included. For more information, visit the aelf-sdk.php repository.\n\nAdding aelf PHP SDK​\n\nTo install the library via Composer, run the following commands in your console:\n\ncomposer require aelf/aelf-sdk dev-dev\ncomposer require curl/curl\n\n\nIf you cloned the SDK directly, you must install Composer and run it in the root directory:\n\n{\n  \"require\": {\n    \"aelf/aelf-sdk\": \"dev-dev\"\n  }\n}\n\nExamples​\n1. Create an Instance​\n\nCreate a new instance of AElf and connect to an AELF chain node. Using this instance, you can call the AElf APIs.\n\nrequire_once 'vendor/autoload.php';\nuse AElf\\AElf;\n\n$url = 'http://127.0.0.1:8000';\n$aelf = new AElf($url);\n\n2. Get a System Contract Address​\n\nGet a system contract address. For example, to get the address of AElf.ContractNames.Token:\n\nrequire_once 'vendor/autoload.php';\nuse AElf\\AElf;\nuse AElf\\Protobuf\\Generated\\Hash;\n\n$url = 'http://127.0.0.1:8000';\n$aelf = new AElf($url);\n\n$privateKey = 'cd86ab6347d8e52bbbe8532141fc59ce596268143a308d1d40fedf385528b458';\n$bytes = new Hash();\n$bytes->setValue(hex2bin(hash('sha256', 'AElf.ContractNames.Token')));\n$contractAddress = $aelf->GetContractAddressByName($privateKey, $bytes);\n\n3. Send a Transaction​\n\nGet the contract address and then send a transaction.\n\nrequire_once 'vendor/autoload.php';\nuse AElf\\AElf;\nuse BitWasp\\Bitcoin\\Key\\PrivateKeyFactory;\n\n$url = 'http://127.0.0.1:8000';\n$aelf = new AElf($url);\n\n$privateKey = 'cd86ab6347d8e52bbbe8532141fc59ce596268143a308d1d40fedf385528b458';\n$aelfEcdsa = new BitcoinECDSA();\n$aelfEcdsa->setPrivateKey($privateKey);\n$publicKey = $aelfEcdsa->getUncompressedPubKey();\n$address = $aelfEcdsa->hash256(hex2bin($publicKey));\n$address = $address . substr($aelfEcdsa->hash256(hex2bin($address)), 0, 8);\n$base58Address = $aelfEcdsa->base58_encode($address);\n\n$params = new Hash();\n$params->setValue(hex2bin(hash('sha256', 'AElf.ContractNames.Vote')));\n$methodName = \"GetContractAddressByName\";\n$toAddress = $aelf->getGenesisContractAddress();\n\n$transactionObj = $aelf->generateTransaction($base58Address, $toAddress, $methodName, $params);\n$signature = $aelf->signTransaction($privateKey, $transactionObj);\n$transactionObj->setSignature(hex2bin($signature));\n\n$executeTransactionDtoObj = ['RawTransaction' => bin2hex($transactionObj->serializeToString())];\n$result = $aelf->sendTransaction($executeTransactionDtoObj);\nprint_r($result);\n\nWeb API​\n\nYou can access the Web API of your aelf node at:\n\n{chainAddress}/swagger/index.html\n\n\nExample: For a local address: http://127.0.0.1:1235/swagger/index.html\n\nBefore using the methods, make sure you have an instance of AElf:\n\nrequire_once 'vendor/autoload.php';\nuse AElf\\AElf;\n// create a new instance of AElf\n$url = '127.0.0.1:8000';\n$aelf = new AElf($url);\n\n1. Get Chain Status​\n\nAPI Path: /api/blockChain/chainStatus\n\nParameters: None\n\nReturns:\n\nArray\nChainId - String\nBranches - Array\nNotLinkedBlocks - Array\nLongestChainHeight - Integer\nLongestChainHash - String\nGenesisBlockHash - String\nGenesisContractAddress - String\nLastIrreversibleBlockHash - String\nLastIrreversibleBlockHeight - Integer\nBestChainHash - String\nBestChainHeight - Integer\n\nExample :\n\n// create a new instance of AElf\n$aelf = new AElf($url);\n\n$chainStatus = $aelf->getChainStatus();\nprint_r($chainStatus);\n\n2. Get Block Height​\n\nAPI Path: /api/blockChain/blockHeight\n\nParameters: None\n\nReturns: Integer\n\nExample :\n\n$aelf = new AElf($url);\n\n$height = $aelf->getBlockHeight();\nprint($height);\n\n3. getBlock​\n\nAPI Path: /api/blockChain/block\n\nParameters:\n\nblock_hash (String)\ninclude_transactions (Boolean)\n\nReturns:\n\nArray\nBlockHash - String\nHeader - Array\nPreviousBlockHash - String\nMerkleTreeRootOfTransactions - String\nMerkleTreeRootOfWorldState - String\nExtra - List\nHeight - Integer\nTime - String\nChainId - String\nBloom - String\nSignerPubkey - String\nBody - Array\nTransactionsCount - Integer\nTransactions - Array\ntransactionId - String\n\nExample :\n\n$aelf = new AElf($url);\n\n$block = $aelf->getBlockByHeight(1, true);\n$block2 = $aelf->getBlockByHash($block['BlockHash'], false);\nprint_r($block2);\n\n4. Get Block by Height​\n\nAPI Path: /api/blockChain/blockByHeight\n\nParameters:\n\nblock_height (Number)\ninclude_transactions (Boolean)\n\nReturns:\n\nArray\nBlockHash - String\nHeader - Array\nPreviousBlockHash - String\nMerkleTreeRootOfTransactions - String\nMerkleTreeRootOfWorldState - String\nExtra - List\nHeight - Integer\nTime - String\nChainId - String\nBloom - String\nSignerPubkey - String\nBody - Array\nTransactionsCount - Integer\nTransactions - Array\ntransactionId - String\n\nExample :\n\n$aelf = new AElf($url);\n\n$block = $aelf->getBlockByHeight(1, true);\nprint_r($block);\n\n5. Get Transaction Result​\n\nAPI Path: /api/blockChain/transactionResult\n\nParameters:\n\ntransactionId (String)\n\nReturns:\n\nObject\nTransactionId - String\nStatus - String\nLogs - Array\nAddress - String\nName - String\nIndexed - Array\nNonIndexed - String\nBloom - String\nBlockNumber - Integer\nTransaction - Array\nFrom - String\nTo - String\nRefBlockNumber - Integer\nRefBlockPrefix - String\nMethodName - String\nParams - json\nSignature - String\ntransactionId - String\nReadableReturnValue - String\nError - String\n\nExample :\n\n$aelf = new AElf($url);\n\n$block = $aelf->getBlockByHeight(1, true);\n$transactionResult = $aelf->getTransactionResult($block['Body']['Transactions'][0]);\nprint_r($transactionResult);\n\n6. Get Multiple Transaction Results​\n\nAPI Path: /api/blockChain/transactionResults\n\nParameters:\n\nblockHash (String)\noffset (Number)\nlimit (Number)\n\nReturns:\n\nList - The array of method descriptions:\nthe transaction result object\n\nExample :\n\n$aelf = new AElf($url);\n\n$block = $aelf->getBlockByHeight(1, true);\n$transactionResults = $aelf->getTransactionResults($block['Body']);\nprint_r($transactionResults);\n\n7. Get Transaction Pool Status​\n\nAPI Path: /api/blockChain/transactionPoolStatus\n\nExample :\n\n$aelf = new AElf($url);\n\n$status = $aelf->getTransactionPoolStatus();\nprint_r($status);\n\n8. Send Transaction​\n\nAPI Path: /api/blockChain/sendTransaction\n\nMethod: POST\n\nParameters:\n\ntransaction (String)\n\nExample :\n\n$params = new Hash();\n$params->setValue(hex2bin(hash('sha256', 'AElf.ContractNames.Vote')));\n$transaction = buildTransaction($aelf->getGenesisContractAddress(), 'GetContractAddressByName', $params);\n$executeTransactionDtoObj = ['RawTransaction' => bin2hex($transaction->serializeToString())];\n$result = $aelf->sendTransaction($executeTransactionDtoObj);\nprint_r($result);\n\n9. Send Multiple Transactions​\n\nAPI Path: /api/blockChain/sendTransactions\n\nMethod:POST\n\nParameters:\n\ntransactions (String)\n\nExample :\n\n$aelf = new AElf($url);\n\n$paramsList = [$params1, $params2];\n$rawTransactionsList = [];\nforeach ($paramsList as $param) {\n    $transactionObj = buildTransaction($toAddress, $methodName, $param);\n    $rawTransactions = bin2hex($transactionObj->serializeToString());\n    array_push($rawTransactionsList, $rawTransactions);\n}\n$sendTransactionsInputs = ['RawTransactions' => implode(',', $rawTransactionsList)];\n$listString = $aelf->sendTransactions($sendTransactionsInputs);\nprint_r($listString);\n\n10. Get Peers​\n\nAPI Path: /api/net/peers\n\nExample :\n\nprint_r($aelf->getPeers(true));\n\n11. Add Peer​\n\nAPI Path: /api/net/peer\n\nMethod: POST\n\nParameters:\n\npeer_address (String)\n\nExample :\n\n$aelf->addPeer($url);\n\n12. Remove Peer​\n\nAPI Path: /api/net/peer\n\nParameters:\n\npeer_address (String)\n\nExample :\n\n$aelf->removePeer($url);\n\n13. Create Raw Transaction​\n\nAPI Path: /api/blockchain/rawTransaction\n\nMethod: POST\n\nParameters:\n\ntransaction (Array)\n\nReturns:\n\nArray\nRawTransaction - hex string bytes generated by transaction information\n\nExample :\n\n$aelf = new AElf($url);\n\n$status = $aelf->getChainStatus();\n$params = base64_encode(hex2bin(hash('sha256', 'AElf.ContractNames.Consensus')));\n$param = array('value' => $params);\n$transaction = [\n    \"from\" => $aelf->getAddressFromPrivateKey($privateKey),\n    \"to\" => $aelf->getGenesisContractAddress(),\n    \"refBlockNumber\" => $status['BestChainHeight'],\n    \"refBlockHash\" => $status['BestChainHash'],\n    \"methodName\" => \"GetContractAddressByName\",\n    \"params\" => json_encode($param)\n];\n$rawTransaction = $aelf->createRawTransaction($transaction);\nprint_r($rawTransaction);\n\n14. Send Raw Transaction​\n\nAPI Path: /api/blockchain/sendRawTransaction\n\nParameters:\n\nTransaction (raw transaction)\nSignature (signature)\nReturnTransaction (indicates whether to return transaction)\n\nExample :\n\n$aelf = new AElf($url);\n\n$rawTransaction = $aelf->createRawTransaction($transaction);\n$transactionId = hash('sha256', hex2bin($rawTransaction['RawTransaction']));\n$sign = $aelf->getSignatureWithPrivateKey($privateKey, $transactionId);\n$transaction = array('Transaction' => $rawTransaction['RawTransaction'], 'signature' => $sign, 'returnTransaction' => true);\n$execute = $aelf->sendRawTransaction($transaction);\nprint_r($execute);\n\n15. Execute Raw Transaction​\n\nAPI Path: /api/blockchain/executeRawTransaction\n\nMethod: POST\n\nParameters:\n\nRawTransaction (raw transaction)\nSignature (signature)\n\nExample :\n\n$aelf = new AElf($url);\n\n$rawTransaction = $aelf->createRawTransaction($transaction);\n$transactionId = hash('sha256', hex2bin($rawTransaction['RawTransaction']));\n$sign = $aelf->getSignatureWithPrivateKey($privateKey, $transactionId);\n$transaction = array('RawTransaction' => $rawTransaction['RawTransaction'], 'signature' => $sign);\n$execute = $aelf->executeRawTransaction($transaction);\nprint_r($execute);\n\n16. Get Merkle Path by Transaction ID​\n\nAPI Path: /api/blockchain/merklePathByTransactionId\n\nParameters:\n\ntransactionId (String)\n\nExample :\n\n$aelf = new AElf($url);\n\n$block = $aelf->getBlockByHeight(1, true);\n$merklePath = $aelf->getMerklePathByTransactionId($block['Body']['Transactions'][0]);\nprint_r($merklePath);\n\n17. Calculate Transaction Fee​\n\nAPI Path: /api/blockChain/calculateTransactionFee\n\nMethod: POST\n\nParameters:\n\nCalculateTransactionFeeInput (Object)\n\nReturns:\n\nCalculateTransactionFeeOutput (Object)\n\nSuccess - bool\nTransactionFee - Array\nResourceFee - Array\n\nExample :\n\n$aelf = new AElf($url);\n\n$calculateTransactionFeeInputParam = [\n    \"rawTransaction\" => $rawTransactionInput,\n];\n$result = $aelf->calculateTransactionFee($calculateTransactionFeeInputParam);\nprint_r($result);\n\n18. Get Network Info​\n\nAPI Path: /api/net/networkInfo\n\nExample :\n\n$aelf = new AElf($url);\n\nprint_r($aelf->getNetworkInfo());\n\n19. Get Contract File Descriptor Set​\n\nAPI Path: /api/blockchain/contractFileDescriptorSet\n\nExample :\n\n$aelf = new AElf($url);\n\n$blockDto = $aelf->getBlockByHeight($blockHeight, false);\n$transactionResultDtoList = $aelf->getTransactionResults($blockDto['BlockHash'], 0, 10);\nforeach ($transactionResultDtoList as $v) {\n  $request = $aelf->getContractFileDescriptorSet($v['Transaction']['To']);\n  print_r($request);\n}\n\n20. Get Task Queue Status​\n\nAPI Path: /api/blockchain/taskQueueStatus\n\nExample :\n\n$aelf = new AElf($url);\n\n$taskQueueStatus = $aelf->getTaskQueueStatus();\nprint_r($taskQueueStatus);\n\n21. Execute Transaction​\n\nAPI Path: /api/blockchain/executeTransaction\n\nExample :\n\n$aelf = new AElf($url);\n\n$methodName = \"GetNativeTokenInfo\";\n$bytes = new Hash();\n$bytes->setValue(hex2bin(hash('sha256', 'AElf.ContractNames.Token')));\n$toAddress = $aelf->GetContractAddressByName($privateKey, $bytes);\n$param = new Hash();\n$param->setValue('');\n$transaction = $aelf->generateTransaction($fromAddress, $toAddress, $methodName, $param);\n$signature = $aelf->signTransaction($privateKey, $transaction);\n$transaction->setSignature(hex2bin($signature));\n$executeTransactionDtoObj = ['RawTransaction' => bin2hex($transaction->serializeToString())];\n$response = $aelf->executeTransaction($executeTransactionDtoObj);\n$tokenInfo = new TokenInfo();\n$tokenInfo->mergeFromString(hex2bin($response));\n\nOther Tool Kit​\n\naelf supplies some APIs to simplify development.\n\n1. Get Chain Id​\n$aelf = new AElf($url);\n\n$chainId = $aelf->getChainId();\nprint_r($chainId);\n\n2. Generate Transaction​\n$aelf = new AElf($url);\n\n$param = new Hash();\n$param->setValue('');\n$transaction = $aelf->generateTransaction($fromAddress, $toAddress, $methodName, $param);\n\n3. Sign Transaction​\n$aelf = new AElf($url);\n\n$transaction = $aelf->generateTransaction($fromAddress, $toAddress, $methodName, $param);\n$signature = $aelf->signTransaction($privateKey, $transaction);\n\n4. Get Genesis Contract Address​\n$aelf = new AElf($url);\n\n$genesisContractAddress = $aelf->getGenesisContractAddress();\nprint_r($genesisContractAddress);\n\n5. Get Address From PubKey​\n\nCalculate the account address according to the public key.\n\n$aelf = new AElf($url);\n\n$pubKeyAddress = $aelf->getAddressFromPubKey('04166cf4be901dee1c21f3d97b9e4818f229bec72a5ecd56b5c4d6ce7abfc3c87e25c36fd279db721acf4258fb489b4a4406e6e6e467935d06990be9d134e5741c');\nprint_r($pubKeyAddress);\n\n6. Get Formatted Address​\n\nConvert the address to the displayed string: symbol_base58-string_base58-string_chain_id.\n\n$aelf = new AElf($url);\n\n$addressVal = $aelf->getFormattedAddress($privateKey, $base58Address);\nprint_r($addressVal);\n\n7. Generate Key Pair Info​\n\nGenerate a new key pair using ECDSA.\n\n$aelf = new AElf($url);\n\n$pairInfo = $aelf->generateKeyPairInfo();\nprint_r($pairInfo);\n\n8. Get Contract Address By Name​\n$aelf = new AElf($url);\n\n$bytes = new Hash();\n$bytes->setValue(hex2bin(hash('sha256', 'AElf.ContractNames.Token')));\n$contractAddress = $aelf->GetContractAddressByName($privateKey, $bytes);\nprint_r($contractAddress);\n\n9. Get Address From Private Key​\n$aelf = new AElf($url);\n\n$address = $aelf->getAddressFromPrivateKey($privateKey);\nprint_r($address);\n\n10. Get Signature With Private Key​\n$aelf = new AElf($url);\n\n$sign = $aelf->getSignatureWithPrivateKey($privateKey, $transactionId);\nprint_r($sign);\n\n11. Is Connected​\n$aelf = new AElf($url);\n\n$isConnected = $this->aelf->isConnected();\nprint_r($isConnected);\n\n12. Get Transaction Fees​\n\nGet the transaction fee from the transaction result.\n\n$aelf = new AElf($url);\n\n$block = $aelf->getBlockByHeight(1, true);\n$transactionResult = $aelf->getTransactionResult($block['Body']['Transactions'][0]);\n$transactionFees = $aelf->getTransactionFees($transactionResult);\nprint_r($transactionFees);\n\nAElf.version​\nCopy code\n$aelf = new AElf($url);\n\n$version = $aelf->version;\n\nRequirements​\nphp\nAbout contributing​\n\nRead out [contributing guide]\n\nAbout Version​\n\nhttps://semver.org/\n\nPrevious\nJAVA SDK\nNext\nPython SDK\nIntroduction\nAdding aelf PHP SDK\nExamples\n1. Create an Instance\n2. Get a System Contract Address\n3. Send a Transaction\nWeb API\n1. Get Chain Status\n2. Get Block Height\n3. getBlock\n4. Get Block by Height\n5. Get Transaction Result\n6. Get Multiple Transaction Results\n7. Get Transaction Pool Status\n8. Send Transaction\n9. Send Multiple Transactions\n10. Get Peers\n11. Add Peer\n12. Remove Peer\n13. Create Raw Transaction\n14. Send Raw Transaction\n15. Execute Raw Transaction\n16. Get Merkle Path by Transaction ID\n17. Calculate Transaction Fee\n18. Get Network Info\n19. Get Contract File Descriptor Set\n20. Get Task Queue Status\n21. Execute Transaction\nOther Tool Kit\n1. Get Chain Id\n2. Generate Transaction\n3. Sign Transaction\n4. Get Genesis Contract Address\n5. Get Address From PubKey\n6. Get Formatted Address\n7. Generate Key Pair Info\n8. Get Contract Address By Name\n9. Get Address From Private Key\n10. Get Signature With Private Key\n11. Is Connected\n12. Get Transaction Fees\nAElf.version\nRequirements\nAbout contributing\nAbout Version\nPlatform\nTechnology\nAudit Report\nPrivacy\nTerms of Use\nCookie Policy\nDeveloper Resources\nQuick Start\nLearn\nDocs\nTools\nResources\nEcosystem\nOverview\ndApps\naelf Ventures\nBlog\nConnect\nContact Us\nCopyright © 2024 aelf"
    },
    {
      "title": "AELF Docs",
      "url": "https://docs.aelf.com/tools/chain-sdk/java-sdk/",
      "html": "Skip to main content\nQuick Start\nLearn\nDocs\nTools\nResources\nBlog\nSearch\nTools\nChain SDK\nJavascript SDK\nC# SDK\nGo SDK\nJAVA SDK\nPHP SDK\nPython SDK\naelf Deploy Tool\naelf CLI\nSmart Contract\naelf Testnet Faucet\naelf Design\naelf Playground\nContract SDK\nToolsChain SDKJAVA SDK\naelf-sdk.java - aelf Java API\nIntroduction​\n\naelf-sdk.java is a set of libraries that allow interaction with a local or remote aelf node using an HTTP connection. This documentation guides you through installing and running aelf-sdk.java, along with providing API reference documentation and examples.\n\nFor more information, you can check out the repository.\n\nAdding aelf-sdk.java Package​\n\nTo add the aelf-sdk.java package to your project, use the following Maven dependency:\n\n<!-- https://mvnrepository.com/artifact/io.aelf/aelf-sdk -->\n<dependency>\n    <groupId>io.aelf</groupId>\n    <artifactId>aelf-sdk</artifactId>\n    <version>0.X.X</version>\n</dependency>\n\nExamples​\nCreate Instance​\n\nCreate a new instance of AElfClient, and set the URL of an aelf chain node.\n\nimport AElf.Client.Service;\n\n// Create a new instance of AElfClient, change the URL if needed\nAElfClient client = new AElfClient(\"http://127.0.0.1:1235\");\n\nTest Connection​\n\nCheck if the aelf chain node is connectable.\n\nboolean isConnected = client.isConnected();\n\nInitiate a Transfer Transaction​\n// Get token contract address.\nString tokenContractAddress = client.getContractAddressByName(privateKey, Sha256.getBytesSha256(\"AElf.ContractNames.Token\"));\n\nClient.Address.Builder to = Client.Address.newBuilder();\nto.setValue(ByteString.copyFrom(Base58.decodeChecked(\"7s4XoUHfPuqoZAwnTV7pHWZAaivMiL8aZrDSnY9brE1woa8vz\")));\nClient.Address toObj = to.build();\n\nTokenContract.TransferInput.Builder paramTransfer = TokenContract.TransferInput.newBuilder();\nparamTransfer.setTo(toObj);\nparamTransfer.setSymbol(\"ELF\");\nparamTransfer.setAmount(1000000000);\nparamTransfer.setMemo(\"transfer in demo\");\nTokenContract.TransferInput paramTransferObj = paramTransfer.build();\n\nString ownerAddress = client.getAddressFromPrivateKey(privateKey);\n\nTransaction.Builder transactionTransfer = client.generateTransaction(ownerAddress, tokenContractAddress, \"Transfer\", paramTransferObj.toByteArray());\nTransaction transactionTransferObj = transactionTransfer.build();\ntransactionTransfer.setSignature(ByteString.copyFrom(ByteArrayHelper.hexToByteArray(client.signTransaction(privateKey, transactionTransferObj))));\ntransactionTransferObj = transactionTransfer.build();\n\n// Send the transfer transaction to aelf chain node.\nSendTransactionInput sendTransactionInputObj = new SendTransactionInput();\nsendTransactionInputObj.setRawTransaction(Hex.toHexString(transactionTransferObj.toByteArray()));\nSendTransactionOutput sendResult = client.sendTransaction(sendTransactionInputObj);\n\nThread.sleep(4000);\n// After the transaction is mined, query the execution results.\nTransactionResultDto transactionResult = client.getTransactionResult(sendResult.getTransactionId());\nSystem.out.println(transactionResult.getStatus());\n\n// Query account balance.\nClient.Address.Builder owner = Client.Address.newBuilder();\nowner.setValue(ByteString.copyFrom(Base58.decodeChecked(ownerAddress)));\nClient.Address ownerObj = owner.build();\n\nTokenContract.GetBalanceInput.Builder paramGetBalance = TokenContract.GetBalanceInput.newBuilder();\nparamGetBalance.setSymbol(\"ELF\");\nparamGetBalance.setOwner(ownerObj);\nTokenContract.GetBalanceInput paramGetBalanceObj = paramGetBalance.build();\n\nTransaction.Builder transactionGetBalance = client.generateTransaction(ownerAddress, tokenContractAddress, \"GetBalance\", paramGetBalanceObj.toByteArray());\nTransaction transactionGetBalanceObj = transactionGetBalance.build();\nString signature = client.signTransaction(privateKey, transactionGetBalanceObj);\ntransactionGetBalance.setSignature(ByteString.copyFrom(ByteArrayHelper.hexToByteArray(signature)));\ntransactionGetBalanceObj = transactionGetBalance.build();\n\nExecuteTransactionDto executeTransactionDto = new ExecuteTransactionDto();\nexecuteTransactionDto.setRawTransaction(Hex.toHexString(transactionGetBalanceObj.toByteArray()));\nString transactionGetBalanceResult = client.executeTransaction(executeTransactionDto);\n\nTokenContract.GetBalanceOutput balance = TokenContract.GetBalanceOutput.getDefaultInstance().parseFrom(ByteArrayHelper.hexToByteArray(transactionGetBalanceResult));\nSystem.out.println(balance.getBalance());\n\n\nThis guide provides basic steps to interact with an aelf node using the aelf-sdk.java library. For more detailed information and advanced usage, please refer to the repository documentation.\n\nWeb API​\n\nYou can see how the Web API of the node works at {chainAddress}/swagger/index.html. For example, if you are using a local address, it would be: http://127.0.0.1:1235/swagger/index.html.\n\nThe usage of these methods is based on the AElfClient instance. So, if you don’t have one, please create it:\n\nimport AElf.Client.Service;\n\n// Create a new instance of AElfClient, change the URL if needed\nAElfClient client = new AElfClient(\"http://127.0.0.1:1235\");\n\nGetChainStatus​\n\nGet the current status of the blockchain.\n\nWeb API path: /api/blockChain/chainStatus\n\nParameters: None\n\nReturns: ChainStatusDto\n\nChainId - String\nBranches - HashMap <String, Long>\nNotLinkedBlocks - HashMap <String, String>\nLongestChainHeight - long\nLongestChainHash - String\nGenesisBlockHash - String\nGenesisContractAddress - String\nLastIrreversibleBlockHash - String\nLastIrreversibleBlockHeight - long\nBestChainHash - String\nBestChainHeight - long\n\nExample:\n\nclient.getChainStatus();\n\nGetContractFileDescriptorSet​\n\nGet the protobuf definitions related to a contract.\n\nWeb API path: /api/blockChain/contractFileDescriptorSet\n\nParameters:\n\ncontractAddress - String (address of a contract)\n\nReturns: byte[]\n\nExample:\n\nclient.getContractFileDescriptorSet(address);\n\nGetBlockHeight​\n\nGet the current best height of the chain.\n\nWeb API path: /api/blockChain/blockHeight\n\nParameters:: None\n\nReturns: long\n\nExample:\n\nclient.getBlockHeight();\n\nGetBlock​\n\nGet block information by block hash.\n\nWeb API path: /api/blockChain/block\n\nParameters:\n\nblockHash - String\nincludeTransactions - boolean (true to include transaction ids list in the block, false otherwise)\n\nReturns:\n\nBlockDto\nBlockHash - String\nHeader - BlockHeaderDto\nPreviousBlockHash - String\nMerkleTreeRootOfTransactions - String\nMerkleTreeRootOfWorldState - String\nExtra - String\nHeight - long\nTime - Date\nChainId - String\nBloom - String\nSignerPubkey - String\nBody - BlockBodyDto\nTransactionsCount - int\nTransactions - List\ntransactionId - String\n\nExample:\n\nclient.getBlockByHash(blockHash);\n\nGetBlockByHeight​\n\nWeb API path: /api/blockChain/blockByHeight\n\nParameters:\n\nblockHeight - long\nincludeTransactions - boolean (true to include transaction ids list in the block, false otherwise)\n\nReturns:\n\nBlockDto\nBlockHash - String\nHeader - BlockHeaderDto\nPreviousBlockHash - String\nMerkleTreeRootOfTransactions - String\nMerkleTreeRootOfWorldState - String\nExtra - String\nHeight - long\nTime - Date\nChainId - String\nBloom - String\nSignerPubkey - String\nBody - BlockBodyDto\nTransactionsCount - int\nTransactions - List\ntransactionId - String\n\nExample:\n\nclient.getBlockByHeight(height);\n\nGetTransactionResult​\n\nWeb API path: /api/blockChain/transactionResult\n\nParameters:\n\ntransactionId - String\n\nReturns: TransactionResultDto\n\njson\nTransactionId - String\nStatus - String\nLogs - List\nAddress - String\nName - String\nIndexed - List\nNonIndexed - String\nBloom - String\nBlockNumber - Number\nTransaction - List\nFrom - String\nTo - String\nRefBlockNumber - Number\nRefBlockPrefix - String\nMethodName - String\nParams - json\nSignature - String\nReadableReturnValue - json\nError - String\n\nExample:\n\nclient.getTransactionResult(transactionId);\n\nGetTransactionResults​\n\nWeb API path: /api/blockChain/transactionResults\n\nParameters:\n\nblockHash - String\noffset - int\nlimit - int\n\nReturns: List<TransactionResultDto> - The array of transaction results\n\nExample:\n\nclient.getTransactionResults(blockHash, 0, 10);\n\nGetTransactionPoolStatus​\n\nWeb API path: /api/blockChain/transactionPoolStatus\n\nParameters:: None\n\nReturns:\n\nTransactionPoolStatusOutput\nQueued - int\nValidated - int\n\nExample:\n\nclient.getTransactionPoolStatus();\n\nSendTransaction​\n\nWeb API path: /api/blockChain/sendTransaction\n\nMethod: POST\n\nParameters:\n\nSendTransactionInput - Serialization of data into protobuf format:\nRawTransaction - String\n\nReturns:\n\nSendTransactionOutput\nTransactionId - String\n\nExample:\n\nclient.sendTransaction(input);\n\nSendRawTransaction​\n\nWeb API path: /api/blockChain/sendTransaction\n\nMethod: POST\n\nParameters:\n\nSendRawTransactionInput - Serialization of data into protobuf format:\nTransaction - String\nSignature - String\nReturnTransaction - boolean\n\nReturns:\n\nSendRawTransactionOutput\nTransactionId - String\nTransaction - TransactionDto\n\nExample:\n\nclient.sendRawTransaction(input);\n\nSendTransactions​\n\nBroadcast multiple transactions.\n\nWeb API path: /api/blockChain/sendTransactions\n\nMethod: POST\n\nParameters:\n\nSendTransactionsInput - Serialization of data into protobuf format:\nRawTransactions - String\n\nReturns: List<String>\n\nExample:\n\nclient.sendTransactions(input);\n\nCreateRawTransaction​\n\nCreate an unsigned serialized transaction.\n\nWeb API path: /api/blockChain/rawTransaction\n\nMethod: POST\n\nParameters:\n\nCreateRawTransactionInput\nFrom - String\nTo - String\nRefBlockNumber - long\nRefBlockHash - String\nMethodName - String\nParams - String\n\nReturns:\n\nCreateRawTransactionOutput - Serialization of data into protobuf format:\nRawTransaction - String\n\nExample:\n\nclient.createRawTransaction(input);\n\nExecuteTransaction​\n\nWeb API path: /api/blockChain/executeTransaction\n\nMethod: POST\n\nParameters:\n\nExecuteTransactionDto - Serialization of data into protobuf format:\nRawTransaction - String\n\nReturns: String\n\nExample:\n\nclient.executeTransaction(input);\n\nExecuteRawTransaction​\n\nWeb API path: /api/blockChain/executeRawTransaction\n\nMethod: POST\n\nParameters:\n\nExecuteRawTransactionDto - Serialization of data into protobuf format:\nRawTransaction - String\nSignature - String\n\nReturns: String\n\nExample:\n\nclient.executeRawTransaction(input);\n\nGetPeers​\n\nGet peer information about the connected network nodes.\n\nWeb API path: /api/net/peers\n\nParameters:\n\nwithMetrics - boolean\n\nReturns:\n\nList<PeerDto>\nIpAddress - String\nProtocolVersion - int\nConnectionTime - long\nConnectionStatus - String\nInbound - boolean\nBufferedTransactionsCount - int\nBufferedBlocksCount - int\nBufferedAnnouncementsCount - int\nNodeVersion - String\nRequestMetrics - List<RequestMetric>\nRoundTripTime - long\nMethodName - String\nInfo - String\nRequestTime - String\n\nExample:\n\nclient.getPeers(false);\n\nAddPeer​\n\nAttempts to add a node to the connected network nodes.\n\nWeb API path: /api/net/peer\n\nMethod: POST\n\nParameters:\n\nAddPeerInput\nAddress - String\n\nReturns: boolean\n\nExample:\n\nclient.addPeer(\"127.0.0.1:7001\");\n\nRemovePeer​\n\nAttempts to remove a node from the connected network nodes.\n\nWeb API path: /api/net/peer\n\nMethod: DELETE\n\nParameters:\n\nAddress - String\n\nReturns: boolean\n\nExample:\n\nclient.removePeer(\"127.0.0.1:7001\");\n\nCalculateTransactionFee​\n\nEstimate transaction fee.\n\nWeb API path: /api/blockChain/calculateTransactionFee\n\nMethod: POST\n\nParameters:\n\nCalculateTransactionFeeInput\nRawTransaction - String\n\nReturns:\n\nCalculateTransactionFeeOutput\nSuccess - boolean\nTransactionFee - HashMap<String, Long>\nResourceFee - HashMap<String, Long>\n\nExample:\n\nCalculateTransactionFeeOutput output = client.calculateTransactionFee(input);\n\nGetNetworkInfo​\n\nWeb API path: /api/net/networkInfo\n\nParameters: None\n\nReturns:\n\nNetworkInfoOutput\nVersion - String\nProtocolVersion - int\nConnections - int\n\nExample:\n\nclient.getNetworkInfo();\n\nAElf Client​\nIsConnected​\n\nVerify whether this SDK successfully connects to the chain.\n\nParameters: None\n\nReturns: boolean\n\nExample:\n\nclient.isConnected();\n\nGetGenesisContractAddress​\n\nParameters: None\n\nReturns: String\n\nExample:\n\nclient.getGenesisContractAddress();\n\nGetContractAddressByName​\n\nGet the address of a contract by the given contract name hash.\n\nParameters::\n\nprivateKey - String\ncontractNameHash - byte[]\n\nReturns: String\n\nExample:\n\nclient.getContractAddressByName(privateKey, contractNameHash);\n\nGenerateTransaction​\n\nBuild a transaction from the input parameters.\n\nParameters:\n\nfrom - String\nto - String\nmethodName - String\ninput - byte[]\n\nReturns: Transaction\n\nExample:\n\nclient.generateTransaction(from, to, methodName, input);\n\nGetFormattedAddress​\n\nConvert the Address to the displayed string: symbol_base58-string_base58-String-chain-id.\n\nParameters:\n\nprivateKey - String\naddress - String\n\nReturns: String\n\nExample:\n\nclient.getFormattedAddress(privateKey, address);\n\nSignTransaction​\n\nParameters:\n\nprivateKeyHex - String\ntransaction - Transaction\n\nReturns: String\n\nExample:\n\nclient.signTransaction(privateKeyHex, transaction);\n\nGetAddressFromPubKey​\n\nParameters:\n\npubKey - String\n\nReturns: String\n\nExample:\n\nclient.getAddressFromPubKey(pubKey);\n\nGetAddressFromPrivateKey​\n\nParameters:\n\nprivateKey - String\n\nReturns: String\n\nExample:\n\nclient.getAddressFromPrivateKey(privateKey);\n\nGenerateKeyPairInfo​\n\nParameters: None\n\nReturns:\n\nKeyPairInfo\n\nPrivateKey - String\nPublicKey - String\nAddress - String\n\nExample:\n\nclient.generateKeyPairInfo();\n\nSupports​\nJDK1.8+\nLog4j2.6.2\nPrevious\nGo SDK\nNext\nPHP SDK\nIntroduction\nAdding aelf-sdk.java Package\nExamples\nCreate Instance\nTest Connection\nInitiate a Transfer Transaction\nWeb API\nGetChainStatus\nGetContractFileDescriptorSet\nGetBlockHeight\nGetBlock\nGetBlockByHeight\nGetTransactionResult\nGetTransactionResults\nGetTransactionPoolStatus\nSendTransaction\nSendRawTransaction\nSendTransactions\nCreateRawTransaction\nExecuteTransaction\nExecuteRawTransaction\nGetPeers\nAddPeer\nRemovePeer\nCalculateTransactionFee\nGetNetworkInfo\nAElf Client\nIsConnected\nGetGenesisContractAddress\nGetContractAddressByName\nGenerateTransaction\nGetFormattedAddress\nSignTransaction\nGetAddressFromPubKey\nGetAddressFromPrivateKey\nGenerateKeyPairInfo\nSupports\nPlatform\nTechnology\nAudit Report\nPrivacy\nTerms of Use\nCookie Policy\nDeveloper Resources\nQuick Start\nLearn\nDocs\nTools\nResources\nEcosystem\nOverview\ndApps\naelf Ventures\nBlog\nConnect\nContact Us\nCopyright © 2024 aelf"
    },
    {
      "title": "AELF Docs",
      "url": "https://docs.aelf.com/tools/chain-sdk/csharp-sdk/",
      "html": "Skip to main content\nQuick Start\nLearn\nDocs\nTools\nResources\nBlog\nSearch\nTools\nChain SDK\nJavascript SDK\nC# SDK\nGo SDK\nJAVA SDK\nPHP SDK\nPython SDK\naelf Deploy Tool\naelf CLI\nSmart Contract\naelf Testnet Faucet\naelf Design\naelf Playground\nContract SDK\nToolsChain SDKC# SDK\naelf-sdk.cs - aelf C# API\n\naelf-sdk.cs is a C# library that facilitates communication with an aelf node over HTTP. Below is a comprehensive guide on how to install and use the aelf-sdk.cs package, along with some example usages.\n\nIntroduction​\n\naelf-sdk.cs is a collection of libraries designed for interaction with both local and remote aelf nodes via HTTP connections. This documentation provides instructions on how to install and run aelf-sdk.cs, and includes API reference documentation with examples. aelf-sdk.cs\n\nAdding aelf-sdk.cs package​\n\nTo use aelf-sdk.cs, you need to add the AElf.Client package to your project. This can be done using various methods:\n\nUsing Package Manager​\n\nOpen the Package Manager Console in Visual Studio and run:\n\nPM> Install-Package AElf.Client\n\nUsing .NET CLI​\n\nRun the following command in your terminal:\n\ndotnet add package AElf.Client\n\nUsing PackageReference​\n\nAdd the following line to your .csproj file:\n\n<PackageReference Include=\"AElf.Client\" Version=\"X.X.X\" />\n\n\nReplace X.X.X with the desired version of the AElf.Client package.\n\nExamples​\n1. Create Instance​\n\nCreate a new instance of AElfClient and set the URL of an aelf chain node.\n\nusing AElf.Client.Service;\n\n// Create a new instance of AElfClient\nAElfClient client = new AElfClient(\"http://127.0.0.1:1235\");\n\n2. Test Connection​\n\nCheck that the aelf chain node is connectable.\n\nvar isConnected = await client.IsConnectedAsync();\nConsole.WriteLine($\"Connected: {isConnected}\");\n\n3. Initiate a Transfer Transaction​\n// Get token contract address.\nvar tokenContractAddress = await client.GetContractAddressByNameAsync(HashHelper.ComputeFrom(\"AElf.ContractNames.Token\"));\n\nvar methodName = \"Transfer\";\nvar param = new TransferInput\n{\n    To = new Address {Value = Address.FromBase58(\"7s4XoUHfPuqoZAwnTV7pHWZAaivMiL8aZrDSnY9brE1woa8vz\").Value},\n    Symbol = \"ELF\",\n    Amount = 1000000000,\n    Memo = \"transfer in demo\"\n};\nvar ownerAddress = client.GetAddressFromPrivateKey(PrivateKey);\n\n// Generate a transfer transaction.\nvar transaction = await client.GenerateTransaction(ownerAddress, tokenContractAddress.ToBase58(), methodName, param);\nvar txWithSign = client.SignTransaction(PrivateKey, transaction);\n\n// Send the transfer transaction to AElf chain node.\nvar result = await client.SendTransactionAsync(new SendTransactionInput\n{\n    RawTransaction = txWithSign.ToByteArray().ToHex()\n});\n\nawait Task.Delay(4000);\n// After the transaction is mined, query the execution results.\nvar transactionResult = await client.GetTransactionResultAsync(result.TransactionId);\nConsole.WriteLine(transactionResult.Status);\n\n// Query account balance.\nvar paramGetBalance = new GetBalanceInput\n{\n    Symbol = \"ELF\",\n    Owner = new Address {Value = Address.FromBase58(ownerAddress).Value}\n};\nvar transactionGetBalance =await client.GenerateTransaction(ownerAddress, tokenContractAddress.ToBase58(), \"GetBalance\", paramGetBalance);\nvar txWithSignGetBalance = client.SignTransaction(PrivateKey, transactionGetBalance);\n\nvar transactionGetBalanceResult = await client.ExecuteTransactionAsync(new ExecuteTransactionDto\n{\n    RawTransaction = txWithSignGetBalance.ToByteArray().ToHex()\n});\n\nvar balance = GetBalanceOutput.Parser.ParseFrom(ByteArrayHelper.HexstringToByteArray(transactionGetBalanceResult));\nConsole.WriteLine(balance.Balance);\n\nWeb API​\n\nYou can see how the Web API of the node works at {chainAddress}/swagger/index.html. For example, on a local address: http://127.0.0.1:1235/swagger/index.html.\n\nHere are the examples and code snippets for interacting with the aelf Web API using the AElfClient instance.\n\n1. Create Instance​\n\nCreate a new instance of AElfClient and set the URL of an aelf chain node.\n\nusing AElf.Client.Service;\n\n// Create a new instance of AElfClient, change the URL if needed\nAElfClient client = new AElfClient(\"http://127.0.0.1:1235\");\n\n2. Get Chain Status​\n\nWeb API path: /api/blockChain/chainStatus\n\nParameters : None\n\nReturns: ChainStatusDto\n\nChainId - string\nBranches - Dictionary<string,long>\nNotLinkedBlocks - Dictionary<string,string>\nLongestChainHeight - long\nLongestChainHash - string\nGenesisBlockHash - string\nGenesisContractAddress - string\nLastIrreversibleBlockHash - string\nLastIrreversibleBlockHeight - long\nBestChainHash - string\nBestChainHeight - long\nExample:​\nawait client.GetChainStatusAsync();\n\n3. Get Contract File Descriptor Set​\n\nWeb API path: /api/blockChain/contractFileDescriptorSet\n\nParameters :\n\ncontractAddress - string\n\nReturns: []byte\n\nExample:​\nawait client.GetContractFileDescriptorSetAsync(address);\n\n4. Get Block Height​\n\nWeb API path: /api/blockChain/blockHeight\n\nParameters : None\n\nReturns: long\n\nExample:​\nawait client.GetBlockHeightAsync();\n\n5. Get Block Information by Block Hash​\n\nWeb API path: /api/blockChain/block\n\nParameters :\n\nblockHash - string\nincludeTransactions - bool\n\nReturns: BlockDto\n\nBlockHash - string\nHeader - BlockHeaderDto\nPreviousBlockHash - string\nMerkleTreeRootOfTransactions - string\nMerkleTreeRootOfWorldState - string\nExtra - string\nHeight - long\nTime - string\nChainId - string\nBloom - string\nSignerPubkey - string\nBody - BlockBodyDto\nTransactionsCount - int\nTransactions - []string\nExample:​\nawait client.GetBlockByHashAsync(blockHash);\n\n6. Get Block Information by Block Height​\n\nWeb API path: /api/blockChain/blockByHeight\n\nParameters :\n\nblockHeight - long\nincludeTransactions - bool\n\nReturns: BlockDto\n\nBlockHash - string\nHeader - BlockHeaderDto\nPreviousBlockHash - string\nMerkleTreeRootOfTransactions - string\nMerkleTreeRootOfWorldState - string\nExtra - string\nHeight - long\nTime - string\nChainId - string\nBloom - string\nSignerPubkey - string\nBody - BlockBodyDto\nTransactionsCount - int\nTransactions - []string\nExample:​\nawait client.GetBlockByHeightAsync(height);\n\n7. Get Transaction Result​\n\nWeb API path: /api/blockChain/transactionResult\n\nParameters :\n\ntransactionId - string\n\nReturns: TransactionResultDto\n\nTransactionId - string\nStatus - string\nLogs - []LogEventDto\nAddress - string\nName - string\nIndexed - []string\nNonIndexed - string\nBloom - string\nBlockNumber - long\nBlockHash - string\nTransaction - TransactionDto\nFrom - string\nTo - string\nRefBlockNumber - long\nRefBlockPrefix - string\nMethodName - string\nParams - string\nSignature - string\nError - string\nExample:​\nawait client.GetTransactionResultAsync(transactionId);\n\n8. Get Multiple Transaction Results in a Block​\n\nWeb API path: /api/blockChain/transactionResults\n\nParameters :\n\nblockHash - string\noffset - int\nlimit - int\n\nReturns: List<TransactionResultDto> - The array of transaction result:\n\nthe transaction result object\nExample:​\nawait client.GetTransactionResultsAsync(blockHash, 0, 10);\n\n9. Get Transaction Pool Status​\n\nWeb API path: /api/blockChain/transactionPoolStatus\n\nParameters : None\n\nReturns: TransactionPoolStatusOutput\n\nQueued - int\nValidated - int\nExample:​\nvar transactionPoolStatus = await client.GetTransactionPoolStatusAsync();\n\n10. Send Transaction​\n\nWeb API path: /api/blockChain/sendTransaction (POST)\n\nParameters :\n\nSendRawTransactionInput - Serialization of data into protobuf data: -RawTransaction - string\n\nReturns: SendRawTransactionOutput\n\nTransactionId - string\nExample:​\nvar sendTransactionOutput = await client.SendTransactionAsync(sendTransactionInput);\n\n11. Send Raw Transaction​\n\nWeb API path: /api/blockChain/sendTransaction (POST)\n\nParameters :\n\nSendRawTransactionInput - Serialization of data into protobuf data:\nTransaction - string\nSignature - string\nReturnTransaction - bool\n\nReturns: SendRawTransactionOutput\n\nTransactionId - string\nTransaction - TransactionDto\nExample:​\nvar sendRawTransactionInput = new SendRawTransactionInput\n{\n    Transaction = \"YOUR_RAW_TRANSACTION\",\n    Signature = \"YOUR_SIGNATURE\",\n    ReturnTransaction = true\n};\nvar sendRawTransactionOutput = await client.SendRawTransactionAsync(sendRawTransactionInput);\nConsole.WriteLine($\"Transaction ID: {sendRawTransactionOutput.TransactionId}\");\n\n12. Send Multiple Transactions​\n\nWeb API path: /api/blockChain/sendTransactions (POST)\n\nParameters :\n\nSendTransactionsInput - Serialization of data into protobuf data:\nSendTransactionsInput - string\n\nReturns: string[]\n\nExample:​\nawait client.SendTransactionsAsync(input);\n\n13. Create Raw Transaction​\n\nWeb API path: /api/blockChain/rawTransaction (POST)\n\nParameters :\n\nCreateRawTransactionInput\nFrom - string\nTo - string\nRefBlockNumber - long\nRefBlockHash - string\nMethodName - string\nParams - string\n\nReturns:\n\nCreateRawTransactionOutput\nRawTransactions - string\nExample:​\nawait client.CreateRawTransactionAsync(input);\n\n14. Execute Transaction​\n\nWeb API path: /api/blockChain/executeTransaction (POST)\n\nParameters :\n\nExecuteRawTransactionDto - Serialization of data into protobuf data:\nRawTransaction - string\n\nReturns: string\n\nExample:​\nawait client.ExecuteRawTransactionAsync(input);\n\n15. Execute Raw Transaction​\n\nWeb API path: /api/blockChain/executeRawTransaction (POST)\n\nParameters :\n\nExecuteRawTransactionDto - Serialization of data into protobuf data:\nRawTransaction - string\nSignature - string\n\nReturns: string\n\nExample:​\nawait client.ExecuteRawTransactionAsync(input);\n\n16. Get Peers​\n\nWeb API path: /api/net/peers\n\nParameters :\n\nwithMetrics - bool\n\nReturns: List<PeerDto>\n\nIpAddress - string\nProtocolVersion - int\nConnectionTime - long\nConnectionStatus - string\nInbound - bool\nBufferedTransactionsCount - int\nBufferedBlocksCount - int\nBufferedAnnouncementsCount - int\nNodeVersion - string\nRequestMetrics - List<RequestMetric>\nRoundTripTime - long\nMethodName - string\nInfo - string\nRequestTime - string\nExample:​\nawait client.GetPeersAsync(false);\n\n17. Add Peer​\n\nAttempts to remove a node from the connected network nodes.\n\nWeb API path: /api/net/peer (POST)\n\nParameters :\n\nipAddress - string\n\nReturns: bool\n\nExample:​\nawait client.AddPeerAsync(\"127.0.0.1:7001\");\n\n18. Remove Peer​\n\nAttempts to remove a node from the connected network nodes.\n\nWeb API path: /api/net/peer (DELETE)\n\nParameters :\n\nipAddress - string\n\nReturns: bool\n\nawait client.RemovePeerAsync(\"127.0.0.1:7001\");\n\n19. Calculate Transaction Fee​\n\nWeb API path: /api/blockChain/calculateTransactionFee (POST)\n\nParameters :\n\nCalculateTransactionFeeInput - The object with the following structure :\nRawTrasaction - string\n\nReturns:\n\nTransactionFeeResultOutput\nSuccess - bool\nTransactionFee - map[string]interface\nResourceFee - map[string]interface\nExample:​\nvar input = new CalculateTransactionFeeInput{\n    RawTransaction = RawTransaction\n};\nawait Client.CalculateTransactionFeeAsync(input);\n\n20. Get Network Information​\n\nWeb API path: /api/net/networkInfo\n\nParameters : Empty\n\nReturns:\n\nNetworkInfoOutput\nVersion - string\nProtocolVersion - int\nConnections - int\nExample:​\nawait client.GetNetworkInfoAsync();\n\n\nThese examples demonstrate how to use the aelf Web API in C# using the AElfClient class to interact with the aelf blockchain, including checking chain status, handling transactions, and managing network peers.\n\naelf Client​\n1. IsConnected​\n\nVerify whether this SDK successfully connects to the chain.\n\nParameters: None\n\nReturns :\n\nbool: Connection status\nExample:​\nbool isConnected = await client.IsConnectedAsync();\nConsole.WriteLine($\"Is Connected: {isConnected}\");\n\n2. GetGenesisContractAddress​\n\nGet the address of the genesis contract.\n\nParameters: None\n\nReturns :\n\nstring: Genesis contract address\nExample:​\nawait client.GetGenesisContractAddressAsync();\n\n3. GetContractAddressByName​\n\nGet the address of a contract by the given contract name hash.\n\nParameters:\n\ncontractNameHash (string): Hash of the contract name\n\nReturns :\n\nstring: Contract address\nExample:​\nawait client.GetContractAddressByNameAsync(contractNameHash);\n\n4. GenerateTransaction​\n\nBuild a transaction from the input parameters.\n\nParameters:\n\nfrom (string): Sender's address\nto (string): Recipient's address\nmethodName (string): Method name\ninput IMessage\n\nReturns :\n\nTransaction: Built transaction\nExample:​\nawait client.GenerateTransactionAsync(from, to, methodName, input);\n\n5. GetFormattedAddress​\n\nConvert the Address to the displayed string format: symbol_base58-string_base58-string_chain-id.\n\nParameters:\n\naddress (string): Address to format\n\nReturns :\n\nstring: Formatted address\nExample:​\nawait client.GetFormattedAddressAsync(address);\n\n6. SignTransaction​\n\nParameters:\n\nprivateKey (string): Address to format\ntransaction (string): Address to format\n\nReturns :\n\nTransaction\nExample:​\nclient.SignTransaction(privateKeyHex, transaction);\n\n7. GetAddressFromPubKey​\n\nGet the account address through the public key.\n\nParameters:\n\npubKey (string): Public key\n\nReturns :\n\nstring: Account address\nExample:​\nclient.GetAddressFromPubKey(pubKey);\n\n8. GetAddressFromPrivateKey​\n\nGet the account address through the private key.\n\nParameters:\n\nprivateKey (string): Private key\n\nReturns :\n\nstring: Account address\nExample:​\nclient.GetAddressFromPrivateKey(privateKeyHex);\n\n9. GenerateKeyPairInfo​\n\nGenerate a new account key pair.\n\nParameters: None\n\nReturns :\n\nKeyPairInfo\nPrivateKey - string\nPublicKey - string\nAddress - string\nExample:​\nclient.GenerateKeyPairInfo();\n\nSupports​\n\n.NET Standard 2.0\n\nPrevious\nJavascript SDK\nNext\nGo SDK\nIntroduction\nAdding aelf-sdk.cs package\nUsing Package Manager\nUsing .NET CLI\nUsing PackageReference\nExamples\n1. Create Instance\n2. Test Connection\n3. Initiate a Transfer Transaction\nWeb API\n1. Create Instance\n2. Get Chain Status\n3. Get Contract File Descriptor Set\n4. Get Block Height\n5. Get Block Information by Block Hash\n6. Get Block Information by Block Height\n7. Get Transaction Result\n8. Get Multiple Transaction Results in a Block\n9. Get Transaction Pool Status\n10. Send Transaction\n11. Send Raw Transaction\n12. Send Multiple Transactions\n13. Create Raw Transaction\n14. Execute Transaction\n15. Execute Raw Transaction\n16. Get Peers\n17. Add Peer\n18. Remove Peer\n19. Calculate Transaction Fee\n20. Get Network Information\naelf Client\n1. IsConnected\n2. GetGenesisContractAddress\n3. GetContractAddressByName\n4. GenerateTransaction\n5. GetFormattedAddress\n6. SignTransaction\n7. GetAddressFromPubKey\n8. GetAddressFromPrivateKey\n9. GenerateKeyPairInfo\nSupports\nPlatform\nTechnology\nAudit Report\nPrivacy\nTerms of Use\nCookie Policy\nDeveloper Resources\nQuick Start\nLearn\nDocs\nTools\nResources\nEcosystem\nOverview\ndApps\naelf Ventures\nBlog\nConnect\nContact Us\nCopyright © 2024 aelf"
    },
    {
      "title": "AELF Docs",
      "url": "https://docs.aelf.com/tools/chain-sdk/go-sdk/",
      "html": "Skip to main content\nQuick Start\nLearn\nDocs\nTools\nResources\nBlog\nSearch\nTools\nChain SDK\nJavascript SDK\nC# SDK\nGo SDK\nJAVA SDK\nPHP SDK\nPython SDK\naelf Deploy Tool\naelf CLI\nSmart Contract\naelf Testnet Faucet\naelf Design\naelf Playground\nContract SDK\nToolsChain SDKGo SDK\naelf-sdk.go - aelf Go API\nIntroduction​\n\nThis document provides information on how to use the aelf Go SDK (aelf-sdk.go) to interact with an aelf node. The SDK allows you to communicate with a local or remote aelf node using HTTP. Here you will find instructions for setting up the SDK, examples of how to use it, and a brief description of its main functions.\n\nFor additional information, please visit the repository: aelf-sdk.go\n\nInstallation​\n\nTo install the aelf-sdk.go package, run the following command:\n\ngo get -u github.com/AElfProject/aelf-sdk.go\n\nExamples​\nCreate instance​\n\nCreate a new instance of AElfClient and set the URL of an AElf chain node:\n\nimport (\"github.com/AElfProject/aelf-sdk.go/client\")\n\nvar aelf = client.AElfClient{\n    Host:       \"http://127.0.0.1:8000\",\n    Version:    \"1.0\",\n    PrivateKey: \"cd86ab6347d8e52bbbe8532141fc59ce596268143a308d1d40fedf385528b458\",\n}\n\nInitiating a Transfer Transaction​\n\nHere is an example of how to initiate a transfer transaction using the aelf Go SDK:\n\n// Get token contract address.\ntokenContractAddress, _ := aelf.GetContractAddressByName(\"AElf.ContractNames.Token\")\nfromAddress := aelf.GetAddressFromPrivateKey(aelf.PrivateKey)\nmethodName := \"Transfer\"\ntoAddress, _ := util.Base58StringToAddress(\"7s4XoUHfPuqoZAwnTV7pHWZAaivMiL8aZrDSnY9brE1woa8vz\")\n\nparams := &pb.TransferInput{\n    To:     toAddress,\n    Symbol: \"ELF\",\n    Amount: 1000000000,\n    Memo:   \"transfer in demo\",\n}\nparamsByte, _ := proto.Marshal(params)\n\n// Generate a transfer transaction.\ntransaction, _ := aelf.CreateTransaction(fromAddress, tokenContractAddress, methodName, paramsByte)\nsignature, _ := aelf.SignTransaction(aelf.PrivateKey, transaction)\ntransaction.Signature = signature\n\n// Send the transfer transaction to aelf chain node.\ntransactionByets, _ := proto.Marshal(transaction)\nsendResult, _ := aelf.SendTransaction(hex.EncodeToString(transactionByets))\n\ntime.Sleep(time.Duration(4) * time.Second)\ntransactionResult, _ := aelf.GetTransactionResult(sendResult.TransactionID)\nfmt.Println(transactionResult)\n\n// Query account balance.\nownerAddress, _ := util.Base58StringToAddress(fromAddress)\ngetBalanceInput := &pb.GetBalanceInput{\n    Symbol: \"ELF\",\n    Owner:  ownerAddress,\n}\ngetBalanceInputByte, _ := proto.Marshal(getBalanceInput)\n\ngetBalanceTransaction, _ := aelf.CreateTransaction(fromAddress, tokenContractAddress, \"GetBalance\", getBalanceInputByte)\ngetBalanceTransaction.Params = getBalanceInputByte\ngetBalanceSignature, _ := aelf.SignTransaction(aelf.PrivateKey, getBalanceTransaction)\ngetBalanceTransaction.Signature = getBalanceSignature\n\ngetBalanceTransactionByets, _ := proto.Marshal(getBalanceTransaction)\ngetBalanceResult, _ := aelf.ExecuteTransaction(hex.EncodeToString(getBalanceTransactionByets))\nbalance := &pb.GetBalanceOutput{}\ngetBalanceResultBytes, _ := hex.DecodeString(getBalanceResult)\nproto.Unmarshal(getBalanceResultBytes, balance)\nfmt.Println(balance)\n\nWeb API​\n\nYou can see how the Web API of the node works at {chainAddress}/swagger/index.html. For example, on a local address: http://127.0.0.1:1235/swagger/index.html.\n\nThe usage of these methods is based on the AElfClient instance. If you don’t have one, please create it:\n\nimport (\"github.com/AElfProject/aelf-sdk.go/client\")\n\nvar aelf = client.AElfClient{\n    Host:       \"http://127.0.0.1:8000\",\n    Version:    \"1.0\",\n    PrivateKey: \"680afd630d82ae5c97942c4141d60b8a9fedfa5b2864fca84072c17ee1f72d9d\",\n}\n\nGetChainStatus​\n\nWeb API path: /api/blockChain/chainStatus\n\nParameters : None\n\nReturns:\n\nChainStatusDto\n\nChainId - string\nBranches - map[string]interface\nNotLinkedBlocks - map[string]interface\nLongestChainHeight - int64\nLongestChainHash - string\nGenesisBlockHash - string\nGenesisContractAddress - string\nLastIrreversibleBlockHash - string\nLastIrreversibleBlockHeight - int64\nBestChainHash - string\nBestChainHeight - int64\nExample:​\nchainStatus, err := aelf.GetChainStatus()\n\nGetContractFileDescriptorSet​\n\nGet the protobuf definitions related to a contract.\n\nWeb API path: /api/blockChain/contractFileDescriptorSet\n\nParameters :\n\ncontractAddress - string\n\nReturns: []byte\n\nExample:​\ncontractFile, err := aelf.GetContractFileDescriptorSet(\"pykr77ft9UUKJZLVq15wCH8PinBSjVRQ12sD1Ayq92mKFsJ1i\")\n\nGetBlockHeight​\n\nGet the current best height of the chain.\n\nWeb API path: /api/blockChain/blockHeight\n\nParameters : None\n\nReturns: float64\n\nExample:​\nheight, err := aelf.GetBlockHeight()\n\nGetBlock​\n\nGet block information by block hash.\n\nWeb API path: /api/blockChain/block\n\nParameters :\n\nblockHash - string\nincludeTransactions - bool\n\nReturns:\n\nBlockDto\n\nBlockHash - string\nHeader - BlockHeaderDto\nPreviousBlockHash - string\nMerkleTreeRootOfTransactions - string\nMerkleTreeRootOfWorldState - string\nExtra - string\nHeight - int64\nTime - string\nChainId - string\nBloom - string\nSignerPubkey - string\nBody - BlockBodyDto\nTransactionsCount - int\nTransactions - []string\nExample:​\nblock, err := aelf.GetBlockByHash(blockHash, true)\n\nGetBlockByHeight​\n\nWeb API path: /api/blockChain/blockByHeight\n\nParameters :\n\nblockHeight - int64\nincludeTransactions - bool\n\nReturns:\n\nBlockDto\n\nBlockHash - string\nHeader - BlockHeaderDto\nPreviousBlockHash - string\nMerkleTreeRootOfTransactions - string\nMerkleTreeRootOfWorldState - string\nExtra - string\nHeight - int64\nTime - string\nChainId - string\nBloom - string\nSignerPubkey - string\nBody - BlockBodyDto\nTransactionsCount - int\nTransactions - []string\nExample:​\nblock, err := aelf.GetBlockByHeight(100, true)\n\nGetTransactionResult​\n\nWeb API path: /api/blockChain/transactionResult\n\nParameters :\n\ntransactionId - string\n\nReturns:\n\nTransactionResultDto\n\nTransactionId - string\nStatus - string\nLogs - []LogEventDto\nAddress - string\nName - string\nIndexed - []string\nNonIndexed - string\nBloom - string\nBlockNumber - int64\nBlockHash - string\nTransaction - TransactionDto\nFrom - string\nTo - string\nRefBlockNumber - int64\nRefBlockPrefix - string\nMethodName - string\nParams - string\nSignature - string\nReturnValue - string\nError - string\nExample:​\ntransactionResult, err := aelf.GetTransactionResult(transactionID)\n\nGetTransactionResults​\n\nGet multiple transaction results in a block.\n\nWeb API path: /api/blockChain/transactionResults\n\nParameters :\n\nblockHash - string\noffset - int\nlimit - int\n\nReturns: []TransactionResultDto\n\nthe transaction result object\nExample:​\ntransactionResults, err := aelf.GetTransactionResults(blockHash, 0, 10)\n\nGetTransactionPoolStatus​\n\nWeb API path: /api/blockChain/transactionPoolStatus\n\nParameters : None\n\nReturns: TransactionPoolStatusOutput\n\nQueued - int\nValidated - int\nExample:​\npoolStatus, err := aelf.GetTransactionPoolStatus();\n\nSendTransaction​\n\nWeb API path: /api/blockChain/sendTransaction (POST)\n\nParameters :\n\nSendRawTransactionInput - Serialization of data into protobuf data:\nRawTransaction - string\n\nReturns:\n\nSendTransactionOutput\nTransactionId - string\nExample:​\nsendResult, err := aelf.SendTransaction(input)\n\nSendRawTransaction​\n\nWeb API path: /api/blockChain/sendTransaction (POST)\n\nParameters :\n\nSendRawTransactionInput - Serialization of data into protobuf data:\nRawTransaction - string\nSignature - string\nReturnTransaction - bool\n\nReturns:\n\nSendRawTransactionOutput\nTransactionId - string\nTransaction - TransactionDto\nExample:​\nsendRawResult, err := aelf.SendRawTransaction(input)\n\nSendTransactions​\n\nWeb API path: /api/blockChain/sendTransactions (POST)\n\nParameters :\n\nrawTransactions - string - - Serialization of data into protobuf data:\n\nReturns: []interface{}\n\nExample:​\nresults, err := aelf.SendTransactions(transactions)\n\nCreateRawTransaction​\n\nCreates an unsigned serialized transaction.\n\nWeb API path: /api/blockChain/rawTransaction (POST)\n\nParameters :\n\nCreateRawTransactionInput\nFrom - string\nTo - string\nRefBlockNumber - long\nRefBlockHash - string\nMethodName - string\nParams - string\n\nReturns:\n\nCreateRawTransactionOutput\nRawTransactions - string\nExample:​\nresult, err := aelf.CreateRawTransaction(input)\n\nExecuteTransaction​\n\nCall a read-only method on a contract.\n\nWeb API path: /api/blockChain/executeTransaction (POST)\n\nParameters :\n\nrawTransaction - string\n\nReturns: string\n\nExample:​\nexecuteresult, err := aelf.ExecuteTransaction(rawTransaction)\n\nExecuteRawTransaction​\n\nCall a read-only method on a contract.\n\nWeb API path: /api/blockChain/executeRawTransaction (POST)\n\nParameters :\n\nExecuteRawTransactionDto - Serialization of data into protobuf data:\nRawTransaction - string\nSignature - string\n\nReturns: string\n\nExample:​\nexecuteRawresult, err := aelf.ExecuteRawTransaction(executeRawinput)\n\nGetPeers​\n\nGet peer info about the connected network nodes.\n\nWeb API path: /api/net/peers\n\nParameters :\n\nwithMetrics - bool\n\nReturns:\n\n[]PeerDto\n\nIpAddress - string\nProtocolVersion - int\nConnectionTime - int64\nConnectionStatus - string\nInbound - bool\nBufferedTransactionsCount - int\nBufferedBlocksCount - int\nBufferedAnnouncementsCount - int\nNodeVersion - string\nRequestMetrics - []RequestMetric\nRoundTripTime - int64\nMethodName - string\nInfo - string\nRequestTime - string\nExample:​\npeers, err := aelf.GetPeers(false)\n\nAddPeer​\n\nAttempts to add a node to the connected network nodes.\n\nWeb API path: /api/net/peer (POST)\n\nParameters :\n\nipAddress - string\n\nReturns: bool\n\nExample:​\naddResult, err := aelf.AddPeer(\"127.0.0.1:7001\")\n\nRemovePeer​\n\nAttempts to remove a node from the connected network nodes.\n\nWeb API path: /api/net/peer (DELETE)\n\nParameters :\n\nipAddress - string\n\nReturns: bool\n\nExample:​\nremoveResult, err := aelf.RemovePeer(\"127.0.0.1:7001\")\n\nCalculateTransactionFee​\n\nEstimate transaction fee.\n\nWeb API path: /api/blockChain/calculateTransactionFee (POST)\n\nParameters :\n\nCalculateTransactionFeeInput - The object with the following structure :\nRawTrasaction - string\n\nReturns:\n\nTransactionFeeResultOutput\nSuccess - bool\nTransactionFee - map[string]interface\nResourceFee - map[string]interface\nExample:​\ncalculateTransactionFee, err := aelf.CalculateTransactionFee(transactionFeeInput)\n\nGetNetworkInfo​\n\nGet the network information of the node.\n\nWeb API path: /api/net/networkInfo\n\nParameters : Empty\n\nReturns:\n\nNetworkInfoOutput\nVersion - string\nProtocolVersion - int\nConnections - int\nExample:​\nnetworkInfo, err := aelf.GetNetworkInfo()\n\naelf Client​\nIsConnected​\n\nCheck if the SDK is successfully connected to the blockchain.\n\nParameters: None\n\nReturns :\n\nbool: Connection status\nExample:​\nisConnected := aelf.IsConnected()\n\nGetGenesisContractAddress​\n\nParameters: None\n\nReturns :\n\nstring: Genesis contract address\nExample:​\ncontractAddress, err := aelf.GetGenesisContractAddress()\n\nGetContractAddressByName​\n\nGet the address of a contract by its name hash.\n\nParameters:\n\ncontractNameHash (string): Hash of the contract name\n\nReturns :\n\nstring: Contract address\nExample:​\ncontractAddress, err := aelf.GetContractAddressByName(\"AElf.ContractNames.Token\")\n\nCreateTransaction​\n\nBuild a transaction with the provided parameters.\n\nParameters:\n\nfrom (string): Sender's address\nto (string): Recipient's address\nmethodName (string): Method name\nparams ([]byte): Method parameters\n\nReturns :\n\nTransaction: Built transaction\nExample:​\ntransaction, err := aelf.CreateTransaction(fromAddress, toAddress, methodName, param)\n\nGetFormattedAddress​\n\nConvert an address to a displayable string format: symbol_base58-string_base58-string-chain-id.\n\nParameters:\n\naddress (string): Address to format\n\nReturns :\n\nstring: Formatted address\nExample:​\nformattedAddress, err := aelf.GetFormattedAddress(address)\n\nSignTransaction​\n\nSign a transaction using a private key.\n\nParameters:\n\nprivateKey (string): Address to format\ntransaction (string): Address to format\n\nReturns :\n\n[]byte: Transaction signature\nExample:​\nsignature, err := aelf.SignTransaction(privateKey, transaction)\n\nGetAddressFromPubKey​\n\nParameters:\n\npubKey (string): Public key\n\nReturns :\n\nstring: Account address\nExample:​\naddress := aelf.GetAddressFromPubKey(pubKey)\n\nGetAddressFromPrivateKey​\n\nParameters:\n\nprivateKey (string): Private key\n\nReturns :\n\nstring: Account address\nExample:​\naddress := aelf.GetAddressFromPrivateKey(privateKey)\n\nGenerateKeyPairInfo​\n\nParameters: None\n\nReturns :\n\nKeyPairInfo\nPrivateKey\nPublicKey\nAddress\nExample:​\nkeyPair := aelf.GenerateKeyPairInfo()\n\nSupported Go Version​\nGo 1.13\nPrevious\nC# SDK\nNext\nJAVA SDK\nIntroduction\nInstallation\nExamples\nCreate instance\nInitiating a Transfer Transaction\nWeb API\nGetChainStatus\nGetContractFileDescriptorSet\nGetBlockHeight\nGetBlock\nGetBlockByHeight\nGetTransactionResult\nGetTransactionResults\nGetTransactionPoolStatus\nSendTransaction\nSendRawTransaction\nSendTransactions\nCreateRawTransaction\nExecuteTransaction\nExecuteRawTransaction\nGetPeers\nAddPeer\nRemovePeer\nCalculateTransactionFee\nGetNetworkInfo\naelf Client\nIsConnected\nGetGenesisContractAddress\nGetContractAddressByName\nCreateTransaction\nGetFormattedAddress\nSignTransaction\nGetAddressFromPubKey\nGetAddressFromPrivateKey\nGenerateKeyPairInfo\nSupported Go Version\nPlatform\nTechnology\nAudit Report\nPrivacy\nTerms of Use\nCookie Policy\nDeveloper Resources\nQuick Start\nLearn\nDocs\nTools\nResources\nEcosystem\nOverview\ndApps\naelf Ventures\nBlog\nConnect\nContact Us\nCopyright © 2024 aelf"
    },
    {
      "title": "AELF Docs",
      "url": "https://docs.aelf.com/tutorials/operate-a-node/run-a-side-chain/running-a-side-chain/",
      "html": "Skip to main content\nQuick Start\nLearn\nDocs\nTools\nResources\nBlog\nSearch\nUnderstanding aelf\nCore\nCross Chain\nConsensus\nNetwork\nBoot Sequence\nAddresses\nTransactions\nSmart Contract\nACS\nTutorials\nNode Operator\nTestnet Node\nMainnet Node\nRun aelf on Cloud\nSide Chain\nRequest a Side Chain\nRun a Side Chain\nTutorialsNode OperatorSide ChainRun a Side Chain\nRunning a Side Chain\n\nThis tutorial explains how to run a side chain node after it has been approved by the producers and released by the creator. After creating the side chain, producers need to run a side chain node.\n\nPrerequisites​\nYou already have a main-chain node running.\nThe creation of the side chain has been approved and released.\nImportant Note​\n\nThe key-pair (account) used for mining on the side chain must be the same as the one used on the main-chain node. Both production nodes need to be launched with the same key-pair.\n\nFor more information about side chain creation, refer to the document in the request-side-chain section.\n\nSide Chain Configuration​\nConfiguration Files​\n\nTwo configuration files must be placed in the configuration folder of the side chain, from which you will launch the node:\n\nappsettings.json\nappsettings.SideChain.MainNet.json\nChain ID and Settings​\n\nAfter the release of the side chain creation request, the ChainId of the new side chain will be accessible in the SideChainCreatedEvent logged by the transaction that released it.\n\nIn this example, we will set up the side chain node with ChainId tDVV (1866392 converted to base58), connecting to Redis db2, and using web API port 1235. Don’t forget to change the account, password, and initial miner.\n\nappsettings.json​\n{\n  \"ChainId\": \"tDVV\",\n  \"ChainType\": \"SideChain\",\n  \"NetType\": \"MainNet\",\n  \"ConnectionStrings\": {\n    \"BlockchainDb\": \"redis://localhost:6379?db=2\",\n    \"StateDb\": \"redis://localhost:6379?db=2\"\n  },\n  \"Account\": {\n    \"NodeAccount\": \"YOUR PRODUCER ACCOUNT\",\n    \"NodeAccountPassword\": \"YOUR PRODUCER PASSWORD\"\n  },\n  \"Kestrel\": {\n    \"EndPoints\": {\n      \"Http\": {\n        \"Url\": \"http://*:1235/\"\n      }\n    }\n  },\n  \"Consensus\": {\n    \"MiningInterval\": 4000,\n    \"StartTimestamp\": 0\n  }\n}\n\nappsettings.SideChain.MainNet.json​\n{\n  \"CrossChain\": {\n    \"Grpc\": {\n      \"ParentChainServerPort\": 5010,\n      \"ListeningPort\": 5000,\n      \"ParentChainServerIp\": \"127.0.0.1\"\n    },\n    \"ParentChainId\": \"AELF\"\n  }\n}\n\n\nChange ParentChainServerIp and ParentChainServerPort depending on the listening address of your mainchain node.\n\nLaunching the Side Chain Node​\n\nOpen a terminal and navigate to the folder where you created the side chain configuration:\n\ndotnet ../AElf.Launcher.dll\n\n\nYou can try out a few commands from another terminal to check if everything is fine, for example:\n\naelf-command get-blk-height -e http://127.0.0.1:1235\n\nPrevious\nRequest a Side Chain\nPrerequisites\nImportant Note\nSide Chain Configuration\nConfiguration Files\nChain ID and Settings\nLaunching the Side Chain Node\nPlatform\nTechnology\nAudit Report\nPrivacy\nTerms of Use\nCookie Policy\nDeveloper Resources\nQuick Start\nLearn\nDocs\nTools\nResources\nEcosystem\nOverview\ndApps\naelf Ventures\nBlog\nConnect\nContact Us\nCopyright © 2024 aelf"
    },
    {
      "title": "AELF Docs",
      "url": "https://docs.aelf.com/tutorials/operate-a-node/run-a-side-chain/request-side-chain-creation/",
      "html": "Skip to main content\nQuick Start\nLearn\nDocs\nTools\nResources\nBlog\nSearch\nUnderstanding aelf\nCore\nCross Chain\nConsensus\nNetwork\nBoot Sequence\nAddresses\nTransactions\nSmart Contract\nACS\nTutorials\nNode Operator\nTestnet Node\nMainnet Node\nRun aelf on Cloud\nSide Chain\nRequest a Side Chain\nRun a Side Chain\nTutorialsNode OperatorSide ChainRequest a Side Chain\nRequest a Side Chain\n\nSide chains can be created in the aelf ecosystem to enable scalability. This section introduces the process in detail.\n\nSide Chain Creation API​\n\nAnyone can request the creation of a side chain in the aelf ecosystem. The proposer/creator of a new side chain needs to request the creation through the cross-chain contract on the main chain. The request contains fields that determine the type of side chain to be created.\n\nAPI for Proposing Side Chain Creation​\n\nThe fields in the SideChainCreationRequest determine the type of side chain that is created. For more details, follow RequestSideChainCreation in the Crosschain contract documentation.\n\nUpon creating a new proposal for the side chain, the ProposalCreated event containing the proposal ID will be fired. A parliament organization, specified since the chain's launch, will approve this proposal within 24 hours (refer to the Parliament contract documentation for details). The proposer can release the side chain creation request with the proposal ID once it can be released. Refer to ReleaseSideChainCreation in the Crosschain contract documentation.\n\nOnce the side chain is created, the SideChainCreatedEvent containing the chain ID will be fired.\n\nThe side chain node can be launched once it is created on the main chain. Ensure the side chain ID from the creation result is configured correctly before launching the side chain node. Make sure the cross-chain communication context is correctly set, as the side chain node will request main chain node for chain initialization data. For more details, check the side chain node running tutorial.\n\nSide Chain Types​\n\nTwo types of side chains currently exist: exclusive and shared. An exclusive side chain allows developers to choose the transaction fee model and set the transaction fee price. Only the creator of an exclusive side chain can propose deploying a new contract.\n\nPaying for Side Chain​\nIndexing Fee​\n\nThe indexing fee is paid for side chain indexing. You can specify the indexing fee price and prepayments amount when requesting side chain creation. The cross-chain contract charges prepayments once the side chain is created and pays the miner who indexes the side chain block every time.\n\nResource Fee​\n\nDevelopers of an exclusive side chain pay producers for running it by paying CPU, RAM, DISK, and NET resource tokens. This model is called charge-by-time. The amount the side chain creator must share with the producers is set after the chain's creation. The exclusive side chain is priced according to the time used. The unit price of the fee is determined through negotiation between the production node and the developer.\n\nSimple Demo for Side Chain Creation Request​\n\nWhen a user (usually a developer) feels the need to create a new side chain on aelf, they must call the cross-chain contract and request a side chain creation. After the request, parliament organization members will either approve or reject the creation. If the request is approved, the developer must then release the proposal.\n\nStep-by-Step Code Snippets​\n\nWe'll use the aelf-js-sdk to create a new side chain. The full script will be provided at the end.\n\nThis creation of a side chain (logical, on-chain creation) is done in four steps:\n\nThe developer must allow/approve some tokens to the cross-chain contract of the main chain.\nThe developer calls the cross-chain contract of the main chain to request the creation.\nThe parliament organization members must approve this request.\nFinally, the developer must release the request to finalize the creation.\nSet-Up​\n\nTo test the creation process, you will need a producer node running and the following:\n\nA key-pair (account) created; this will be your Producer (also used to create the creation request in this tutorial).\nThe node needs to be configured with an API endpoint, account, and miner list that correspond to what is in the script.\n\nHere is the initialization code:\n\nconst AElf = require('aelf-sdk');\nconst Wallet = AElf.wallet;\n\nconst { sha256 } = AElf.utils;\n\n// set the private key of the block producer.\n// REPLACE\nconst defaultPrivateKey = 'e119487fea0658badc42f089fbaa56de23d8c0e8d999c5f76ac12ad8ae897d76';\nconst defaultPrivateKeyAddress = 'HEtBQStfqu53cHVC3PxJU6iGP3RGxiNUfQGvAPTjfrF3ZWH3U';\n\n// load the wallet associated with your block producer's account.\nconst wallet = Wallet.getWalletByPrivateKey(defaultPrivateKey);\n\n// API link to the node\n// REPLACE\nconst aelf = new AElf(new AElf.providers.HttpProvider('http://127.0.0.1:1234'));\n\n// names of the contracts that will be used.\nconst tokenContractName = 'AElf.ContractNames.Token';\nconst parliamentContractName = 'AElf.ContractNames.Parliament';\nconst crossChainContractName = 'AElf.ContractNames.CrossChain';\n\n...\n\nconst createSideChain = async () => {\n    // check the chain status to make sure the node is running\n    const chainStatus = await aelf.chain.getChainStatus({sync: true});\n    const genesisContract = await aelf.chain.contractAt(chainStatus.GenesisContractAddress, wallet)\n        .catch((err) => {\n        console.log(err);\n        });\n\n    // get the addresses of the contracts that we'll need to call\n    const tokenContractAddress = await genesisContract.GetContractAddressByName.call(sha256(tokenContractName));\n    const parliamentContractAddress = await genesisContract.GetContractAddressByName.call(sha256(parliamentContractName));\n    const crossChainContractAddress = await genesisContract.GetContractAddressByName.call(sha256(crossChainContractName));\n\n    // build the aelf-sdk contract instance objects\n    const parliamentContract = await aelf.chain.contractAt(parliamentContractAddress, wallet);\n    const tokenContract = await aelf.chain.contractAt(tokenContractAddress, wallet);\n    const crossChainContract = await aelf.chain.contractAt(crossChainContractAddress, wallet);\n\n    ...\n}\n\n\nWhen running the script, the createSideChain function will be executed and will run through the full process of creating the side chain.\n\nCreation of the Side Chain​\nSet the Allowance​\n\nFirst, the developer must approve some ELF tokens for use by the cross-chain contract.\n\nvar setAllowance = async function (tokenContract, crossChainContractAddress) {\n  // set some allowance to the cross-chain contract\n  const approvalResult = await tokenContract.Approve({\n    symbol: \"ELF\",\n    spender: crossChainContractAddress,\n    amount: 20000,\n  });\n\n  let approveTransactionResult = await pollMining(approvalResult.TransactionId);\n};\n\nCreation Request​\n\nTo request a side chain creation, the developer must call RequestSideChainCreation on the cross-chain contract. This creates a proposal with the Parliament contract. After calling this method, a ProposalCreated log will be created containing the ProposalId.\n\nrpc RequestSideChainCreation(SideChainCreationRequest) returns (google.protobuf.Empty){}\n\nmessage SideChainCreationRequest {\n    int64 indexing_price = 1; // The cross chain indexing price.\n    int64 locked_token_amount = 2; // Initial locked balance for a new side chain.\n    bool is_privilege_preserved = 3; // Creator privilege boolean flag.\n    SideChainTokenCreationRequest side_chain_token_creation_request = 4; // Side chain token information.\n    repeated SideChainTokenInitialIssue side_chain_token_initial_issue_list = 5; // A list of accounts and amounts that will be issued when the chain starts.\n    map<string, int32> initial_resource_amount = 6; // The initial rent resources.\n}\n\nmessage SideChainTokenCreationRequest{\n    string side_chain_token_symbol = 1; // Token symbol of the side chain to be created.\n    string side_chain_token_name = 2; // Token name of the side chain to be created.\n    int64 side_chain_token_total_supply = 3; // Token total supply of the side chain to be created.\n    int32 side_chain_token_decimals = 4; // Token decimals of the side chain to be created.\n}\n\nmessage SideChainTokenInitialIssue{\n    aelf.Address address = 1; // The account that will be issued.\n    int64 amount = 2; // The amount that will be issued.\n}\n\n\nIn order for the creation request to succeed, some assertions must pass:\n\nThe Sender can only have one pending request at any time.\nThe locked_token_amount cannot be lower than the indexing price.\nIf is_privilege_preserved is true (exclusive side chain), the token initial issue list cannot be empty and all with an amount greater than 0.\nIf is_privilege_preserved is true (exclusive side chain), the initial_resource_amount must contain all resource tokens of the chain, and the value must be greater than 0.\nThe allowance approved to cross-chain contract from the proposer (Sender of the transaction) cannot be lower than the locked_token_amount.\nNo need to provide data about side chain token if is_privilege_preserved is false.\nvar sideChainCreationRequest = async function (crossChainContract) {\n  // call the cross-chain contract to request the creation\n  const creationRequestResult =\n    await crossChainContract.RequestSideChainCreation({\n      indexing_price: 1,\n      locked_token_amount: 20000,\n      is_privilege_preserved: true,\n      side_chain_token_creation_request: {\n        side_chain_token_symbol: \"MEGA\",\n        side_chain_token_name: \"MEGA\",\n        side_chain_token_total_supply: 100000000,\n        side_chain_token_decimals: 8,\n      },\n      side_chain_token_initial_issue_list: [\n        {\n          address: defaultPrivateKeyAddress,\n          amount: 10000000,\n        },\n      ],\n      initial_resource_amount: {\n        CPU: 100,\n        RAM: 100,\n        DISK: 100,\n        NET: 100,\n      },\n    });\n\n  let sideChainProposalResult = await pollMining(\n    creationRequestResult.TransactionId\n  );\n  let logs = parseLogs(sideChainProposalResult.Logs);\n  let proposalId = logs.ProposalId;\n};\n\n\nThe cross-chain contract emits an event containing the ProposalId. This is needed for the last step.\n\nApprove the Proposal​\n\nThis is where the parliament organization members approve the proposal:\n\nvar proposalApproveTx = await parliamentContract.Approve(deserializedLogs[0].proposalId);\n\nawait pollMining(proposalApproveTx.TransactionId);\n\n\nNote: when calling Approve it will be the Sender of the transaction that approves. Here the script is set to use the key of one parliament organization member, see full script at the end.\n\nRelease the Proposal​\n\nThis part of the script releases the proposal:\n\nvar releaseResult = await crossChainContract.ReleaseSideChainCreation({\n    proposalId: deserializedLogs[0].proposalId\n});\n\nlet releaseTxResult = await pollMining(releaseResult.TransactionId);\n\n// Parse the logs to get the chain id.\nlet sideChainCreationEvent = crossChainContract.deserializeLog(releaseTxResult.Logs, 'SideChainCreatedEvent');\n\n\nThis is the last step involved in creating a side chain, after this the chain id of the new side chain is accessible in the SideChainCreatedEvent event log.\n\nComplete Script​\n\nThis script demonstrates the essential steps to create a side chain in the aelf ecosystem. The developer must approve some ELF tokens, request the side chain creation, get approval from the parliament organization, and finally release the proposal to create the side chain. Ensure to set the proper configurations and values as per your blockchain environment.\n\nconst AElf = require(\"aelf-sdk\");\nconst Wallet = AElf.wallet;\n\nconst { sha256 } = AElf.utils;\n\n// set the private key of the block producer\nconst defaultPrivateKey =\n  \"e119487fea0658badc42f089fbaa56de23d8c0e8d999c5f76ac12ad8ae897d76\";\nconst defaultPrivateKeyAddress =\n  \"HEtBQStfqu53cHVC3PxJU6iGP3RGxiNUfQGvAPTjfrF3ZWH3U\";\n\nconst wallet = Wallet.getWalletByPrivateKey(defaultPrivateKey);\n\n// link to the node\nconst aelf = new AElf(new AElf.providers.HttpProvider(\"http://127.0.0.1:8000\"));\n\nif (!aelf.isConnected()) {\n  console.log(\"Could not connect to the node.\");\n}\n\nconst tokenContractName = \"AElf.ContractNames.Token\";\nconst parliamentContractName = \"AElf.ContractNames.Parliament\";\nconst crossChainContractName = \"AElf.ContractNames.CrossChain\";\n\nvar pollMining = async function (transactionId) {\n  console.log(`>> Waiting for ${transactionId} the transaction to be mined.`);\n\n  for (i = 0; i < 10; i++) {\n    const currentResult = await aelf.chain.getTxResult(transactionId);\n    // console.log('transaction status: ' + currentResult.Status);\n\n    if (currentResult.Status === \"MINED\") return currentResult;\n\n    await new Promise((resolve) => setTimeout(resolve, 2000)).catch(\n      function () {\n        console.log(\"Promise Rejected\");\n      }\n    );\n  }\n};\n\nvar setAllowance = async function (tokenContract, crossChainContractAddress) {\n  console.log(\"\\n>>>> Setting allowance for the cross-chain contract.\");\n\n  // set some allowance to the cross-chain contract\n  const approvalResult = await tokenContract.Approve({\n    symbol: \"ELF\",\n    spender: crossChainContractAddress,\n    amount: 20000,\n  });\n\n  await pollMining(approvalResult.TransactionId);\n};\n\nvar checkAllowance = async function (tokenContract, owner, spender) {\n  console.log(\"\\n>>>> Checking the cross-chain contract's allowance\");\n\n  const checkAllowanceTx = await tokenContract.GetAllowance.call({\n    symbol: \"ELF\",\n    owner: owner,\n    spender: spender,\n  });\n\n  console.log(\n    `>> allowance to the cross-chain contract: ${checkAllowanceTx.allowance} ${checkAllowanceTx.symbol}`\n  );\n};\n\nconst createSideChain = async () => {\n  // get the status of the chain in order to get the genesis contract address\n  console.log(\"Starting side chain creation script\\n\");\n\n  const chainStatus = await aelf.chain.getChainStatus({ sync: true });\n  const genesisContract = await aelf.chain\n    .contractAt(chainStatus.GenesisContractAddress, wallet)\n    .catch((err) => {\n      console.log(err);\n    });\n\n  // get the addresses of the contracts that we'll need to call\n  const tokenContractAddress =\n    await genesisContract.GetContractAddressByName.call(\n      sha256(tokenContractName)\n    );\n  const parliamentContractAddress =\n    await genesisContract.GetContractAddressByName.call(\n      sha256(parliamentContractName)\n    );\n  const crossChainContractAddress =\n    await genesisContract.GetContractAddressByName.call(\n      sha256(crossChainContractName)\n    );\n\n  // build the aelf-sdk contract object\n  const parliamentContract = await aelf.chain.contractAt(\n    parliamentContractAddress,\n    wallet\n  );\n  const tokenContract = await aelf.chain.contractAt(\n    tokenContractAddress,\n    wallet\n  );\n  const crossChainContract = await aelf.chain.contractAt(\n    crossChainContractAddress,\n    wallet\n  );\n\n  // 1. set and check the allowance, spender is the cross-chain contract\n  await setAllowance(tokenContract, crossChainContractAddress);\n  await checkAllowance(\n    tokenContract,\n    defaultPrivateKeyAddress,\n    crossChainContractAddress\n  );\n\n  // 2. request the creation of the side chain with the cross=chain contract\n  console.log(\"\\n>>>> Requesting the side chain creation.\");\n  const sideChainCreationRequestTx =\n    await crossChainContract.RequestSideChainCreation({\n      indexingPrice: 1,\n      lockedTokenAmount: \"20000\",\n      isPrivilegePreserved: true,\n      sideChainTokenCreationRequest: {\n        sideChainTokenDecimals: 8,\n        sideChainTokenName: \"SCATokenName\",\n        sideChainTokenSymbol: \"SCA\",\n        sideChainTokenTotalSupply: \"100000000000000000\",\n      },\n      sideChainTokenInitialIssueList: [\n        {\n          address: \"28Y8JA1i2cN6oHvdv7EraXJr9a1gY6D1PpJXw9QtRMRwKcBQMK\",\n          amount: \"1000000000000000\",\n        },\n      ],\n      initialResourceAmount: { CPU: 2, RAM: 4, DISK: 512, NET: 1024 },\n    });\n\n  let sideChainCreationRequestTxResult = await pollMining(\n    sideChainCreationRequestTx.TransactionId\n  );\n\n  // deserialize the log to get the proposal's ID.\n  let deserializedLogs = parliamentContract.deserializeLog(\n    sideChainCreationRequestTxResult.Logs,\n    \"ProposalCreated\"\n  );\n  console.log(\n    `>> side chain creation request proposal id ${JSON.stringify(\n      deserializedLogs[0].proposalId\n    )}`\n  );\n\n  // 3. Approve the proposal\n  console.log(\"\\n>>>> Approving the proposal.\");\n\n  var proposalApproveTx = await parliamentContract.Approve(\n    deserializedLogs[0].proposalId\n  );\n  await pollMining(proposalApproveTx.TransactionId);\n\n  // 3. Release the side chain\n  console.log(\"\\n>>>> Release the side chain.\");\n\n  var releaseResult = await crossChainContract.ReleaseSideChainCreation({\n    proposalId: deserializedLogs[0].proposalId,\n  });\n\n  let releaseTxResult = await pollMining(releaseResult.TransactionId);\n\n  // Parse the logs to get the chain id.\n  let sideChainCreationEvent = crossChainContract.deserializeLog(\n    releaseTxResult.Logs,\n    \"SideChainCreatedEvent\"\n  );\n  console.log(\"Chain chain created : \");\n  console.log(sideChainCreationEvent);\n};\n\ncreateSideChain().then(() => {\n  console.log(\"Done.\");\n});\n\n\nNote: Replace the placeholders in the script with actual values and logic for your use case.\n\nPrevious\nSide Chain\nNext\nRun a Side Chain\nSide Chain Creation API\nAPI for Proposing Side Chain Creation\nSide Chain Types\nPaying for Side Chain\nIndexing Fee\nResource Fee\nSimple Demo for Side Chain Creation Request\nStep-by-Step Code Snippets\nSet-Up\nCreation of the Side Chain\nComplete Script\nPlatform\nTechnology\nAudit Report\nPrivacy\nTerms of Use\nCookie Policy\nDeveloper Resources\nQuick Start\nLearn\nDocs\nTools\nResources\nEcosystem\nOverview\ndApps\naelf Ventures\nBlog\nConnect\nContact Us\nCopyright © 2024 aelf"
    },
    {
      "title": "AELF Docs",
      "url": "https://docs.aelf.com/learn/smart-contract/requirements-and-restrictions/other-restrictions/",
      "html": "Skip to main content\nQuick Start\nLearn\nDocs\nTools\nResources\nBlog\nSearch\nUnderstanding aelf\nCore\nCross Chain\nConsensus\nNetwork\nBoot Sequence\nAddresses\nTransactions\nSmart Contract\nArchitecture\nService\nEvents\nMessages\nRestrictions\nProject Requirements\nClass Structure\nType and Namespace\nOther Restrictions\nACS\nTutorials\nNode Operator\nUnderstanding aelfSmart ContractRestrictionsOther Restrictions\nOther Restrictions\nGetHashCode Usage​\n\nThe GetHashCode method can only be called within other GetHashCode methods. Calling GetHashCode from other methods is not permitted. This restriction allows developers to implement custom GetHashCode methods for their own types and also supports protobuf-generated message types.\n\nIt is prohibited to modify any field within GetHashCode methods.\n\nExecution Observer​\n\naelf's contract patcher automatically includes a method call count observer for your contract. This feature prevents infinite method calls, such as recursion. During transaction execution, the observer counts the number of methods called. If this count exceeds 15,000, transaction execution pauses. Adjustments to this limit are managed by Parliament.\n\nAdditionally, aelf's contract patcher includes a method branch count observer for your contract. This prevents infinite loop scenarios by counting control transfers within your contract code during transaction execution. If the number of control transfers exceeds 15,000, transaction execution pauses. The control transfer opcodes in C# contracts are listed below.\n\nOpcode\tDescription\nOpCodes.Beq\tBranch if equal\nOpCodes.Beq_S\tBranch if equal (short form)\nOpCodes.Bge\tBranch if greater than or equal\nOpCodes.Bge_S\tBranch if greater than or equal (short form)\nOpCodes.Bge_Un\tBranch if greater than or equal (unsigned)\nOpCodes.Bge_Un_S\tBranch if greater than or equal (unsigned, short form)\nOpCodes.Bgt\tBranch if greater than\nOpCodes.Bgt_S\tBranch if greater than (short form)\nOpCodes.Ble\tBranch if less than or equal\nOpCodes.Ble_S\tBranch if less than or equal (short form)\nOpCodes.Ble_Un\tBranch if less than or equal (unsigned)\nOpCodes.Blt\tBranch if less than\nOpCodes.Bne_Un\tBranch if not equal (unsigned)\nOpCodes.Bne_Un_S\tBranch if not equal (unsigned, short form)\nOpCodes.Br\tBranch unconditional\nOpCodes.Brfalse\tBranch if false\nOpCodes.Brfalse_S\tBranch if false (short form)\nOpCodes.Brtrue\tBranch if true\nOpCodes.Brtrue_S\tBranch if true (short form)\nOpCodes.Br_S\tBranch unconditional (short form)\nState Size Limit​\n\nData written to State is subject to a size limit enforced by aelf's contract patcher, set at 128 KB by default. This ensures contracts cannot store excessively large data. Any adjustments to this limit are decided by Parliament.\n\nPrevious\nType and Namespace\nNext\nACS\nGetHashCode Usage\nExecution Observer\nState Size Limit\nPlatform\nTechnology\nAudit Report\nPrivacy\nTerms of Use\nCookie Policy\nDeveloper Resources\nQuick Start\nLearn\nDocs\nTools\nResources\nEcosystem\nOverview\ndApps\naelf Ventures\nBlog\nConnect\nContact Us\nCopyright © 2024 aelf"
    },
    {
      "title": "Cross Chain Consensus | AELF Docs",
      "url": "https://docs.aelf.com/learn/acs-introduction/acs11-cross-chain-consensus-standard/",
      "html": "Skip to main content\nQuick Start\nLearn\nDocs\nTools\nResources\nBlog\nSearch\nUnderstanding aelf\nCore\nCross Chain\nConsensus\nNetwork\nBoot Sequence\nAddresses\nTransactions\nSmart Contract\nACS\nContract Deployment\nTransaction Fee\nParallel Execution\nContract Proposal\nConsensus\nContract Threshold\nRandom Number\nContract CrossChain\nToken Fee\nProfit Dividend\nDividend Pool\nCross Chain Consensus\nUser Contract\nTutorials\nNode Operator\nUnderstanding aelfACSCross Chain Consensus\nACS11 - Cross Chain Consensus Standard\n\nACS11 is a standard used to customize consensus mechanisms for cross-chain operations.\n\nInterface​\n\nContracts inheriting from ACS11 must implement the following interfaces:\n\nMethods​\nMethod Name\tRequest Type\tResponse Type\tDescription\nUpdateInformationFromCrossChain\tgoogle.protobuf.BytesValue\tgoogle.protobuf.Empty\tUpdate the consensus information of the side chain.\nGetChainInitializationInformation\tgoogle.protobuf.BytesValue\tgoogle.protobuf.BytesValue\tGet the current miner list and consensus round information.\nCheckCrossChainIndexingPermission\taelf.Address\tgoogle.protobuf.BoolValue\tVerify that the input address is the current miner.\nTypes​\naelf.Address​\nField\tType\tDescription\tLabel\nvalue\tbytes\t\t\naelf.BinaryMerkleTree​\nField\tType\tDescription\tLabel\nnodes\tHash\tThe leaf nodes.\t\nroot\tHash\tThe root node hash.\trepeated\nleaf_count\tint32\tThe count of leaf node.\t\naelf.Hash​\nField\tType\tDescription\tLabel\nvalue\tbytes\t\t\naelf.LogEvent​\nField\tType\tDescription\tLabel\naddress\tAddress\tThe contract address.\t\nname\tstring\tThe name of the log event.\t\nindexed\tbytes\tThe indexed data, used to calculate bloom.\trepeated\nnon_indexed\tbytes\tThe non-indexed data.\trepeated\naelf.MerklePath​\nField\tType\tDescription\tLabel\nmerkle_path_nodes\tMerklePathNode\tThe merkle path nodes.\trepeated\naelf.MerklePathNode​\nField\tType\tDescription\tLabel\nhash\tHash\tThe node hash.\t\nis_left_child_node\tbool\tWhether it is a left child node.\t\naelf.SInt32Value​\nField\tType\tDescription\tLabel\nvalue\tsint32\t\t\naelf.SInt64Value​\nField\tType\tDescription\tLabel\nvalue\tsint64\t\t\naelf.ScopedStatePath​\nField\tType\tDescription\tLabel\naddress\tAddress\tThe scope address.\t\npath\tStatePath\tThe path of contract state.\t\naelf.SmartContractRegistration​\nField\tType\tDescription\tLabel\ncategory\tsint32\tThe category of contract code (0: C#).\t\ncode\tbytes\tThe byte array of the contract code.\t\ncode_hash\tHash\tThe hash of the contract code.\t\nis_system_contract\tbool\tWhether it is a system contract.\t\nversion\tint32\tThe version of the current contract.\t\naelf.StatePath​\nField\tType\tDescription\tLabel\nparts\tstring\tThe partial path of the state path.\trepeated\naelf.Transaction​\nField\tType\tDescription\tLabel\nfrom\tAddress\tThe address of the sender of the transaction.\t\nto\tAddress\tThe address of the contract when calling a contract.\t\nref_block_number\tint64\tThe height of the referenced block hash.\t\nref_block_prefix\tbytes\tThe first four bytes of the referenced block hash.\t\nmethod_name\tstring\tThe name of a method in the smart contract at the To address.\t\nparams\tbytes\tThe parameters to pass to the smart contract method.\t\nsignature\tbytes\tSubset of fields: from/to, target method, parameter, reference block number, prefix.\t\naelf.TransactionExecutingStateSet​\nField\tType\tDescription\tLabel\nwrites\tTransactionExecutingStateSet.WritesEntry\tThe changed states.\trepeated\nreads\tTransactionExecutingStateSet.ReadsEntry\tThe read states.\trepeated\ndeletes\tTransactionExecutingStateSet.DeletesEntry\tThe deleted states.\trepeated\naelf.TransactionExecutingStateSet.DeletesEntry​\nField\tType\tDescription\tLabel\nkey\tstring\t\t\nvalue\tbool\t\t\naelf.TransactionExecutingStateSet.ReadsEntry​\nField\tType\tDescription\tLabel\nkey\tstring\t\t\nvalue\tbool\t\t\naelf.TransactionExecutingStateSet.WritesEntry​\nField\tType\tDescription\tLabel\nkey\tstring\t\t\nvalue\tbytes\t\t\naelf.TransactionResult​\nField\tType\tDescription\tLabel\ntransaction_id\tHash\tThe transaction id.\t\nstatus\tTransactionResultStatus\tThe transaction result status.\t\nlogs\tLogEvent\tThe log events.\trepeated\nbloom\tbytes\tBloom filter for transaction logs.\trepeated\nreturn_value\tbytes\tThe return value of the transaction execution.\t\nblock_number\tint64\tThe height of the block that packages the transaction.\t\nblock_hash\tHash\tThe hash of the block that packages the transaction.\t\nerror\tstring\tFailed execution error message.\t\naelf.TransactionResultStatus​\nName\tNumber\tDescription\nNOT_EXISTED\t0\tThe execution result of the transaction does not exist.\nPENDING\t1\tThe transaction is in the transaction pool waiting to be packaged.\nFAILED\t2\tTransaction execution failed.\nMINED\t3\tThe transaction was successfully executed and packaged into a block.\nCONFLICT\t4\tWhen executed in parallel, there are conflicts with other transactions.\nPENDING_VALIDATION\t5\tThe transaction is waiting for validation.\nNODE_VALIDATION_FAILED\t6\tTransaction validation failed.\nExample​\n\nACS11 defines methods for customizing consensus mechanisms for cross-chain scenarios. aelf provides an implementation of ACS11 through the AEDPoS contract. Developers can refer to the AEDPoS contract API for implementation details.\n\nPrevious\nDividend Pool\nNext\nUser Contract\nInterface\nMethods\nTypes\nExample\nPlatform\nTechnology\nAudit Report\nPrivacy\nTerms of Use\nCookie Policy\nDeveloper Resources\nQuick Start\nLearn\nDocs\nTools\nResources\nEcosystem\nOverview\ndApps\naelf Ventures\nBlog\nConnect\nContact Us\nCopyright © 2024 aelf"
    },
    {
      "title": "User Contract | AELF Docs",
      "url": "https://docs.aelf.com/learn/acs-introduction/acs12-user-contract-standard/",
      "html": "Skip to main content\nQuick Start\nLearn\nDocs\nTools\nResources\nBlog\nSearch\nUnderstanding aelf\nCore\nCross Chain\nConsensus\nNetwork\nBoot Sequence\nAddresses\nTransactions\nSmart Contract\nACS\nContract Deployment\nTransaction Fee\nParallel Execution\nContract Proposal\nConsensus\nContract Threshold\nRandom Number\nContract CrossChain\nToken Fee\nProfit Dividend\nDividend Pool\nCross Chain Consensus\nUser Contract\nTutorials\nNode Operator\nUnderstanding aelfACSUser Contract\nACS12 - User Contract Standard\n\nACS12 is a standard used to manage user contracts.\n\nTypes​\nacs12.UserContractMethodFees​\nField\tType\tLabel\tDescription\nfees\tacs12.UserContractMethodFee\trepeated\tList of fees to be charged.\nis_size_fee_free\tbool\t\tOptional based on the implementation of SetConfiguration method.\nacs12.UserContractMethodFee​\nField\tType\tLabel\tDescription\nsymbol\tstring\t\tThe token symbol of the method fee.\nbasic_fee\tint64\t\tThe amount of fees to be charged.\nPrevious\nCross Chain Consensus\nNext\nTutorials\nTypes\nacs12.UserContractMethodFees\nacs12.UserContractMethodFee\nPlatform\nTechnology\nAudit Report\nPrivacy\nTerms of Use\nCookie Policy\nDeveloper Resources\nQuick Start\nLearn\nDocs\nTools\nResources\nEcosystem\nOverview\ndApps\naelf Ventures\nBlog\nConnect\nContact Us\nCopyright © 2024 aelf"
    },
    {
      "title": "AELF Docs",
      "url": "https://docs.aelf.com/learn/acs-introduction/acs10-dividend-pool-standard/",
      "html": "Skip to main content\nQuick Start\nLearn\nDocs\nTools\nResources\nBlog\nSearch\nUnderstanding aelf\nCore\nCross Chain\nConsensus\nNetwork\nBoot Sequence\nAddresses\nTransactions\nSmart Contract\nACS\nContract Deployment\nTransaction Fee\nParallel Execution\nContract Proposal\nConsensus\nContract Threshold\nRandom Number\nContract CrossChain\nToken Fee\nProfit Dividend\nDividend Pool\nCross Chain Consensus\nUser Contract\nTutorials\nNode Operator\nUnderstanding aelfACSDividend Pool\nACS10 - Dividend Pool Standard\n\nACS10 facilitates the creation and management of dividend pools within a contract.\n\nInterface​\n\nTo create a dividend pool, implement these optional interfaces:\n\nMethods​\nMethod Name\tRequest Type\tResponse Type\tDescription\nDonate\tacs10.DonateInput\tgoogle.protobuf.Empty\tTransfers tokens from the caller to the dividend pool. Converts non-native tokens to native tokens if required.\nRelease\tacs10.ReleaseInput\tgoogle.protobuf.Empty\tReleases dividends based on the specified period number.\nSetSymbolList\tacs10.SymbolList\tgoogle.protobuf.Empty\tSets the list of token symbols supported by the dividend pool.\nGetSymbolList\tgoogle.protobuf.Empty\tacs10.SymbolList\tRetrieves the list of token symbols supported by the dividend pool.\nGetUndistributedDividends\tgoogle.protobuf.Empty\tacs10.Dividends\tQueries the balance of undistributed tokens according to the symbol list.\nGetDividends\tgoogle.protobuf.Int64Value\tacs10.Dividends\tQueries dividend information based on the specified height.\nTypes​\nacs10.Dividends​\nField\tType\tDescription\tLabel\nvalue\tDividends.ValueEntry\tThe dividends, symbol -> amount.\trepeated\nacs10.Dividends.ValueEntry​\nField\tType\tDescription\tLabel\nkey\tstring\t\t\nvalue\tint64\t\t\nacs10.DonateInput​\nField\tType\tDescription\tLabel\nsymbol\tstring\tThe token symbol to donate.\t\namount\tint64\tThe amount to donate.\t\nacs10.DonationReceived​\nField\tType\tDescription\tLabel\nfrom\taelf.Address\tThe address of donors.\t\npool_contract\taelf.Address\tThe address of dividend pool.\t\nsymbol\tstring\tThe token symbol Donated.\t\namount\tint64\tThe amount Donated.\t\nacs10.ReleaseInput​\nField\tType\tDescription\tLabel\nperiod_number\tint64\tThe period number to release.\t\nacs10.SymbolList​\nField\tType\tDescription\tLabel\nvalue\tstring\tThe token symbol list.\trepeated\naelf.Address​\nField\tType\tDescription\tLabel\nvalue\tbytes\t\t\naelf.BinaryMerkleTree​\nField\tType\tDescription\tLabel\nnodes\tHash\tThe leaf nodes.\t\nroot\tHash\tThe root node hash.\trepeated\nleaf_count\tint32\tThe count of leaf node.\t\naelf.Hash​\nField\tType\tDescription\tLabel\nvalue\tbytes\t\t\naelf.LogEvent​\nField\tType\tDescription\tLabel\naddress\tAddress\tThe contract address.\t\nname\tstring\tThe name of the log event.\t\nindexed\tbytes\tThe indexed data, used to calculate bloom.\trepeated\nnon_indexed\tbytes\tThe non indexed data.\trepeated\naelf.MerklePath​\nField\tType\tDescription\tLabel\nmerkle_path_nodes\tMerklePathNode\tThe merkle path nodes.\trepeated\naelf.MerklePathNode​\nField\tType\tDescription\tLabel\nhash\tHash\tThe node hash.\t\nis_left_child_node\tbool\tWhether it is a left child node.\t\naelf.SInt32Value​\nField\tType\tDescription\tLabel\nvalue\tsint32\t\t\naelf.SInt64Value​\nField\tType\tDescription\tLabel\nvalue\tsint64\t\t\naelf.ScopedStatePath​\nField\tType\tDescription\tLabel\naddress\tAddress\tThe scope address.\t\npath\tStatePath\tThe path of contract state.\t\naelf.SmartContractRegistration​\nField\tType\tDescription\tLabel\ncategory\tsint32\tThe category of contract code (0: C#).\t\ncode\tbytes\tThe byte array of the contract code.\t\ncode_hash\tHash\tThe hash of the contract code.\t\nis_system_contract\tbool\tWhether it is a system contract.\t\nversion\tint32\tThe version of the current contract.\t\naelf.StatePath​\nField\tType\tDescription\tLabel\nparts\tstring\tThe partial path of the state path.\trepeated\naelf.Transaction​\nField\tType\tDescription\tLabel\nfrom\tAddress\tThe address of the sender of the transaction.\t\nto\tAddress\tThe address of the contract when calling a contract.\t\nref_block_number\tint64\tThe height of the referenced block hash.\t\nref_block_prefix\tbytes\tThe first four bytes of the referenced block hash.\t\nmethod_name\tstring\tThe name of a method in the smart contract at the To address.\t\nparams\tbytes\tThe parameters to pass to the smart contract method.\t\nsignature\tbytes\tWhen signing a transaction, subset of fields: from/to, target method, parameter, reference block number, prefix.\t\naelf.TransactionExecutingStateSet​\nField\tType\tDescription\tLabel\nwrites\tTransactionExecutingStateSet.WritesEntry\tThe changed states.\trepeated\nreads\tTransactionExecutingStateSet.ReadsEntry\tThe read states.\trepeated\ndeletes\tTransactionExecutingStateSet.DeletesEntry\tThe deleted states.\trepeated\naelf.TransactionExecutingStateSet.DeletesEntry​\nField\tType\tDescription\tLabel\nkey\tstring\t\t\nvalue\tbool\t\t\naelf.TransactionExecutingStateSet.ReadsEntry​\nField\tType\tDescription\tLabel\nkey\tstring\t\t\nvalue\tbool\t\t\naelf.TransactionExecutingStateSet.WritesEntry​\nField\tType\tDescription\tLabel\nkey\tstring\t\t\nvalue\tbytes\t\t\naelf.TransactionResult​\nField\tType\tDescription\tLabel\ntransaction_id\tHash\tThe transaction id.\t\nstatus\tTransactionResultStatus\tThe transaction result status.\t\nlogs\tLogEvent\tThe log events.\trepeated\nbloom\tbytes\tBloom filter for transaction logs.\trepeated\nreturn_value\tbytes\tThe return value of the transaction execution.\t\nblock_number\tint64\tThe height of the block that packages the transaction.\t\nblock_hash\tHash\tThe hash of the block that packages the transaction.\t\nerror\tstring\tFailed execution error message.\t\naelf.TransactionResultStatus​\nName\tNumber\tDescription\nNOT_EXISTED\t0\tThe execution result of the transaction does not exist.\nPENDING\t1\tThe transaction is in the transaction pool waiting to be packaged.\nFAILED\t2\tTransaction execution failed.\nMINED\t3\tThe transaction was successfully executed and packaged into a block.\nCONFLICT\t4\tWhen executed in parallel, there are conflicts with other transactions.\nPENDING_VALIDATION\t5\tThe transaction is waiting for validation.\nNODE_VALIDATION_FAILED\t6\tTransaction validation failed.\nUsage​\n\nACS10 provides a standardized interface for dividend pools, independent of aelf chain interactions.\n\nImplementation​\nUsing the Profit Contract\nState.ProfitContract.Value =\n    Context.GetContractAddressByName(SmartContractConstants.ProfitContractSystemName);\nvar schemeToken = HashHelper.ComputeFrom(Context.Self);\nState.ProfitContract.CreateScheme.Send(new CreateSchemeInput\n{\n    Manager = Context.Self,\n    CanRemoveBeneficiaryDirectly = true,\n    IsReleaseAllBalanceEveryTimeByDefault = true,\n    Token = schemeToken\n});\nState.ProfitSchemeId.Value = Context.GenerateId(State.ProfitContract.Value, schemeToken);\n\nUsing the TokenHolder Contract\nState.TokenHolderContract.Value =\n    Context.GetContractAddressByName(SmartContractConstants.TokenHolderContractSystemName);\nState.TokenHolderContract.CreateScheme.Send(new CreateTokenHolderProfitSchemeInput\n{\n    Symbol = Context.Variables.NativeSymbol,\n    MinimumLockMinutes = input.MinimumLockMinutes\n});\nreturn new Empty();\n\nDonate can be implemented as:\npublic override Empty Donate(DonateInput input)\n{\n    State.TokenContract.TransferFrom.Send(new TransferFromInput\n    {\n        From = Context.Sender,\n        Symbol = input.Symbol,\n        Amount = input.Amount,\n        To = Context.Self\n    });\n    State.TokenContract.Approve.Send(new ApproveInput\n    {\n        Symbol = input.Symbol,\n        Amount = input.Amount,\n        Spender = State.TokenHolderContract.Value\n    });\n    State.TokenHolderContract.ContributeProfits.Send(new ContributeProfitsInput\n    {\n        SchemeManager = Context.Self,\n        Symbol = input.Symbol,\n        Amount = input.Amount\n    });\n    Context.Fire(new DonationReceived\n    {\n        From = Context.Sender,\n        Symbol = input.Symbol,\n        Amount = input.Amount,\n        PoolContract = Context.Self\n    });\n    var currentReceivedDividends = State.ReceivedDividends[Context.CurrentHeight];\n    if (currentReceivedDividends != null && currentReceivedDividends.Value.ContainsKey(input.Symbol))\n    {\n        currentReceivedDividends.Value[input.Symbol] =\n            currentReceivedDividends.Value[input.Symbol].Add(input.Amount);\n    }\n    else\n    {\n        currentReceivedDividends = new Dividends\n        {\n            Value =\n            {\n                {\n                    input.Symbol, input.Amount\n                }\n            }\n        };\n    }\n    State.ReceivedDividends[Context.CurrentHeight] = currentReceivedDividends;\n    Context.LogDebug(() => string.Format(\"Contributed {0} {1}s to side chain dividends pool.\", input.Amount, input.Symbol));\n    return new Empty();\n}\n\nThe method Release directly sends the TokenHolder’s method DistributeProfits transaction:\npublic override Empty Release(ReleaseInput input)\n{\n    State.TokenHolderContract.DistributeProfits.Send(new DistributeProfitsInput\n    {\n        SchemeManager = Context.Self\n    });\n    return new Empty();\n}\n\nGetSymbolList returns the symbol list recorded in dividend scheme:\npublic override SymbolList GetSymbolList(Empty input)\n{\n    return new SymbolList\n    {\n        Value =\n        {\n            GetDividendPoolScheme().ReceivedTokenSymbols\n        }\n    };\n}\nprivate Scheme GetDividendPoolScheme()\n{\n    if (State.DividendPoolSchemeId.Value == null)\n    {\n        var tokenHolderScheme = State.TokenHolderContract.GetScheme.Call(Context.Self);\n        State.DividendPoolSchemeId.Value = tokenHolderScheme.SchemeId;\n    }\n    return Context.Call<Scheme>(\n        Context.GetContractAddressByName(SmartContractConstants.ProfitContractSystemName),\n        nameof(ProfitContractContainer.ProfitContractReferenceState.GetScheme),\n        State.DividendPoolSchemeId.Value);\n}\n\nImplementation of GetUndistributedDividends returns the balance (same as previous section):\npublic override Dividends GetUndistributedDividends(Empty input)\n{\n    var scheme = GetDividendPoolScheme();\n    return new Dividends\n    {\n        Value =\n        {\n            scheme.ReceivedTokenSymbols.Select(s => State.TokenContract.GetBalance.Call(new GetBalanceInput\n            {\n                Owner = scheme.VirtualAddress,\n                Symbol = s\n            })).ToDictionary(b => b.Symbol, b => b.Balance)\n        }\n    };\n}\n\nTest​\n\nTesting includes sending Donate, Release transactions, and querying operations. Example:\n\nDefine the required Stubs:\nconst long amount = 10_00000000;\nvar keyPair = SampleECKeyPairs.KeyPairs[0];\nvar address = Address.FromPublicKey(keyPair.PublicKey);\nvar acs10DemoContractStub =\n    GetTester<ACS10DemoContractContainer.ACS10DemoContractStub>(DAppContractAddress, keyPair);\nvar tokenContractStub =\n    GetTester<TokenContractContainer.TokenContractStub>(TokenContractAddress, keyPair);\nvar tokenHolderContractStub =\n    GetTester<TokenHolderContractContainer.TokenHolderContractStub>(TokenHolderContractAddress,\n        keyPair);\n\nApprove the TokenHolder contract and the dividend pool contract\nawait tokenContractStub.Approve.SendAsync(new ApproveInput\n{\n    Spender = TokenHolderContractAddress,\n    Symbol = \"ELF\",\n    Amount = long.MaxValue\n});\nawait tokenContractStub.Approve.SendAsync(new ApproveInput\n{\n    Spender = DAppContractAddress,\n    Symbol = \"ELF\",\n    Amount = long.MaxValue\n});\n\nLock the position to reducethe account balance by 10 ELF:\nawait tokenHolderContractStub.RegisterForProfits.SendAsync(new RegisterForProfitsInput\n{\n    SchemeManager = DAppContractAddress,\n    Amount = amount\n});\n\nImplement Donate to reduce the account balance by another 10 ELF:\nawait acs10DemoContractStub.Donate.SendAsync(new DonateInput\n{\n    Symbol = \"ELF\",\n    Amount = amount\n});\n\nTest the GetUndistributedDividends and GetDividends:\n// Check undistributed dividends before releasing.\n{\n    var undistributedDividends =\n        await acs10DemoContractStub.GetUndistributedDividends.CallAsync(new Empty());\n    undistributedDividends.Value[\"ELF\"].ShouldBe(amount);\n}\nvar blockchainService = Application.ServiceProvider.GetRequiredService<IBlockchainService>();\nvar currentBlockHeight = (await blockchainService.GetChainAsync()).BestChainHeight;\nvar dividends =\n    await acs10DemoContractStub.GetDividends.CallAsync(new Int64Value {Value = currentBlockHeight});\ndividends.Value[\"ELF\"].ShouldBe(amount);\n\nRelease bonus, and test GetUndistributedDividends again:\nawait acs10DemoContractStub.Release.SendAsync(new ReleaseInput\n{\n    PeriodNumber = 1\n});\n// Check undistributed dividends after releasing.\n{\n    var undistributedDividends =\n        await acs10DemoContractStub.GetUndistributedDividends.CallAsync(new Empty());\n    undistributedDividends.Value[\"ELF\"].ShouldBe(0);\n}\n\nAccount will receive the dividend and will change the balance:\nvar balanceBeforeClaimForProfits = await tokenContractStub.GetBalance.CallAsync(new GetBalanceInput\n{\n    Owner = address,\n    Symbol = \"ELF\"\n});\nawait tokenHolderContractStub.ClaimProfits.SendAsync(new ClaimProfitsInput\n{\n    SchemeManager = DAppContractAddress,\n    Beneficiary = address\n});\nvar balanceAfterClaimForProfits = await tokenContractStub.GetBalance.CallAsync(new GetBalanceInput\n{\n    Owner = address,\n    Symbol = \"ELF\"\n});\nbalanceAfterClaimForProfits.Balance.ShouldBe(balanceBeforeClaimForProfits.Balance + amount);\n\nExample​\n\nImplementing ACS10 facilitates building dividend pools on main and side chains.\n\nPrevious\nProfit Dividend\nNext\nCross Chain Consensus\nInterface\nMethods\nTypes\nUsage\nImplementation\nTest\nExample\nPlatform\nTechnology\nAudit Report\nPrivacy\nTerms of Use\nCookie Policy\nDeveloper Resources\nQuick Start\nLearn\nDocs\nTools\nResources\nEcosystem\nOverview\ndApps\naelf Ventures\nBlog\nConnect\nContact Us\nCopyright © 2024 aelf"
    },
    {
      "title": "AELF Docs",
      "url": "https://docs.aelf.com/learn/acs-introduction/acs9-contract-profit-dividend-standard/",
      "html": "Skip to main content\nQuick Start\nLearn\nDocs\nTools\nResources\nBlog\nSearch\nUnderstanding aelf\nCore\nCross Chain\nConsensus\nNetwork\nBoot Sequence\nAddresses\nTransactions\nSmart Contract\nACS\nContract Deployment\nTransaction Fee\nParallel Execution\nContract Proposal\nConsensus\nContract Threshold\nRandom Number\nContract CrossChain\nToken Fee\nProfit Dividend\nDividend Pool\nCross Chain Consensus\nUser Contract\nTutorials\nNode Operator\nUnderstanding aelfACSProfit Dividend\nACS9 - Contract Profit Dividend Standard\n\nACS9 defines a standard for distributing profits on aelf's side chain contracts.\n\nInterface​\n\nACS9 includes several methods given below:\n\nMethods​\nMethod Name\tRequest Type\tResponse Type\tDescription\nTakeContractProfits\tacs9.TakeContractProfitsInput\tgoogle.protobuf.Empty\tAllows developers to collect contract profits.\nGetProfitConfig\tgoogle.protobuf.Empty\tacs9.ProfitConfig\tRetrieves profit distribution configuration.\nGetProfitsAmount\tgoogle.protobuf.Empty\tacs9.ProfitsMap\tQueries total profits accumulated by the contract.\nTypes​\nacs9.ProfitConfig​\nField\tType\tDescription\tLabel\ndonation_parts_per_hundred\tint32\tPercentage of profit donated to dividend pool.\t\nprofits_token_symbol_list\tstring\tList of profit token symbols.\trepeated\nstaking_token_symbol\tstring\tToken symbol users can lock to claim profits.\t\nacs9.ProfitsMap​\nField\tType\tDescription\tLabel\nvalue\tmap<string, int64>\tProfits accumulated, symbol -> amount.\trepeated\nacs9.TakeContractProfitsInput​\nField\tType\tDescription\tLabel\nsymbol\tstring\tToken symbol to withdraw profits.\t\namount\tint64\tAmount of token to withdraw.\t\nImplementation​\n\nThe contract initializes by creating a token called APP and establishing a profit distribution scheme using the TokenHolder contract. Users receive 10 APP tokens upon signing up and can deposit ELF to receive APP tokens. The Use method consumes APP tokens.\n\nUpon initialization, ACS9 sets the profit configuration and enables profit distribution to the profit receiver and dividend pool.\n\nThe contract allows users to interact by signing up, depositing and withdrawing tokens, and using APP tokens for transactions. Developers can configure profit distribution settings and monitor accumulated profits.\n\nImplementation of Initialize\npublic override Empty Initialize(InitializeInput input)\n{\n    State.TokenHolderContract.Value =\n        Context.GetContractAddressByName(SmartContractConstants.TokenHolderContractSystemName);\n    State.TokenContract.Value =\n        Context.GetContractAddressByName(SmartContractConstants.TokenContractSystemName);\n    State.DividendPoolContract.Value =\n        Context.GetContractAddressByName(input.DividendPoolContractName.Value.ToBase64());\n    State.Symbol.Value = input.Symbol == string.Empty ? \"APP\" : input.Symbol;\n    State.ProfitReceiver.Value = input.ProfitReceiver;\n    CreateToken(input.ProfitReceiver);\n    // To test TokenHolder Contract.\n    CreateTokenHolderProfitScheme();\n    // To test ACS9 workflow.\n    SetProfitConfig();\n    State.ProfitReceiver.Value = input.ProfitReceiver;\n    return new Empty();\n}\nprivate void CreateToken(Address profitReceiver, bool isLockWhiteListIncludingSelf = false)\n{\n    var lockWhiteList = new List<Address>\n        {Context.GetContractAddressByName(SmartContractConstants.TokenHolderContractSystemName)};\n    if (isLockWhiteListIncludingSelf)\n        lockWhiteList.Add(Context.Self);\n    State.TokenContract.Create.Send(new CreateInput\n    {\n        Symbol = State.Symbol.Value,\n        TokenName = \"DApp Token\",\n        Decimals = ACS9DemoContractConstants.Decimal,\n        Issuer = Context.Self,\n        IsBurnable = true,\n        IsProfitable = true,\n        TotalSupply = ACS9DemoContractConstants.TotalSupply,\n        LockWhiteList =\n        {\n            lockWhiteList\n        }\n    });\n    State.TokenContract.Issue.Send(new IssueInput\n    {\n        To = profitReceiver,\n        Amount = ACS9DemoContractConstants.TotalSupply / 5,\n        Symbol = State.Symbol.Value,\n        Memo = \"Issue token for profit receiver\"\n    });\n}\nprivate void CreateTokenHolderProfitScheme()\n{\n    State.TokenHolderContract.CreateScheme.Send(new CreateTokenHolderProfitSchemeInput\n    {\n        Symbol = State.Symbol.Value\n    });\n}\nprivate void SetProfitConfig()\n{\n    State.ProfitConfig.Value = new ProfitConfig\n    {\n        DonationPartsPerHundred = 1,\n        StakingTokenSymbol = \"APP\",\n        ProfitsTokenSymbolList = {\"ELF\"}\n    };\n}\n\nThe user can use the SighUp method to register and get the bonus\n/// <summary>\n/// When user sign up, give him 10 APP tokens, then initialize his profile.\n/// </summary>\n/// <param name=\"input\"></param>\n/// <returns></returns>\npublic override Empty SignUp(Empty input)\n{\n    Assert(State.Profiles[Context.Sender] == null, \"Already registered.\");\n    var profile = new Profile\n    {\n        UserAddress = Context.Sender\n    };\n    State.TokenContract.Issue.Send(new IssueInput\n    {\n        Symbol = State.Symbol.Value,\n        Amount = ACS9DemoContractConstants.ForNewUser,\n        To = Context.Sender\n    });\n    // Update profile.\n    profile.Records.Add(new Record\n    {\n        Type = RecordType.SignUp,\n        Timestamp = Context.CurrentBlockTime,\n        Description = string.Format(\"{0} +{1}\",State.Symbol.Value, ACS9DemoContractConstants.ForNewUser)\n    });\n    State.Profiles[Context.Sender] = profile;\n    return new Empty();\n}\n\nRecharge and redemption:\npublic override Empty Deposit(DepositInput input)\n{\n    // User Address -> DApp Contract.\n    State.TokenContract.TransferFrom.Send(new TransferFromInput\n    {\n        From = Context.Sender,\n        To = Context.Self,\n        Symbol = \"ELF\",\n        Amount = input.Amount\n    });\n    State.TokenContract.Issue.Send(new IssueInput\n    {\n        Symbol = State.Symbol.Value,\n        Amount = input.Amount,\n        To = Context.Sender\n    });\n    // Update profile.\n    var profile = State.Profiles[Context.Sender];\n    profile.Records.Add(new Record\n    {\n        Type = RecordType.Deposit,\n        Timestamp = Context.CurrentBlockTime,\n        Description = string.Format(\"{0} +{1}\", State.Symbol.Value, input.Amount)\n    });\n    State.Profiles[Context.Sender] = profile;\n    return new Empty();\n}\npublic override Empty Withdraw(WithdrawInput input)\n{\n    State.TokenContract.TransferFrom.Send(new TransferFromInput\n    {\n        From = Context.Sender,\n        To = Context.Self,\n        Symbol = State.Symbol.Value,\n        Amount = input.Amount\n    });\n    State.TokenContract.Transfer.Send(new TransferInput\n    {\n        To = Context.Sender,\n        Symbol = input.Symbol,\n        Amount = input.Amount\n    });\n    State.TokenHolderContract.RemoveBeneficiary.Send(new RemoveTokenHolderBeneficiaryInput\n    {\n        Beneficiary = Context.Sender,\n        Amount = input.Amount\n    });\n    // Update profile.\n    var profile = State.Profiles[Context.Sender];\n    profile.Records.Add(new Record\n    {\n        Type = RecordType.Withdraw,\n        Timestamp = Context.CurrentBlockTime,\n        Description = string.Format(\"{0} -{1}\", State.Symbol.Value, input.Amount)\n    });\n    State.Profiles[Context.Sender] = profile;\n    return new Empty();\n}\n\nImplementation of Use directly transfers 1/3 profits into the token holder dividend scheme:\npublic override Empty Use(Record input)\n{\n    State.TokenContract.TransferFrom.Send(new TransferFromInput\n    {\n        From = Context.Sender,\n        To = Context.Self,\n        Symbol = State.Symbol.Value,\n        Amount = ACS9DemoContractConstants.UseFee\n    });\n    if (input.Symbol == string.Empty)\n        input.Symbol = State.TokenContract.GetPrimaryTokenSymbol.Call(new Empty()).Value;\n    var contributeAmount = ACS9DemoContractConstants.UseFee.Div(3);\n    State.TokenContract.Approve.Send(new ApproveInput\n    {\n        Spender = State.TokenHolderContract.Value,\n        Symbol = input.Symbol,\n        Amount = contributeAmount\n    });\n    // Contribute 1/3 profits (ELF) to profit scheme.\n    State.TokenHolderContract.ContributeProfits.Send(new ContributeProfitsInput\n    {\n        SchemeManager = Context.Self,\n        Amount = contributeAmount,\n        Symbol = input.Symbol\n    });\n    // Update profile.\n    var profile = State.Profiles[Context.Sender];\n    profile.Records.Add(new Record\n    {\n        Type = RecordType.Withdraw,\n        Timestamp = Context.CurrentBlockTime,\n        Description = string.Format(\"{0} -{1}\", State.Symbol.Value, ACS9DemoContractConstants.UseFee),\n        Symbol = input.Symbol\n    });\n    State.Profiles[Context.Sender] = profile;\n    return new Empty();\n}\n\nImplement ACS9 for the perfect profit distribution:\npublic override Empty TakeContractProfits(TakeContractProfitsInput input)\n{\n    var config = State.ProfitConfig.Value;\n    // For Side Chain Dividends Pool.\n    var amountForSideChainDividendsPool = input.Amount.Mul(config.DonationPartsPerHundred).Div(100);\n    State.TokenContract.Approve.Send(new ApproveInput\n    {\n        Symbol = input.Symbol,\n        Amount = amountForSideChainDividendsPool,\n        Spender = State.DividendPoolContract.Value\n    });\n    State.DividendPoolContract.Donate.Send(new DonateInput\n    {\n        Symbol = input.Symbol,\n        Amount = amountForSideChainDividendsPool\n    });\n    // For receiver.\n    var amountForReceiver = input.Amount.Sub(amountForSideChainDividendsPool);\n    State.TokenContract.Transfer.Send(new TransferInput\n    {\n        To = State.ProfitReceiver.Value,\n        Amount = amountForReceiver,\n        Symbol = input.Symbol\n    });\n    // For Token Holder Profit Scheme. (To distribute.)\n    State.TokenHolderContract.DistributeProfits.Send(new DistributeProfitsInput\n    {\n        SchemeManager = Context.Self\n    });\n    return new Empty();\n}\npublic override ProfitConfig GetProfitConfig(Empty input)\n{\n    return State.ProfitConfig.Value;\n}\npublic override ProfitsMap GetProfitsAmount(Empty input)\n{\n    var profitsMap = new ProfitsMap();\n    foreach (var symbol in State.ProfitConfig.Value.ProfitsTokenSymbolList)\n    {\n        var balance = State.TokenContract.GetBalance.Call(new GetBalanceInput\n        {\n            Owner = Context.Self,\n            Symbol = symbol\n        }).Balance;\n        profitsMap.Value[symbol] = balance;\n    }\n    return profitsMap;\n}\n\nTest​\n\nTesting involves deploying contracts implementing ACS9 or ACS10, initializing the ACS9 contract using IContractInitializationProvider, and verifying profit distribution among stakeholders.\n\nBefore the testing begins, the contract implementing ACS9 can be initialized by interface IContractInitializationProvider\npublic class ACS9DemoContractInitializationProvider : IContractInitializationProvider\n{\n    public List<InitializeMethod> GetInitializeMethodList(byte[] contractCode)\n    {\n        return new List<InitializeMethod>\n        {\n            new InitializeMethod\n            {\n                MethodName = nameof(ACS9DemoContract.Initialize),\n                Params = new InitializeInput\n                {\n                    ProfitReceiver = Address.FromPublicKey(SampleECKeyPairs.KeyPairs.Skip(3).First().PublicKey),\n                    DividendPoolContractName = ACS10DemoSmartContractNameProvider.Name\n                }.ToByteString()\n            }\n        };\n    }\n    public Hash SystemSmartContractName { get; } = ACS9DemoSmartContractNameProvider.Name;\n    public string ContractCodeName { get; } = \"AElf.Contracts.ACS9DemoContract\";\n}\n\nPrepare a user account:\nprotected List<ECKeyPair> UserKeyPairs => SampleECKeyPairs.KeyPairs.Skip(2).Take(3).ToList();\n\nPrepare some Stubs:\nvar keyPair = UserKeyPairs[0];\nvar address = Address.FromPublicKey(keyPair.PublicKey);\n// Prepare stubs.\nvar acs9DemoContractStub = GetACS9DemoContractStub(keyPair);\nvar acs10DemoContractStub = GetACS10DemoContractStub(keyPair);\nvar userTokenStub =\n    GetTester<TokenContractImplContainer.TokenContractImplStub>(TokenContractAddress, UserKeyPairs[0]);\nvar userTokenHolderStub =\n    GetTester<TokenHolderContractContainer.TokenHolderContractStub>(TokenHolderContractAddress,\n        UserKeyPairs[0]);\n\nThen, transfer ELF to the user (TokenContractStub is the Stub of the initial bp who has much ELF) :\n// Transfer some ELFs to user.\nawait TokenContractStub.Transfer.SendAsync(new TransferInput\n{\n    To = address,\n    Symbol = \"ELF\",\n    Amount = 1000_00000000\n});\n\nUser have to call SignUp to check if they got 10 APP tokens:\nawait acs9DemoContractStub.SignUp.SendAsync(new Empty());\n// User has 10 APP tokens because of signing up.\n(await GetFirstUserBalance(\"APP\")).ShouldBe(10_00000000);\n\nTest the recharge method of the contract itself:\nvar elfBalanceBefore = await GetFirstUserBalance(\"ELF\");\n// User has to Approve an amount of ELF tokens before deposit to the DApp.\nawait userTokenStub.Approve.SendAsync(new ApproveInput\n{\n    Amount = 1000_00000000,\n    Spender = ACS9DemoContractAddress,\n    Symbol = \"ELF\"\n});\nawait acs9DemoContractStub.Deposit.SendAsync(new DepositInput\n{\n    Amount = 100_00000000\n});\n// Check the change of balance of ELF.\nvar elfBalanceAfter = await GetFirstUserBalance(\"ELF\");\nelfBalanceAfter.ShouldBe(elfBalanceBefore - 100_00000000);\n// Now user has 110 APP tokens.\n(await GetFirstUserBalance(\"APP\")).ShouldBe(110_00000000);\n\nThe user locks up 57 APP via the TokenHolder contract in order to obtain profits from the contract:\n// User lock some APP tokens for getting profits. (APP -57)\nawait userTokenHolderStub.RegisterForProfits.SendAsync(new RegisterForProfitsInput\n{\n    SchemeManager = ACS9DemoContractAddress,\n    Amount = 57_00000000\n});\n\nThe Use method is invoked 10 times and 0.3 APP is consumed each time, and finally the user have 50 APP left:\nawait userTokenStub.Approve.SendAsync(new ApproveInput\n{\n    Amount = long.MaxValue,\n    Spender = ACS9DemoContractAddress,\n    Symbol = \"APP\"\n});\n// User uses 10 times of this DApp. (APP -3)\nfor (var i = 0; i < 10; i++)\n{\n    await acs9DemoContractStub.Use.SendAsync(new Record());\n}\n// Now user has 50 APP tokens.\n(await GetFirstUserBalance(\"APP\")).ShouldBe(50_00000000);\n\nUsing the TakeContractProfits method, the developer attempts to withdraw 10 ELF as profits. The 10 ELF will be transferred to the developer in this method:\nconst long baseBalance = 0;\n{\n    var balance = await TokenContractStub.GetBalance.CallAsync(new GetBalanceInput\n    {\n        Owner = UserAddresses[1], Symbol = \"ELF\"\n    });\n    balance.Balance.ShouldBe(baseBalance);\n}\n// Profits receiver claim 10 ELF profits.\nawait acs9DemoContractStub.TakeContractProfits.SendAsync(new TakeContractProfitsInput\n{\n    Symbol = \"ELF\",\n    Amount = 10_0000_0000\n});\n// Then profits receiver should have 9.9 ELF tokens.\n{\n    var balance = await TokenContractStub.GetBalance.CallAsync(new GetBalanceInput\n    {\n        Owner = UserAddresses[1], Symbol = \"ELF\"\n    });\n    balance.Balance.ShouldBe(baseBalance + 9_9000_0000);\n}\n\nNext check the profit distribution results. The dividend pool should be allocated 0.1 ELF:\n// And Side Chain Dividends Pool should have 0.1 ELF tokens.\n{\n    var scheme = await TokenHolderContractStub.GetScheme.CallAsync(ACS10DemoContractAddress);\n    var virtualAddress = await ProfitContractStub.GetSchemeAddress.CallAsync(new SchemePeriod\n    {\n        SchemeId = scheme.SchemeId,\n        Period = 0\n    });\n    var balance = await TokenContractStub.GetBalance.CallAsync(new GetBalanceInput\n    {\n        Owner = virtualAddress,\n        Symbol = \"ELF\"\n    });\n    balance.Balance.ShouldBe(1000_0000);\n}\n\nThe user receives 1 ELF from the token holder dividend scheme:\n// Help user to claim profits from token holder profit scheme.\nawait TokenHolderContractStub.ClaimProfits.SendAsync(new ClaimProfitsInput\n{\n    Beneficiary = UserAddresses[0],\n    SchemeManager = ACS9DemoContractAddress,\n});\n// Profits should be 1 ELF.\n(await GetFirstUserBalance(\"ELF\")).ShouldBe(elfBalanceAfter + 1_0000_0000);\n\nFinally, let’s test the Withdraw method.\n// Withdraw\nvar beforeBalance =\n    await userTokenStub.GetBalance.CallAsync(new GetBalanceInput\n    {\n        Symbol = \"APP\",\n        Owner = UserAddresses[0]\n    });\nvar withDrawResult = await userTokenHolderStub.Withdraw.SendAsync(ACS9DemoContractAddress);\nwithDrawResult.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined);\nvar resultBalance = await userTokenStub.GetBalance.CallAsync(new GetBalanceInput\n{\n    Symbol = \"APP\",\n    Owner = UserAddresses[0]\n});\nresultBalance.Balance.ShouldBe(beforeBalance.Balance + 57_00000000);\n\n\nThis documentation provides a framework for implementing profit distribution and verifying its functionality through various test scenarios.\n\nPrevious\nToken Fee\nNext\nDividend Pool\nInterface\nMethods\nTypes\nImplementation\nTest\nPlatform\nTechnology\nAudit Report\nPrivacy\nTerms of Use\nCookie Policy\nDeveloper Resources\nQuick Start\nLearn\nDocs\nTools\nResources\nEcosystem\nOverview\ndApps\naelf Ventures\nBlog\nConnect\nContact Us\nCopyright © 2024 aelf"
    },
    {
      "title": "AELF Docs",
      "url": "https://docs.aelf.com/learn/acs-introduction/acs8-transaction-resource-token-fee-standard/",
      "html": "Skip to main content\nQuick Start\nLearn\nDocs\nTools\nResources\nBlog\nSearch\nUnderstanding aelf\nCore\nCross Chain\nConsensus\nNetwork\nBoot Sequence\nAddresses\nTransactions\nSmart Contract\nACS\nContract Deployment\nTransaction Fee\nParallel Execution\nContract Proposal\nConsensus\nContract Threshold\nRandom Number\nContract CrossChain\nToken Fee\nProfit Dividend\nDividend Pool\nCross Chain Consensus\nUser Contract\nTutorials\nNode Operator\nUnderstanding aelfACSToken Fee\nACS8 - Transaction Resource Token Fee Standard\n\nACS8 is a transaction fee standard similar to ACS1, but it charges the called contract rather than the user. The fee charged includes four specified tokens: WRITE, READ, NET, and TRAFFIC.\n\nWhen a contract inherits from ACS8, each transaction within this contract incurs charges in these four resource tokens.\n\nInterface​\n\nThe acs8.proto file defines the following method:\n\nMethods​\nMethod Name\tRequest Type\tResponse Type\tDescription\nBuyResourceToken\tacs8.BuyResourceTokenInput\tgoogle.protobuf.Empty\tBuys one of the four resource tokens. Consumes ELF balance in the contract account.\nTypes​\nacs8.BuyResourceTokenInput​\nField\tType\tDescription\tLabel\nsymbol\tstring\tThe symbol of the token to buy.\t\namount\tint64\tThe amount of token to buy.\t\npay_limit\tint64\tLimit of cost; buying is abandoned if exceeded. 0 means no limit.\t\nUsage​\n\nContracts inheriting ACS1 use a pre-plugin transaction called ChargeTransactionFees for transaction fee charging. ACS8 introduces a similar post-plugin transaction called ChargeResourceToken, which charges resource tokens based on actual transaction consumption.\n\nThe ChargeResourceToken implementation involves calculating token amounts using polynomial coefficients stored in CalculateFeeCoefficients defined in token_contract.proto. Each resource token has a polynomial for fee calculation, which determines the cost based on transaction consumption.\n\npublic override Empty ChargeResourceToken(ChargeResourceTokenInput input)\n{\n    Context.LogDebug(() => string.Format(\"Start executing ChargeResourceToken.{0}\", input));\n    if (input.Equals(new ChargeResourceTokenInput()))\n    {\n        return new Empty();\n    }\n    var bill = new TransactionFeeBill();\n    foreach (var pair in input.CostDic)\n    {\n        Context.LogDebug(() => string.Format(\"Charging {0} {1} tokens.\", pair.Value, pair.Key));\n        var existingBalance = GetBalance(Context.Sender, pair.Key);\n        Assert(existingBalance >= pair.Value,\n            string.Format(\"Insufficient resource of {0}. Need balance: {1}; Current balance: {2}.\", pair.Key, pair.Value, existingBalance));\n        bill.FeesMap.Add(pair.Key, pair.Value);\n    }\n    foreach (var pair in bill.FeesMap)\n    {\n        Context.Fire(new ResourceTokenCharged\n        {\n            Symbol = pair.Key,\n            Amount = pair.Value,\n            ContractAddress = Context.Sender\n        });\n        if (pair.Value == 0)\n        {\n            Context.LogDebug(() => string.Format(\"Maybe incorrect charged resource fee of {0}: it's 0.\", pair.Key));\n        }\n    }\n    return new Empty();\n}\n\n\nAdditionally, contracts cannot execute methods if they lack sufficient resource token balance. To enforce this, a pre-plugin transaction CheckResourceToken, similar to ACS5, verifies the contract's resource token balance before method execution.\n\npublic override Empty CheckResourceToken(Empty input)\n{\n    foreach (var symbol in Context.Variables.GetStringArray(TokenContractConstants.PayTxFeeSymbolListName))\n    {\n        var balance = GetBalance(Context.Sender, symbol);\n        var owningBalance = State.OwningResourceToken[Context.Sender][symbol];\n        Assert(balance > owningBalance,\n            string.Format(\"Contract balance of {0} token is not enough. Owning {1}.\", symbol, owningBalance));\n    }\n    return new Empty();\n}\n\nPrevious\nContract CrossChain\nNext\nProfit Dividend\nInterface\nMethods\nTypes\nUsage\nPlatform\nTechnology\nAudit Report\nPrivacy\nTerms of Use\nCookie Policy\nDeveloper Resources\nQuick Start\nLearn\nDocs\nTools\nResources\nEcosystem\nOverview\ndApps\naelf Ventures\nBlog\nConnect\nContact Us\nCopyright © 2024 aelf"
    },
    {
      "title": "AELF Docs",
      "url": "https://docs.aelf.com/learn/acs-introduction/acs7-cross-chain-standard/",
      "html": "Skip to main content\nQuick Start\nLearn\nDocs\nTools\nResources\nBlog\nSearch\nUnderstanding aelf\nCore\nCross Chain\nConsensus\nNetwork\nBoot Sequence\nAddresses\nTransactions\nSmart Contract\nACS\nContract Deployment\nTransaction Fee\nParallel Execution\nContract Proposal\nConsensus\nContract Threshold\nRandom Number\nContract CrossChain\nToken Fee\nProfit Dividend\nDividend Pool\nCross Chain Consensus\nUser Contract\nTutorials\nNode Operator\nUnderstanding aelfACSContract CrossChain\nACS7 - Contract CrossChain Standard\n\nACS7 is for implementing cross-chain contracts.\n\nInterface​\n\nThis involves methods for chain creation and indexing:\n\nMethods​\nMethod Name\tRequest Type\tResponse Type\tDescription\nProposeCrossChainIndexing\tacs7.CrossChainBlockData\tgoogle.protobuf.Empty\tPropose a cross-chain indexing.\nReleaseCrossChainIndexingProposal\tacs7.ReleaseCrossChainIndexingProposalInput\tgoogle.protobuf.Empty\tRelease the proposed indexing if approved.\nRequestSideChainCreation\tacs7.SideChainCreationRequest\tgoogle.protobuf.Empty\tRequest side chain creation.\nReleaseSideChainCreation\tacs7.ReleaseSideChainCreationInput\tgoogle.protobuf.Empty\tRelease the side chain creation request if approved.\nCreateSideChain\tacs7.CreateSideChainInput\tgoogle.protobuf.Int32Value\tCreate the side chain and return its ID. Only authorized users.\nRecharge\tacs7.RechargeInput\tgoogle.protobuf.Empty\tRecharge a specified side chain.\nDisposeSideChain\tgoogle.protobuf.Int32Value\tgoogle.protobuf.Int32Value\tDispose a side chain by ID. Only authorized users.\nAdjustIndexingFeePrice\tacs7.AdjustIndexingFeeInput\tgoogle.protobuf.Empty\tAdjust side chain indexing fee. Only authorized users.\nVerifyTransaction\tacs7.VerifyTransactionInput\tgoogle.protobuf.BoolValue\tVerify a cross-chain transaction.\nGetSideChainIdAndHeight\tgoogle.protobuf.Empty\tacs7.ChainIdAndHeightDict\tGet all side chain IDs and heights.\nGetSideChainIndexingInformationList\tgoogle.protobuf.Empty\tacs7.SideChainIndexingInformationList\tGet indexing information of side chains.\nGetAllChainsIdAndHeight\tgoogle.protobuf.Empty\tacs7.ChainIdAndHeightDict\tGet IDs and heights of all chains.\nGetIndexedSideChainBlockDataByHeight\tgoogle.protobuf.Int64Value\tacs7.IndexedSideChainBlockData\tGet block data of indexed side chain by height.\nGetBoundParentChainHeightAndMerklePathByHeight\tgoogle.protobuf.Int64Value\tacs7.CrossChainMerkleProofContext\tGet Merkle path bound to side chain by height.\nGetChainInitializationData\tgoogle.protobuf.Int32Value\tacs7.ChainInitializationData\tGet initialization data for a specified side chain.\nTypes​\nacs7.AdjustIndexingFeeInput​\nField\tDescription\tLabel\nside_chain_id (int32)\tThe side chain ID\t\nindexing_fee (int64)\tThe new indexing fee\t\nacs7.ChainIdAndHeightDict​\nField\tDescription\tLabel\nid_height_dict (map<int32, int64>)\tChain IDs and heights\trepeated\nacs7.ChainInitializationData​\nField\tDescription\tLabel\nchain_id (int32)\tSide chain ID\t\ncreator (aelf.Address)\tCreator's address\t\ncreation_timestamp (google.protobuf.Timestamp)\tCreation timestamp\t\ncreation_height_on_parent_chain (int64)\tHeight on parent chain\t\nchain_creator_privilege_preserved (bool)\tIf privilege is preserved\t\nparent_chain_token_contract_address (aelf.Address)\tToken contract address\t\nchain_initialization_consensus_info (ChainInitializationConsensusInfo)\tInitial consensus info\t\nnative_token_info_data (bytes)\tNative token info\t\nresource_token_info (ResourceTokenInfo)\tResource token info\t\nchain_primary_token_info (ChainPrimaryTokenInfo)\tPrimary token info\t\nacs7.CreateSideChainInput​\nField\tDescription\tLabel\nside_chain_creation_request (SideChainCreationRequest)\tCreation request info\t\nproposer (aelf.Address)\tProposer's address\t\nacs7.CrossChainBlockData​\nField\tDescription\tLabel\nside_chain_block_data_list (repeated SideChainBlockData)\tList of side chain block data\trepeated\nparent_chain_block_data_list (repeated ParentChainBlockData)\tList of parent chain block data\trepeated\nacs7.RechargeInput​\nField\tDescription\tLabel\nchain_id (int32)\tSide chain ID\t\namount (int64)\tAmount to recharge\t\nacs7.ReleaseCrossChainIndexingProposalInput​\nField\tDescription\tLabel\nchain_id_list (repeated int32)\tList of chain IDs to release\trepeated\nacs7.ReleaseSideChainCreationInput​\nField\tDescription\tLabel\nproposal_id (aelf.Hash)\tProposal ID\t\nacs7.SideChainCreationRequest​\nField\tDescription\tLabel\nindexing_price (int64)\tCross-chain indexing price\t\nlocked_token_amount (int64)\tInitial locked balance\t\nis_privilege_preserved (bool)\tIf privilege is preserved\t\nside_chain_token_creation_request (SideChainTokenCreationRequest)\tToken creation request\t\nside_chain_token_initial_issue_list (repeated SideChainTokenInitialIssue)\tInitial token issues list\trepeated\ninitial_resource_amount (repeated SideChainCreationRequest.InitialResourceAmountEntry)\tInitial resource amounts\trepeated\nExample​\n\nACS7 defines methods for cross-chain scenarios. aelf provides an implementation for ACS7 called CrossChainContract. Refer to this implementation for more details.\n\nPrevious\nRandom Number\nNext\nToken Fee\nInterface\nMethods\nTypes\nExample\nPlatform\nTechnology\nAudit Report\nPrivacy\nTerms of Use\nCookie Policy\nDeveloper Resources\nQuick Start\nLearn\nDocs\nTools\nResources\nEcosystem\nOverview\ndApps\naelf Ventures\nBlog\nConnect\nContact Us\nCopyright © 2024 aelf"
    },
    {
      "title": "AELF Docs",
      "url": "https://docs.aelf.com/learn/acs-introduction/acs6-random-number-generation/",
      "html": "Skip to main content\nQuick Start\nLearn\nDocs\nTools\nResources\nBlog\nSearch\nUnderstanding aelf\nCore\nCross Chain\nConsensus\nNetwork\nBoot Sequence\nAddresses\nTransactions\nSmart Contract\nACS\nContract Deployment\nTransaction Fee\nParallel Execution\nContract Proposal\nConsensus\nContract Threshold\nRandom Number\nContract CrossChain\nToken Fee\nProfit Dividend\nDividend Pool\nCross Chain Consensus\nUser Contract\nTutorials\nNode Operator\nUnderstanding aelfACSRandom Number\nACS6 - Random Number Provider Standard\n\nTo generate a random number in your contract, use ACS6.\n\nInterface​\n\nTo provide a random number based on input, implement this interface:\n\nMethods​\nMethod Name\tRequest Type\tResponse Type\tDescription\nGetRandomBytes\tgoogle.protobuf.BytesValue\tgoogle.protobuf.BytesValue\tGet the random number provided by the contract.\nUsage​\n\nOverride the GetRandomBytes method to return a random number based on the given input. The logic for generating the random number is up to you. Ensure you return a BytesValue type so the caller can deserialize the output.\n\nImplementation​\n\nThe simplest implementation:\n\npublic override BytesValue GetRandomBytes(BytesValue input)\n{\n    var serializedInput = new GetRandomBytesInput();\n    serializedInput.MergeFrom(input.Value);\n    var value = new Hash();\n    value.MergeFrom(serializedInput.Value);\n    var randomHashFromContext = Context.GetRandomHash(value);\n\n    return new BytesValue\n    {\n        Value = serializedInput.Kind == 1\n            ? new BytesValue {Value = randomHashFromContext.Value}.ToByteString()\n            : new Int64Value {Value = Context.ConvertHashToInt64(randomHashFromContext, 1, 10000)}.ToByteString()\n    };\n}\n\nPrevious\nContract Threshold\nNext\nContract CrossChain\nInterface\nMethods\nUsage\nImplementation\nPlatform\nTechnology\nAudit Report\nPrivacy\nTerms of Use\nCookie Policy\nDeveloper Resources\nQuick Start\nLearn\nDocs\nTools\nResources\nEcosystem\nOverview\ndApps\naelf Ventures\nBlog\nConnect\nContact Us\nCopyright © 2024 aelf"
    },
    {
      "title": "Contract Threshold | AELF Docs",
      "url": "https://docs.aelf.com/learn/acs-introduction/acs5-contract-threshold-standard/",
      "html": "Skip to main content\nQuick Start\nLearn\nDocs\nTools\nResources\nBlog\nSearch\nUnderstanding aelf\nCore\nCross Chain\nConsensus\nNetwork\nBoot Sequence\nAddresses\nTransactions\nSmart Contract\nACS\nContract Deployment\nTransaction Fee\nParallel Execution\nContract Proposal\nConsensus\nContract Threshold\nRandom Number\nContract CrossChain\nToken Fee\nProfit Dividend\nDividend Pool\nCross Chain Consensus\nUser Contract\nTutorials\nNode Operator\nUnderstanding aelfACSContract Threshold\nACS5 - Contract Threshold Standard\n\nTo raise the threshold for using a contract, consider implementing ACS5.\n\nInterface​\n\nTo limit calling a method in a contract, implement these interfaces:\n\nMethods​\nMethod Name\tRequest Type\tResponse Type\tDescription\nSetMethodCallingThreshold\tacs5.SetMethodCallingThresholdInput\tgoogle.protobuf.Empty\tSet the threshold for method calling.\nGetMethodCallingThreshold\tgoogle.protobuf.StringValue\tacs5.MethodCallingThreshold\tGet the threshold for method calling.\nTypes​\nacs5.MethodCallingThreshold​\nField\tType\tDescription\tLabel\nsymbol_to_amount\tMethodCallingThreshold.SymbolToAmountEntry\tThe threshold for method calling, token symbol -> amount.\trepeated\nthreshold_check_type\tThresholdCheckType\tThe type of threshold check.\t\nacs5.MethodCallingThreshold.SymbolToAmountEntry​\nField\tType\tDescription\tLabel\nkey\tstring\t\t\nvalue\tint64\t\t\nacs5.SetMethodCallingThresholdInput​\nField\tType\tDescription\tLabel\nmethod\tstring\tThe method name to check.\t\nsymbol_to_amount\tSetMethodCallingThresholdInput.SymbolToAmountEntry\tThe threshold for method calling, token symbol -> amount.\trepeated\nthreshold_check_type\tThresholdCheckType\tThe type of threshold check.\t\nacs5.SetMethodCallingThresholdInput.SymbolToAmountEntry​\nField\tType\tDescription\tLabel\nkey\tstring\t\t\nvalue\tint64\t\t\nacs5.ThresholdCheckType​\nName\tNumber\tDescription\nBALANCE\t0\tCheck balance only.\nALLOWANCE\t1\tCheck balance and allowance at the same time.\nUsage​\n\nACS5 works similarly to ACS1, which uses a pre-plugin transaction called ChargeTransactionFees to charge a transaction fee. ACS5 uses a pre-plugin transaction called CheckThreshold to ensure the account sending the transaction can invoke the method.\n\nImplementation of CheckThreshold:​\npublic override Empty CheckThreshold(CheckThresholdInput input)\n{\n    var meetThreshold = false;\n    var meetBalanceSymbolList = new List<string>();\n    foreach (var symbolToThreshold in input.SymbolToThreshold)\n    {\n        if (GetBalance(input.Sender, symbolToThreshold.Key) < symbolToThreshold.Value)\n            continue;\n        meetBalanceSymbolList.Add(symbolToThreshold.Key);\n    }\n    if (meetBalanceSymbolList.Count > 0)\n    {\n        if (input.IsCheckAllowance)\n        {\n            foreach (var symbol in meetBalanceSymbolList)\n            {\n                if (State.Allowances[input.Sender][Context.Sender][symbol] <\n                    input.SymbolToThreshold[symbol]) continue;\n                meetThreshold = true;\n                break;\n            }\n        }\n        else\n        {\n            meetThreshold = true;\n        }\n    }\n    if (input.SymbolToThreshold.Count == 0)\n    {\n        meetThreshold = true;\n    }\n    Assert(meetThreshold, \"Cannot meet the calling threshold.\");\n    return new Empty();\n}\n\n\nIf the sender's token balance or the authorized amount for the target contract doesn't meet the set limit, the pre-plugin transaction throws an exception and prevents the original transaction from executing.\n\nImplementation​\n\nImplement a single GetMethodCallingThreshold method like GetMethodFee in ACS1. Use MappedState<string, MethodCallingThreshold> in the State class:\n\npublic MappedState<string, MethodCallingThreshold> MethodCallingThresholds { get; set; }\n\n\nConfigure the call permission of SetMethodCallingThreshold, requiring an Admin in the State:\n\npublic SingletonState<Address> Admin { get; set; }\n\npublic override Empty SetMethodCallingThreshold(SetMethodCallingThresholdInput input)\n{\n    Assert(State.Admin.Value == Context.Sender, \"No permission.\");\n    State.MethodCallingThresholds[input.Method] = new MethodCallingThreshold\n    {\n        SymbolToAmount = {input.SymbolToAmount}\n    };\n    return new Empty();\n}\n\npublic override MethodCallingThreshold GetMethodCallingThreshold(StringValue input)\n{\n    return State.MethodCallingThresholds[input.Value];\n}\n\npublic override Empty Foo(Empty input)\n{\n    return new Empty();\n}\n\nmessage SetMethodCallingThresholdInput {\n    string method = 1;\n    map<string, int64> symbol_to_amount = 2;// The order matters.\n    ThresholdCheckType threshold_check_type = 3;\n}\n\nTest​\n\nTest the Foo method:\n\nMake a Stub\nvar keyPair = SampleECKeyPairs.KeyPairs[0];\nvar acs5DemoContractStub =\n    GetTester<ACS5DemoContractContainer.ACS5DemoContractStub>(DAppContractAddress, keyPair);\n\nCheck the current threshold (should be 0):\nvar methodResult = await acs5DemoContractStub.GetMethodCallingThreshold.CallAsync(\n    new StringValue\n    {\n        Value = nameof(acs5DemoContractStub.Foo)\n    });\nmethodResult.SymbolToAmount.Count.ShouldBe(0);\n\nEnsure the caller's ELF balance is greater than 1 ELF:\nawait acs5DemoContractStub.SetMethodCallingThreshold.SendAsync(\n    new SetMethodCallingThresholdInput\n    {\n        Method = nameof(acs5DemoContractStub.Foo),\n        SymbolToAmount =\n        {\n            {\"ELF\", 1_0000_0000}\n        },\n        ThresholdCheckType = ThresholdCheckType.Balance\n    });\n\nCheck the threshold again:\nmethodResult = await acs5DemoContractStub.GetMethodCallingThreshold.CallAsync(\n    new StringValue\n    {\n        Value = nameof(acs5DemoContractStub.Foo)\n    });\nmethodResult.SymbolToAmount.Count.ShouldBe(1);\nmethodResult.ThresholdCheckType.ShouldBe(ThresholdCheckType.Balance);\n\nSend the Foo transaction with an account that has enough balance:\n// Call with enough balance.\n{\n    var executionResult = await acs5DemoContractStub.Foo.SendAsync(new Empty());\n    executionResult.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined);\n}\n\nSend the Foo transaction with an account without ELF:\n// Call without enough balance.\n{\n    var poorStub =\n        GetTester<ACS5DemoContractContainer.ACS5DemoContractStub>(DAppContractAddress,\n            SampleECKeyPairs.KeyPairs[1]);\n    var executionResult = await poorStub.Foo.SendWithExceptionAsync(new Empty());\n    executionResult.TransactionResult.Error.ShouldContain(\"Cannot meet the calling threshold.\");\n}\n\nPrevious\nConsensus\nNext\nRandom Number\nInterface\nMethods\nTypes\nUsage\nImplementation of CheckThreshold:\nImplementation\nTest\nPlatform\nTechnology\nAudit Report\nPrivacy\nTerms of Use\nCookie Policy\nDeveloper Resources\nQuick Start\nLearn\nDocs\nTools\nResources\nEcosystem\nOverview\ndApps\naelf Ventures\nBlog\nConnect\nContact Us\nCopyright © 2024 aelf"
    },
    {
      "title": "Contract Proposal | AELF Docs",
      "url": "https://docs.aelf.com/learn/acs-introduction/acs3-contract-proposal-standard/",
      "html": "Skip to main content\nQuick Start\nLearn\nDocs\nTools\nResources\nBlog\nSearch\nUnderstanding aelf\nCore\nCross Chain\nConsensus\nNetwork\nBoot Sequence\nAddresses\nTransactions\nSmart Contract\nACS\nContract Deployment\nTransaction Fee\nParallel Execution\nContract Proposal\nConsensus\nContract Threshold\nRandom Number\nContract CrossChain\nToken Fee\nProfit Dividend\nDividend Pool\nCross Chain Consensus\nUser Contract\nTutorials\nNode Operator\nUnderstanding aelfACSContract Proposal\nACS3 - Contract Proposal Standard\n\nACS3 is used when a method needs multiple approvals. Implement these methods for voting and approval:\n\nInterface​\nMethods​\nMethod Name\tRequest Type\tResponse Type\tDescription\nCreateProposal\tacs3.CreateProposalInput\taelf.Hash\tCreates a proposal for voting and returns the proposal ID.\nApprove\taelf.Hash\tgoogle.protobuf.Empty\tApproves a proposal by its ID.\nReject\taelf.Hash\tgoogle.protobuf.Empty\tRejects a proposal by its ID.\nAbstain\taelf.Hash\tgoogle.protobuf.Empty\tAbstains from voting on a proposal by its ID.\nRelease\taelf.Hash\tgoogle.protobuf.Empty\tReleases a proposal by its ID, triggering the specified contract call.\nChangeOrganizationThreshold\tacs3.ProposalReleaseThreshold\tgoogle.protobuf.Empty\tChanges the proposal thresholds, affecting all current proposals.\nChangeOrganizationProposerWhiteList\tacs3.ProposerWhiteList\tgoogle.protobuf.Empty\tChanges the proposer whitelist for the organization.\nCreateProposalBySystemContract\tacs3.CreateProposalBySystemContractInput\taelf.Hash\tCreates a proposal by system contracts and returns the proposal ID.\nClearProposal\taelf.Hash\tgoogle.protobuf.Empty\tRemoves a specified proposal. If the proposal is active, removal fails.\nGetProposal\taelf.Hash\tacs3.ProposalOutput\tRetrieves a proposal by its ID.\nValidateOrganizationExist\taelf.Address\tgoogle.protobuf.BoolValue\tChecks if an organization exists.\nValidateProposerInWhiteList\tacs3.ValidateProposerInWhiteListInput\tgoogle.protobuf.BoolValue\tChecks if the proposer is in the whitelist.\nTypes​\nacs3.CreateProposalBySystemContractInput​\nField\tType\tDescription\tLabel\nproposal_input\tCreateProposalInput\tParameters for creating the proposal\t\norigin_proposer\taelf.Address\tAddress of the proposer\t\nacs3.CreateProposalInput​\nField\tType\tDescription\tLabel\ncontract_method_name\tstring\tMethod name to call after release\t\nto_address\taelf.Address\tContract address to call after release\t\nparams\tbytes\tParameters for the method call\t\nexpired_time\tgoogle.protobuf.Timestamp\tProposal expiration time\t\norganization_address\taelf.Address\tOrganization address\t\nproposal_description_url\tstring\tURL for proposal description\t\ntoken\taelf.Hash\tToken for proposal ID generation\t\nacs3.OrganizationCreated​\nField\tType\tDescription\tLabel\norganization_address\taelf.Address\tCreated organization address\t\nacs3.OrganizationHashAddressPair​\nField\tType\tDescription\tLabel\norganization_hash\taelf.Hash\tOrganization ID\t\norganization_address\taelf.Address\tOrganization address\t\nacs3.OrganizationThresholdChanged​\nField\tType\tDescription\tLabel\norganization_address\taelf.Address\tOrganization address\t\nproposer_release_threshold\tProposalReleaseThreshold\tNew release threshold\t\nacs3.OrganizationWhiteListChanged​\nField\tType\tDescription\tLabel\norganization_address\taelf.Address\tOrganization address\t\nproposer_white_list\tProposerWhiteList\tNew proposer whitelist\t\nacs3.ProposalCreated​\nField\tType\tDescription\tLabel\nproposal_id\taelf.Hash\tCreated proposal ID\t\norganization_address\taelf.Address\tOrganization address\t\nacs3.ProposalOutput​\nField\tType\tDescription\tLabel\nproposal_id\taelf.Hash\tProposal ID\t\ncontract_method_name\tstring\tMethod name for release\t\nto_address\taelf.Address\tTarget contract address\t\nparams\tbytes\tRelease transaction parameters\t\nexpired_time\tgoogle.protobuf.Timestamp\tProposal expiration date\t\norganization_address\taelf.Address\tOrganization address\t\nproposer\taelf.Address\tProposer address\t\nto_be_released\tbool\tIndicates if releasable\t\napproval_count\tint64\tApproval count\t\nrejection_count\tint64\tRejection count\t\nabstention_count\tint64\tAbstention count\t\nacs3.ProposalReleaseThreshold​\nField\tType\tDescription\tLabel\nminimal_approval_threshold\tint64\tMinimum approval threshold\t\nmaximal_rejection_threshold\tint64\tMaximum rejection threshold\t\nmaximal_abstention_threshold\tint64\tMaximum abstention threshold\t\nminimal_vote_threshold\tint64\tMinimum vote threshold\t\nacs3.ProposalReleased​\nField\tType\tDescription\tLabel\nproposal_id\taelf.Hash\tReleased proposal ID\t\norganization_address\taelf.Address\tOrganization address\t\nacs3.ProposerWhiteList​\nField\tType\tDescription\tLabel\nproposers\taelf.Address\tProposer addresses\trepeated\nacs3.ReceiptCreated​\nField\tType\tDescription\tLabel\nproposal_id\taelf.Hash\tProposal ID\t\naddress\taelf.Address\tSender address\t\nreceipt_type\tstring\tReceipt type (Approve, Reject, Abstain)\t\ntime\tgoogle.protobuf.Timestamp\tTimestamp\t\norganization_address\taelf.Address\tOrganization address\t\nacs3.ValidateProposerInWhiteListInput​\nField\tType\tDescription\tLabel\nproposer\taelf.Address\tProposer address\t\norganization_address\taelf.Address\tOrganization address\t\nImplementation​\n\nAssume there's only one organization in a contract, so no need to define the Organization type. Voters must use a token to vote. We'll focus on the core methods: CreateProposal, Approve, Reject, Abstain, and Release.\n\nState Attributes​\npublic MappedState<Hash, ProposalInfo> Proposals { get; set; }\npublic SingletonState<ProposalReleaseThreshold> ProposalReleaseThreshold { get; set; }\n\nProposals stores all proposal info.\nProposalReleaseThreshold saves the requirements to release a proposal.\nInitialization​\n\nSet the proposal release requirements when the contract initializes:\n\npublic override Empty Initialize(Empty input)\n{\n    State.TokenContract.Value =\n        Context.GetContractAddressByName(SmartContractConstants.TokenContractSystemName);\n    State.ProposalReleaseThreshold.Value = new ProposalReleaseThreshold\n    {\n        MinimalApprovalThreshold = 1,\n        MinimalVoteThreshold = 1\n    };\n    return new Empty();\n}\n\n\nRequires at least one vote and one approval.\n\nCreate Proposal​\n\nCreates a proposal and stores it with its details.\n\npublic override Hash CreateProposal(CreateProposalInput input)\n{\n    var proposalId = Context.GenerateId(Context.Self, input.Token);\n    Assert(State.Proposals[proposalId] == null, \"Proposal with same token already exists.\");\n    State.Proposals[proposalId] = new ProposalInfo\n    {\n        ProposalId = proposalId,\n        Proposer = Context.Sender,\n        ContractMethodName = input.ContractMethodName,\n        Params = input.Params,\n        ExpiredTime = input.ExpiredTime,\n        ToAddress = input.ToAddress,\n        ProposalDescriptionUrl = input.ProposalDescriptionUrl\n    };\n    return proposalId;\n}\n\nVoting Methods​\nAbstain​\npublic override Empty Abstain(Hash input)\n{\n    Charge();\n    var proposal = State.Proposals[input];\n    if (proposal == null)\n    {\n        throw new AssertionException(\"Proposal not found.\");\n    }\n    proposal.Abstentions.Add(Context.Sender);\n    State.Proposals[input] = proposal;\n    return new Empty();\n}\n\nApprove​\npublic override Empty Approve(Hash input)\n{\n    Charge();\n    var proposal = State.Proposals[input];\n    if (proposal == null)\n    {\n        throw new AssertionException(\"Proposal not found.\");\n    }\n    proposal.Approvals.Add(Context.Sender);\n    State.Proposals[input] = proposal;\n    return new Empty();\n}\n\nReject​\npublic override Empty Reject(Hash input)\n{\n    Charge();\n    var proposal = State.Proposals[input];\n    if (proposal == null)\n    {\n        throw new AssertionException(\"Proposal not found.\");\n    }\n    proposal.Rejections.Add(Context.Sender);\n    State.Proposals[input] = proposal;\n    return new Empty();\n}\n\nCharge​\nprivate void Charge()\n{\n    State.TokenContract.TransferFrom.Send(new TransferFromInput\n    {\n        From = Context.Sender,\n        To = Context.Self,\n        Symbol = Context.Variables.NativeSymbol,\n        Amount = 1_00000000\n    });\n}\n\nRelease Proposal​\n\nReleases a proposal if the vote count meets the threshold:\n\npublic override Empty Release(Hash input)\n{\n    var proposal = State.Proposals[input];\n    if (proposal == null)\n    {\n        throw new AssertionException(\"Proposal not found.\");\n    }\n    Assert(IsReleaseThresholdReached(proposal), \"Didn't reach release threshold.\");\n    Context.SendInline(proposal.ToAddress, proposal.ContractMethodName, proposal.Params);\n    return new Empty();\n}\nprivate bool IsReleaseThresholdReached(ProposalInfo proposal)\n{\n    var isRejected = IsProposalRejected(proposal);\n    if (isRejected)\n        return false;\n    var isAbstained = IsProposalAbstained(proposal);\n    return !isAbstained && CheckEnoughVoteAndApprovals(proposal);\n}\nprivate bool IsProposalRejected(ProposalInfo proposal)\n{\n    var rejectionMemberCount = proposal.Rejections.Count;\n    return rejectionMemberCount > State.ProposalReleaseThreshold.Value.MaximalRejectionThreshold;\n}\nprivate bool IsProposalAbstained(ProposalInfo proposal)\n{\n    var abstentionMemberCount = proposal.Abstentions.Count;\n    return abstentionMemberCount > State.ProposalReleaseThreshold.Value.MaximalAbstentionThreshold;\n}\nprivate bool CheckEnoughVoteAndApprovals(ProposalInfo proposal)\n{\n    var approvedMemberCount = proposal.Approvals.Count;\n    var isApprovalEnough =\n        approvedMemberCount >= State.ProposalReleaseThreshold.Value.MinimalApprovalThreshold;\n    if (!isApprovalEnough)\n        return false;\n    var isVoteThresholdReached =\n        proposal.Abstentions.Concat(proposal.Approvals).Concat(proposal.Rejections).Count() >=\n        State.ProposalReleaseThreshold.Value.MinimalVoteThreshold;\n    return isVoteThresholdReached;\n}\n\nTest​\n\nAdd methods to a Dapp contract and test the proposal with these methods.\n\nState Class​\npublic StringState Slogan { get; set; }\npublic SingletonState<Address> Organization { get; set; }\n\nSet/Get Methods​\npublic override StringValue GetSlogan(Empty input)\n{\n    return State.Slogan.Value == null ? new StringValue() : new StringValue {Value = State.Slogan.Value};\n}\n\npublic override Empty SetSlogan(StringValue input)\n{\n    Assert(Context.Sender == State.Organization.Value, \"No permission.\");\n    State.Slogan.Value = input.Value;\n    return new Empty();\n}\n\nPrepare a Stub​\nvar keyPair = SampleECKeyPairs.KeyPairs[0];\nvar acs3DemoContractStub =\n    GetTester<ACS3DemoContractContainer.ACS3DemoContractStub>(DAppContractAddress, keyPair);\n\nApprove Token Transaction​\nvar tokenContractStub =\n    GetTester<TokenContractContainer.TokenContractStub>(\n        GetAddress(TokenSmartContractAddressNameProvider.StringName), keyPair);\nawait tokenContractStub.Approve.SendAsync(new ApproveInput\n{\n    Spender = DAppContractAddress,\n    Symbol = \"ELF\",\n    Amount = long.MaxValue\n});\n\nCreate and Test Proposal​\n\nCreate a proposal to change the Slogan to \"aelf\":\n\nvar proposalId = (await acs3DemoContractStub.CreateProposal.SendAsync(new CreateProposalInput\n{\n    OrganizationAddress = OrganizationAddress\n    ContractMethodName = nameof(acs3DemoContractStub.SetSlogan),\n    ToAddress = DAppContractAddress,\n    ExpiredTime = TimestampHelper.GetUtcNow().AddHours(1),\n    Params = new StringValue {Value = \"aelf\"}.ToByteString(),\n    Token = HashHelper.ComputeFrom(\"aelf\")\n})).Output;\n\nCheck that Slogan is empty, vote, and release:​\n// Check slogan\n{\n    var slogan = await acs3DemoContractStub.GetSlogan.CallAsync(new Empty());\n    slogan.Value.ShouldBeEmpty();\n}\nawait acs3DemoContractStub.Approve.SendAsync(proposalId);\n\nawait acs3DemoContractStub.Release.SendAsync(proposalId);\n// Check slogan\n{\n    var slogan = await acs3DemoContractStub.GetSlogan.CallAsync(new Empty());\n    slogan.Value.ShouldBe(\"aelf\");\n}\n\nPrevious\nParallel Execution\nNext\nConsensus\nInterface\nMethods\nTypes\nImplementation\nState Attributes\nInitialization\nCreate Proposal\nVoting Methods\nRelease Proposal\nTest\nState Class\nPlatform\nTechnology\nAudit Report\nPrivacy\nTerms of Use\nCookie Policy\nDeveloper Resources\nQuick Start\nLearn\nDocs\nTools\nResources\nEcosystem\nOverview\ndApps\naelf Ventures\nBlog\nConnect\nContact Us\nCopyright © 2024 aelf"
    },
    {
      "title": "AELF Docs",
      "url": "https://docs.aelf.com/learn/acs-introduction/acs4-consensus-standard/",
      "html": "Skip to main content\nQuick Start\nLearn\nDocs\nTools\nResources\nBlog\nSearch\nUnderstanding aelf\nCore\nCross Chain\nConsensus\nNetwork\nBoot Sequence\nAddresses\nTransactions\nSmart Contract\nACS\nContract Deployment\nTransaction Fee\nParallel Execution\nContract Proposal\nConsensus\nContract Threshold\nRandom Number\nContract CrossChain\nToken Fee\nProfit Dividend\nDividend Pool\nCross Chain Consensus\nUser Contract\nTutorials\nNode Operator\nUnderstanding aelfACSConsensus\nACS4 - Consensus Standard\n\nACS4 customizes consensus mechanisms.\n\nInterface​\n\nTo customize, implement these five interfaces:\n\nMethods​\nMethod Name\tRequest Type\tResponse Type\tDescription\nGetConsensusCommand\tgoogle.protobuf.BytesValue\tacs4.ConsensusCommand\tGenerate a consensus command based on contract state and the input public key.\nGetConsensusExtraData\tgoogle.protobuf.BytesValue\tgoogle.protobuf.BytesValue\tGenerate extra data when a block is generated.\nGenerateConsensusTransactions\tgoogle.protobuf.BytesValue\tacs4.TransactionList\tGenerate system transactions when a block is generated. Each block has one consensus transaction.\nValidateConsensusBeforeExecution\tgoogle.protobuf.BytesValue\tacs4.ValidationResult\tVerify consensus info in the block header before execution.\nValidateConsensusAfterExecution\tgoogle.protobuf.BytesValue\tacs4.ValidationResult\tVerify the state info written to consensus after execution.\nTypes​\nacs4.ConsensusCommand​\nField\tType\tDescription\nlimit_milliseconds_of_mining_block\tint32\tTime limit for mining the next block.\nhint\tbytes\tDiverse context according to the consensus protocol.\narranged_mining_time\tgoogle.protobuf.Timestamp\tThe arranged mining time.\nmining_due_time\tgoogle.protobuf.Timestamp\tThe expiration time for mining.\nacs4.TransactionList​\nField\tType\tDescription\ntransactions\taelf.Transaction\tConsensus system transactions.\nacs4.ValidationResult​\nField\tType\tDescription\nsuccess\tbool\tIs successful.\nmessage\tstring\tError message.\nis_re_trigger\tbool\tWhether to re-trigger mining.\naelf.Address​\nField\tType\tDescription\nvalue\tbytes\t\naelf.BinaryMerkleTree​\nField\tType\tDescription\nnodes\tHash\tLeaf nodes.\nroot\tHash\tRoot node hash.\nleaf_count\tint32\tLeaf node count.\naelf.Hash​\nField\tType\tDescription\nvalue\tbytes\t\naelf.LogEvent​\nField\tType\tDescription\naddress\tAddress\tContract address.\nname\tstring\tName of the log event.\nindexed\tbytes\tIndexed data for bloom.\nnon_indexed\tbytes\tNon-indexed data.\naelf.MerklePath​\nField\tType\tDescription\nmerkle_path_nodes\tMerklePathNode\tMerkle path nodes.\naelf.MerklePathNode​\nField\tType\tDescription\nhash\tHash\tNode hash.\nis_left_child_node\tbool\tIs it a left child node?\naelf.SInt32Value​\nField\tType\tDescription\nvalue\tsint32\t\naelf.SInt64Value​\nField\tType\tDescription\nvalue\tsint64\t\naelf.ScopedStatePath​\nField\tType\tDescription\naddress\tAddress\tScope address (contract address)\npath\tStatePath\tPath of contract state\naelf.SmartContractRegistration​\nField\tType\tDescription\ncategory\tsint32\tContract code category (0: C#).\ncode\tbytes\tByte array of the contract code.\ncode_hash\tHash\tHash of the contract code.\nis_system_contract\tbool\tIs it a system contract?\nversion\tint32\tCurrent contract version.\naelf.StatePath​\nField\tType\tDescription\nparts\tstring\tPartial state path.\naelf.Transaction​\nField\tType\tDescription\nfrom\tAddress\tSender's address.\nto\tAddress\tContract address being called.\nref_block_number\tint64\tReferenced block number.\nref_block_prefix\tbytes\tFirst four bytes of the referenced block hash.\nmethod_name\tstring\tMethod name in the smart contract.\nparams\tbytes\tParameters for the smart contract method.\nsignature\tbytes\tSignature including sender, target method, parameters, and block reference.\naelf.TransactionExecutingStateSet​\nField\tType\tDescription\nwrites\tTransactionExecutingStateSet.WritesEntry\tChanged states.\nreads\tTransactionExecutingStateSet.ReadsEntry\tRead states.\ndeletes\tTransactionExecutingStateSet.DeletesEntry\tDeleted states.\naelf.TransactionExecutingStateSet.DeletesEntry​\nField\tType\tDescription\nkey\tstring\t\nvalue\tbool\t\naelf.TransactionExecutingStateSet.ReadsEntry​\nField\tType\tDescription\nkey\tstring\t\nvalue\tbool\t\naelf.TransactionExecutingStateSet.WritesEntry​\nField\tType\tDescription\nkey\tstring\t\nvalue\tbytes\t\naelf.TransactionResult​\nField\tType\tDescription\ntransaction_id\tHash\tTransaction ID.\nstatus\tTransactionResultStatus\tTransaction result status.\nlogs\tLogEvent\tLog events.\nbloom\tbytes\tBloom filter for transaction logs.\nreturn_value\tbytes\tReturn value of the transaction execution.\nblock_number\tint64\tBlock height that packages the transaction.\nblock_hash\tHash\tBlock hash that packages the transaction.\nerror\tstring\tFailed execution error message.\naelf.TransactionResultStatus​\nName\tNumber\tDescription\nNOT_EXISTED\t0\tTransaction result does not exist.\nPENDING\t1\tTransaction is in the pool waiting to be packaged.\nFAILED\t2\tTransaction execution failed.\nMINED\t3\tTransaction executed successfully and packaged into a block.\nCONFLICT\t4\tConflicts with other transactions when executed in parallel.\nPENDING_VALIDATION\t5\tTransaction is waiting for validation.\nNODE_VALIDATION_FAILED\t6\tTransaction validation failed.\nUsage​\n\nACS4 methods correspond to the IConsensusService interface in the AElf.Kernel.Consensus project:\n\nACS4 Method\tIConsensusService Method\tMethodology\tTiming\nGetConsensusCommand\tTask TriggerConsensusAsync\tWhen TriggerConsensusAsync is called, it will use the node's configured account to call the GetConsensusCommand method to obtain block information (ConsensusCommand)\tWhen the node starts; When the BestChainFoundEventData event is thrown; When consensus data validation fails and needs to be triggered again (IsReTrigger field is true).\nGetConsensusExtraData\tTask<byte[]> GetConsensusExtraDataAsync\tWhen a node produces a block, it generates block header info via IBlockExtraDataService, which calls GetConsensusExtraData in the consensus contract\tWhen a node produces a new block.\nGenerateConsensusTransactions\tTask<List<Transaction>> GenerateConsensusTransactionsAsync\tIn the process of generating new blocks, a consensus transaction needs to be generated as one of the system transactions\tWhen a node produces a new block.\nValidateConsensusBeforeExecution\tTask<bool> ValidateConsensusBeforeExecutionAsync\tThe IBlockValidationProvider interface allows adding a new block validator. The consensus validator, ConsensusValidationProvider, calls ValidateConsensusBeforeExecution\tWhen a node produces a new block.\nValidateConsensusAfterExecution\tTask<bool> ValidateConsensusAfterExecutionAsync\tThe implementation of ValidateBlockAfterExecuteAsync in ConsensusValidationProvider calls ValidateConsensusAfterExecution in the consensus contract\tWhen a node produces a new block.\nExample​\n\nRefer to the AEDPoS contract implementation.\n\nPrevious\nContract Proposal\nNext\nContract Threshold\nInterface\nMethods\nTypes\nacs4.ConsensusCommand\nacs4.TransactionList\nacs4.ValidationResult\naelf.Address\naelf.BinaryMerkleTree\naelf.Hash\naelf.LogEvent\naelf.MerklePath\naelf.MerklePathNode\naelf.SInt32Value\naelf.SInt64Value\naelf.ScopedStatePath\naelf.SmartContractRegistration\naelf.StatePath\naelf.Transaction\naelf.TransactionExecutingStateSet\naelf.TransactionExecutingStateSet.DeletesEntry\naelf.TransactionExecutingStateSet.ReadsEntry\naelf.TransactionExecutingStateSet.WritesEntry\naelf.TransactionResult\naelf.TransactionResultStatus\nUsage\nExample\nPlatform\nTechnology\nAudit Report\nPrivacy\nTerms of Use\nCookie Policy\nDeveloper Resources\nQuick Start\nLearn\nDocs\nTools\nResources\nEcosystem\nOverview\ndApps\naelf Ventures\nBlog\nConnect\nContact Us\nCopyright © 2024 aelf"
    },
    {
      "title": "AELF Docs",
      "url": "https://docs.aelf.com/learn/acs-introduction/acs2-parallel-execution-standard/",
      "html": "Skip to main content\nQuick Start\nLearn\nDocs\nTools\nResources\nBlog\nSearch\nUnderstanding aelf\nCore\nCross Chain\nConsensus\nNetwork\nBoot Sequence\nAddresses\nTransactions\nSmart Contract\nACS\nContract Deployment\nTransaction Fee\nParallel Execution\nContract Proposal\nConsensus\nContract Threshold\nRandom Number\nContract CrossChain\nToken Fee\nProfit Dividend\nDividend Pool\nCross Chain Consensus\nUser Contract\nTutorials\nNode Operator\nUnderstanding aelfACSParallel Execution\nACS2 - Parallel Execution Standard\n\nACS2 helps with parallel transaction execution.\n\nInterface​\n\nContracts using ACS2 need to implement one method:\n\nMethods​\nMethod Name\tRequest Type\tResponse Type\tDescription\nGetResourceInfo\taelf.Transaction\tacs2.ResourceInfo\tGets the resource info that the transaction execution depends on.\nTypes​\nacs2.ResourceInfo​\nField\tType\tDescription\nwrite_paths\taelf.ScopedStatePath\tState paths for writing.\nread_paths\taelf.ScopedStatePath\tState paths for reading.\nnon_parallelizable\tbool\tIf the transaction isn't parallel.\naelf.Address​\nField\tType\tDescription\nvalue\tbytes\t\naelf.BinaryMerkleTree​\nField\tType\tDescription\nnodes\tHash\tLeaf nodes.\nroot\tHash\tRoot node hash.\nleaf_count\tint32\tCount of leaf nodes.\naelf.Hash​\nField\tType\tDescription\nvalue\tbytes\t\naelf.LogEvent​\nField\tType\tDescription\naddress\tAddress\tContract address.\nname\tstring\tLog event name.\nindexed\tbytes\tIndexed data.\nnon_indexed\tbytes\tNon-indexed data.\naelf.MerklePath​\nField\tType\tDescription\nmerkle_path_nodes\tMerklePathNode\tMerkle path nodes.\naelf.MerklePathNode​\nField\tType\tDescription\nhash\tHash\tNode hash.\nis_left_child_node\tbool\tIf it's a left child node.\naelf.SInt32Value​\nField\tType\tDescription\nvalue\tsint32\t\naelf.SInt64Value​\nField\tType\tDescription\nvalue\tsint64\t\naelf.ScopedStatePath​\nField\tType\tDescription\naddress\tAddress\tContract address.\npath\tStatePath\tPath of contract state.\naelf.SmartContractRegistration​\nField\tType\tDescription\ncategory\tsint32\tContract code category (0: C#).\ncode\tbytes\tContract code byte array.\ncode_hash\tHash\tContract code hash.\nis_system_contract\tbool\tIf it's a system contract.\nversion\tint32\tCurrent contract version.\naelf.StatePath​\nField\tType\tDescription\nparts\tstring\tState path parts.\naelf.Transaction​\nField\tType\tDescription\nfrom\tAddress\tSender address.\nto\tAddress\tContract address.\nref_block_number\tint64\tReferenced block height.\nref_block_prefix\tbytes\tFirst 4 bytes of referenced block hash.\nmethod_name\tstring\tMethod name in the contract.\nparams\tbytes\tMethod parameters.\nsignature\tbytes\tSignature of the transaction.\naelf.TransactionExecutingStateSet​\nField\tType\tDescription\nwrites\tTransactionExecutingStateSet.WritesEntry\tChanged states.\nreads\tTransactionExecutingStateSet.ReadsEntry\tRead states.\ndeletes\tTransactionExecutingStateSet.DeletesEntry\tDeleted states.\naelf.TransactionExecutingStateSet.DeletesEntry​\nField\tType\tDescription\nkey\tstring\t\nvalue\tbool\t\naelf.TransactionExecutingStateSet.ReadsEntry​\nField\tType\tDescription\nkey\tstring\t\nvalue\tbool\t\naelf.TransactionExecutingStateSet.WritesEntry​\nField\tType\tDescription\nkey\tstring\t\nvalue\tbytes\t\naelf.TransactionResult​\nField\tType\tDescription\ntransaction_id\tHash\tTransaction ID.\nstatus\tTransactionResultStatus\tTransaction result status.\nlogs\tLogEvent\tLog events.\nbloom\tbytes\tBloom filter for transaction logs.\nreturn_value\tbytes\tReturn value of the transaction execution.\nblock_number\tint64\tBlock height that packages the transaction.\nblock_hash\tHash\tBlock hash that packages the transaction.\nerror\tstring\tFailed execution error message.\naelf.TransactionResultStatus​\nName\tNumber\tDescription\nNOT_EXISTED\t0\tTransaction result does not exist.\nPENDING\t1\tTransaction is waiting to be packaged.\nFAILED\t2\tTransaction execution failed.\nMINED\t3\tTransaction was successfully executed and packaged.\nCONFLICT\t4\tTransaction has conflicts with other transactions.\nPENDING_VALIDATION\t5\tTransaction is waiting for validation.\nNODE_VALIDATION_FAILED\t6\tTransaction validation failed.\nUsage​\n\naelf uses a key-value database to store data. State Path determines the key for contract execution data.\n\nFor example, a Token contract defines a balance property:\n\npublic MappedState<Address, string, long> Balances { get; set; }\n\n\nTo access the balance of an address (2EM5uV6bSJh6xJfZTUa1pZpYsYcCUAdPvZvFUJzMDJEx3rbioz) for a Token contract address (Nmjj7noTpMqZ522j76SDsFLhiKkThv1u3d4TxqJMD8v89tWmE), use its key in the database:\n\nNmjj7noTpMqZ522j76SDsFLhiKkThv1u3d4TxqJMD8v89tWmE/Balances/2EM5uV6bSJh6xJfZTUa1pZpYsYcCUAdPvZvFUJzMDJEx3rbioz/ELF\n\n\nParallel execution groups transactions by their State Paths. If two methods don’t access the same StatePath, they can be executed in parallel.\n\nIf State Paths mismatch, the transaction is canceled and labeled as “cannot be grouped”.\n\nFor more details, check the ITransactionGrouper and IParallelTransactionExecutingService code.\n\nImplementation​\n\nExample: Token Contract For the Transfer method, notify ITransactionGrouper via GetResourceInfo about the ELF balances of address A and B:\n\nvar args = TransferInput.Parser.ParseFrom(txn.Params);\nvar resourceInfo = new ResourceInfo\n{\n    Paths =\n    {\n        GetPath(nameof(TokenContractState.Balances), txn.From.ToString(), args.Symbol),\n        GetPath(nameof(TokenContractState.Balances), args.To.ToString(), args.Symbol),\n    }\n};\nreturn resourceInfo;\n\n\nThe GetPath method forms a ScopedStatePath from key data:\n\nprivate ScopedStatePath GetPath(params string[] parts)\n{\n    return new ScopedStatePath\n    {\n        Address = Context.Self,\n        Path = new StatePath\n        {\n            Parts =\n            {\n                parts\n            }\n        }\n    }\n}\n\nTesting​\n\nConstruct two transactions and pass them to ITransactionGrouper to test if they can run in parallel using GroupAsync.\n\nPrepare two stubs with different addresses:\n\nvar keyPair1 = SampleECKeyPairs.KeyPairs[0];\nvar acs2DemoContractStub1 = GetACS2DemoContractStub(keyPair1);\nvar keyPair2 = SampleECKeyPairs.KeyPairs[1];\nvar acs2DemoContractStub2 = GetACS2DemoContractStub(keyPair2);\n\nvar transactionGrouper = Application.ServiceProvider.GetRequiredService<ITransactionGrouper>();\nvar blockchainService = Application.ServiceProvider.GetRequiredService<IBlockchainService>();\nvar chain = await blockchainService.GetChainAsync();\n\n\nCheck with transactionGrouper:\n\n// Situation can be parallel executed.\n{\n    var groupedTransactions = await transactionGrouper.GroupAsync(new ChainContext\n    {\n        BlockHash = chain.BestChainHash,\n        BlockHeight = chain.BestChainHeight\n    }, new List<Transaction>\n    {\n        acs2DemoContractStub1.TransferCredits.GetTransaction(new TransferCreditsInput\n        {\n            To = Address.FromPublicKey(SampleECKeyPairs.KeyPairs[2].PublicKey),\n            Symbol = \"ELF\",\n            Amount = 1\n        }),\n        acs2DemoContractStub2.TransferCredits.GetTransaction(new TransferCreditsInput\n        {\n            To = Address.FromPublicKey(SampleECKeyPairs.KeyPairs[3].PublicKey),\n            Symbol = \"ELF\",\n            Amount = 1\n        }),\n    });\n    groupedTransactions.Parallelizables.Count.ShouldBe(2);\n}\n// Situation cannot.\n{\n    var groupedTransactions = await transactionGrouper.GroupAsync(new ChainContext\n    {\n        BlockHash = chain.BestChainHash,\n        BlockHeight = chain.BestChainHeight\n    }, new List<Transaction>\n    {\n        acs2DemoContractStub1.TransferCredits.GetTransaction(new TransferCreditsInput\n        {\n            To = Address.FromPublicKey(SampleECKeyPairs.KeyPairs[2].PublicKey),\n            Symbol = \"ELF\",\n            Amount = 1\n        }),\n        acs2DemoContractStub2.TransferCredits.GetTransaction(new TransferCreditsInput\n        {\n            To = Address.FromPublicKey(SampleECKeyPairs.KeyPairs[2].PublicKey),\n            Symbol = \"ELF\",\n            Amount = 1\n        }),\n    });\n    groupedTransactions.Parallelizables.Count.ShouldBe(1);\n}\n\nExample​\n\nRefer to the MultiToken contract implementation for GetResourceInfo. Note that Transfer method needs to handle transaction fees along with keys.\n\nACS2 - Parallel Execution Standard\n\nACS2 enables parallel execution of transactions by providing necessary resource information.\n\nInterface​\n\nA contract inheriting ACS2 must implement:\n\nMethods​\nMethod Name\tRequest Type\tResponse Type\tDescription\nGetResourceInfo\taelf.Transaction\tacs2.ResourceInfo\tRetrieves resource dependencies for transaction exec.\nTypes​\nacs2.ResourceInfo​\nField\tType\tDescription\tLabel\nwrite_paths\taelf.ScopedStatePath\tState paths written during execution\trepeated\nread_paths\taelf.ScopedStatePath\tState paths read during execution\trepeated\nnon_parallelizable\tbool\tIndicates if transaction is non-parallelizable.\t\nOther Types (Omitted for brevity)​\n\nSeveral other types like aelf.Address, aelf.BinaryMerkleTree, aelf.LogEvent, etc., are used within acs2.ResourceInfo.\n\nUsage​\n\naelf uses State Paths to manage data storage, ensuring transaction grouping based on accessed paths for efficient parallel execution.\n\nImplementation​\n\nToken contract, for example, modifies balances through method Transfer. GetResourceInfo must notify ITransactionGrouper of accessed state paths.\n\nvar args = TransferInput.Parser.ParseFrom(txn.Params);\nvar resourceInfo = new ResourceInfo\n{\n    Paths =\n    {\n        GetPath(nameof(TokenContractState.Balances), txn.From.ToString(), args.Symbol),\n        GetPath(nameof(TokenContractState.Balances), args.To.ToString(), args.Symbol),\n    }\n};\nreturn resourceInfo;\n\nTest​\n\nTest transaction parallelizability using ITransactionGrouper's GroupAsync method with sample transactions.\n\nvar keyPair1 = SampleECKeyPairs.KeyPairs[0];\nvar acs2DemoContractStub1 = GetACS2DemoContractStub(keyPair1);\nvar keyPair2 = SampleECKeyPairs.KeyPairs[1];\nvar acs2DemoContractStub2 = GetACS2DemoContractStub(keyPair2);\n\nvar transactionGrouper = Application.ServiceProvider.GetRequiredService<ITransactionGrouper>();\nvar blockchainService = Application.ServiceProvider.GetRequiredService<IBlockchainService>();\nvar chain = await blockchainService.GetChainAsync();\n\n// Test parallel execution scenario\n{\n    var groupedTransactions = await transactionGrouper.GroupAsync(new ChainContext\n    {\n        BlockHash = chain.BestChainHash,\n        BlockHeight = chain.BestChainHeight\n    }, new List<Transaction>\n    {\n        acs2DemoContractStub1.TransferCredits.GetTransaction(new TransferCreditsInput\n        {\n            To = Address.FromPublicKey(SampleECKeyPairs.KeyPairs[2].PublicKey),\n            Symbol = \"ELF\",\n            Amount = 1\n        }),\n        acs2DemoContractStub2.TransferCredits.GetTransaction(new TransferCreditsInput\n        {\n            To = Address.FromPublicKey(SampleECKeyPairs.KeyPairs[3].PublicKey),\n            Symbol = \"ELF\",\n            Amount = 1\n        }),\n    });\n    groupedTransactions.Parallelizables.Count.ShouldBe(2);\n}\n\n// Test non-parallel execution scenario\n{\n    var groupedTransactions = await transactionGrouper.GroupAsync(new ChainContext\n    {\n        BlockHash = chain.BestChainHash,\n        BlockHeight = chain.BestChainHeight\n    }, new List<Transaction>\n    {\n        acs2DemoContractStub1.TransferCredits.GetTransaction(new TransferCreditsInput\n        {\n            To = Address.FromPublicKey(SampleECKeyPairs.KeyPairs[2].PublicKey),\n            Symbol = \"ELF\",\n            Amount = 1\n        }),\n        acs2DemoContractStub2.TransferCredits.GetTransaction(new TransferCreditsInput\n        {\n            To = Address.FromPublicKey(SampleECKeyPairs.KeyPairs[2].PublicKey),\n            Symbol = \"ELF\",\n            Amount = 1\n        }),\n    });\n    groupedTransactions.Parallelizables.Count.ShouldBe(1);\n}\n\nExample​\n\nFor an example of implementing GetResourceInfo, refer to the MultiToken contract, ensuring transaction fees are considered for the keys involved.\n\nPrevious\nTransaction Fee\nNext\nContract Proposal\nInterface\nMethods\nTypes\nUsage\nImplementation\nTesting\nExample\nInterface\nTypes\nUsage\nImplementation\nTest\nExample\nPlatform\nTechnology\nAudit Report\nPrivacy\nTerms of Use\nCookie Policy\nDeveloper Resources\nQuick Start\nLearn\nDocs\nTools\nResources\nEcosystem\nOverview\ndApps\naelf Ventures\nBlog\nConnect\nContact Us\nCopyright © 2024 aelf"
    },
    {
      "title": "Transaction Fee | AELF Docs",
      "url": "https://docs.aelf.com/learn/acs-introduction/acs1-transaction-fee-standard/",
      "html": "Skip to main content\nQuick Start\nLearn\nDocs\nTools\nResources\nBlog\nSearch\nUnderstanding aelf\nCore\nCross Chain\nConsensus\nNetwork\nBoot Sequence\nAddresses\nTransactions\nSmart Contract\nACS\nContract Deployment\nTransaction Fee\nParallel Execution\nContract Proposal\nConsensus\nContract Threshold\nRandom Number\nContract CrossChain\nToken Fee\nProfit Dividend\nDividend Pool\nCross Chain Consensus\nUser Contract\nTutorials\nNode Operator\nUnderstanding aelfACSTransaction Fee\nACS1 - Transaction Fee Standard\n\nACS1 handles transaction fees.\n\nInterface​\n\nContracts using ACS1 must implement these methods:\n\nMethods​\nMethod Name\tRequest Type\tResponse Type\tDescription\nSetMethodFee\tacs1.MethodFees\tgoogle.protobuf.Empty\tSets the method fees for a method, overriding all fees.\nChangeMethodFeeController\tAuthorityInfo\tgoogle.protobuf.Empty\tChanges the method fee controller. Default is parliament.\nGetMethodFee\tgoogle.protobuf.StringValue\tacs1.MethodFees\tQueries the fee for a method by name.\nGetMethodFeeController\tgoogle.protobuf.Empty\tAuthorityInfo\tQueries the method fee controller.\nTypes​\nacs1.MethodFee​\nField\tType\tDescription\nsymbol\tstring\tThe token symbol for the fee.\nbasic_fee\tint64\tThe fee amount.\nacs1.MethodFees​\nField\tType\tDescription\nmethod_name\tstring\tThe name of the method.\nfees\tMethodFee\tList of fees.\nis_size_fee_free\tbool\tOptional based on implementation.\nAuthorityInfo​\nField\tType\tDescription\ncontract_address\taelf.Address\tThe controller's contract address.\nowner_address\taelf.Address\tThe owner's address.\n\nNote: Only system contracts on the main chain can implement ACS1.\n\nUsage​\n\nA pre-transaction, generated by FeeChargePreExecutionPlugin, charges the transaction fee before main processing.\n\n/// <summary>\n/// Related transactions will be generated by acs1 pre-plugin service,\n/// and will be executed before the origin transaction.\n/// </summary>\n/// <param name=\"input\"></param>\n/// <returns></returns>\npublic override BoolValue ChargeTransactionFees(ChargeTransactionFeesInput input)\n{\n    // ...\n    // Record tx fee bill during current charging process.\n    var bill = new TransactionFeeBill();\n    var fromAddress = Context.Sender;\n    var methodFees = Context.Call<MethodFees>(input.ContractAddress, nameof(GetMethodFee),\n        new StringValue {Value = input.MethodName});\n    var successToChargeBaseFee = true;\n    if (methodFees != null && methodFees.Fees.Any())\n    {\n        successToChargeBaseFee = ChargeBaseFee(GetBaseFeeDictionary(methodFees), ref bill);\n    }\n    var successToChargeSizeFee = true;\n    if (!IsMethodFeeSetToZero(methodFees))\n    {\n        // Then also do not charge size fee.\n        successToChargeSizeFee = ChargeSizeFee(input, ref bill);\n    }\n    // Update balances.\n    foreach (var tokenToAmount in bill.FeesMap)\n    {\n        ModifyBalance(fromAddress, tokenToAmount.Key, -tokenToAmount.Value);\n        Context.Fire(new TransactionFeeCharged\n        {\n            Symbol = tokenToAmount.Key,\n            Amount = tokenToAmount.Value\n        });\n        if (tokenToAmount.Value == 0)\n        {\n            //Context.LogDebug(() => $\"Maybe incorrect charged tx fee of {tokenToAmount.Key}: it's 0.\");\n        }\n    }\n    return new BoolValue {Value = successToChargeBaseFee && successToChargeSizeFee};\n}\n\nSteps:​\nSystem calls GetMethodFee to determine the fee.\nChecks if the balance is sufficient:\nIf yes, the fee is billed.\nIf no, the transaction is rejected.\nIf the method fee is not zero, the system charges a size fee based on the parameter's size.\nAfter charging, an TransactionFeeCharged event is thrown, modifying the sender's balance.\nThe event is processed to calculate the total transaction fees in the block.\nIn the next block:\n10% of the fees are destroyed.\n90% goes to the dividend pool on the main chain and to the FeeReceiver on the side chain.\n/// <summary>\n/// Burn 10% of tx fees.\n/// If Side Chain didn't set FeeReceiver, burn all.\n/// </summary>\n/// <param name=\"symbol\"></param>\n/// <param name=\"totalAmount\"></param>\nprivate void TransferTransactionFeesToFeeReceiver(string symbol, long totalAmount)\n{\n    Context.LogDebug(() => \"Transfer transaction fee to receiver.\");\n    if (totalAmount <= 0) return;\n    var burnAmount = totalAmount.Div(10);\n    if (burnAmount > 0)\n        Context.SendInline(Context.Self, nameof(Burn), new BurnInput\n        {\n            Symbol = symbol,\n            Amount = burnAmount\n        });\n    var transferAmount = totalAmount.Sub(burnAmount);\n    if (transferAmount == 0)\n        return;\n    var treasuryContractAddress =\n        Context.GetContractAddressByName(SmartContractConstants.TreasuryContractSystemName);\n    if ( treasuryContractAddress!= null)\n    {\n        // Main chain would donate tx fees to dividend pool.\n        if (State.DividendPoolContract.Value == null)\n            State.DividendPoolContract.Value = treasuryContractAddress;\n        State.DividendPoolContract.Donate.Send(new DonateInput\n        {\n            Symbol = symbol,\n            Amount = transferAmount\n        });\n    }\n    else\n    {\n        if (State.FeeReceiver.Value != null)\n        {\n            Context.SendInline(Context.Self, nameof(Transfer), new TransferInput\n            {\n                To = State.FeeReceiver.Value,\n                Symbol = symbol,\n                Amount = transferAmount,\n            });\n        }\n        else\n        {\n            // Burn all!\n            Context.SendInline(Context.Self, nameof(Burn), new BurnInput\n            {\n                Symbol = symbol,\n                Amount = transferAmount\n            });\n        }\n    }\n}\n\nImplementation​\nSimple Implementation​\n\nImplement only GetMethodFee to set fixed fees for methods.\n\npublic override MethodFees GetMethodFee(StringValue input)\n{\n    if (input.Value == nameof(Foo1) || input.Value == nameof(Foo2))\n    {\n        return new MethodFees\n        {\n            MethodName = input.Value,\n            Fees =\n            {\n                new MethodFee\n                {\n                    BasicFee = 1_00000000,\n                    Symbol = Context.Variables.NativeSymbol\n                }\n            }\n        };\n    }\n    if (input.Value == nameof(Bar1) || input.Value == nameof(Bar2))\n    {\n        return new MethodFees\n        {\n            MethodName = input.Value,\n            Fees =\n            {\n                new MethodFee\n                {\n                    BasicFee = 2_00000000,\n                    Symbol = Context.Variables.NativeSymbol\n                }\n            }\n        };\n    }\n    return new MethodFees();\n}\n\nRecommended Implementation​\nDefine a MappedState in the contract's State file for transaction fees.\npublic MappedState<string, MethodFees> TransactionFees { get; set; }\n\nModify TransactionFees in SetMethodFee and return the value in GetMethodFee.\npublic override MethodFees GetMethodFee(StringValue input) {\n    return State.TransactionFees[input.Value];\n}\n\nAdd permission management to SetMethodFee to prevent arbitrary fee changes.\npublic SingletonState<AuthorityInfo> MethodFeeController { get; set; }\n\npublic override Empty SetMethodFee(MethodFees input)\n{\n  foreach (var symbolToAmount in input.Fees)\n  {\n     AssertValidToken(symbolToAmount.Symbol, symbolToAmount.BasicFee);\n  }\n  RequiredMethodFeeControllerSet();\n  Assert(Context.Sender ==             State.MethodFeeController.Value.OwnerAddress, \"Unauthorized to set method fee.\");\n    State.TransactionFees[input.MethodName] = input;\n    return new Empty();\n}\n\nPermission Management​\nDefine a SingletonState with type AuthorityInfo.\nprivate void RequiredMethodFeeControllerSet()\n{\n   if (State.MethodFeeController.Value != null) return;\n   if (State.ParliamentContract.Value == null)\n   {\n     State.ParliamentContract.Value =         Context.GetContractAddressByName(SmartContractConstants.ParliamentContractSystemName);\n   }\n   var defaultAuthority = new AuthorityInfo();\n   // Parliament Auth Contract maybe not deployed.\n   if (State.ParliamentContract.Value != null)\n   {\n     defaultAuthority.OwnerAddress =               State.ParliamentContract.GetDefaultOrganizationAddress.Call(new Empty());\n     defaultAuthority.ContractAddress = State.ParliamentContract.Value;\n   }\n   State.MethodFeeController.Value = defaultAuthority;\n}\n\nCheck the sender’s right by comparing its address with the owner’s address.\nImplement permission checks to ensure only authorized changes.\nChanging Authority​\n\nThe authority for SetMethodFee can be changed through a transaction from the default parliament address.\n\npublic override Empty ChangeMethodFeeController(AuthorityInfo input)\n{\n    RequiredMethodFeeControllerSet();\n    AssertSenderAddressWith(State.MethodFeeController.Value.OwnerAddress);\n    var organizationExist = CheckOrganizationExist(input);\n    Assert(organizationExist, \"Invalid authority input.\");\n    State.MethodFeeController.Value = input;\n    return new Empty();\n}\n\npublic override AuthorityInfo GetMethodFeeController(Empty input)\n{\n    RequiredMethodFeeControllerSet();\n    return State.MethodFeeController.Value;\n}\n\nTesting​\n\nCreate ACS1’s Stub and call GetMethodFee and GetMethodFeeController to check the return values.\n\nExample​\n\nAll aelf system contracts implement ACS1 and can be used as references.\n\nPrevious\nContract Deployment\nNext\nParallel Execution\nInterface\nMethods\nTypes\nUsage\nSteps:\nImplementation\nSimple Implementation\nRecommended Implementation\nPermission Management\nChanging Authority\nTesting\nExample\nPlatform\nTechnology\nAudit Report\nPrivacy\nTerms of Use\nCookie Policy\nDeveloper Resources\nQuick Start\nLearn\nDocs\nTools\nResources\nEcosystem\nOverview\ndApps\naelf Ventures\nBlog\nConnect\nContact Us\nCopyright © 2024 aelf"
    },
    {
      "title": "Contract Deployment | AELF Docs",
      "url": "https://docs.aelf.com/learn/acs-introduction/acs0-contract-deployment-standard/",
      "html": "Skip to main content\nQuick Start\nLearn\nDocs\nTools\nResources\nBlog\nSearch\nUnderstanding aelf\nCore\nCross Chain\nConsensus\nNetwork\nBoot Sequence\nAddresses\nTransactions\nSmart Contract\nACS\nContract Deployment\nTransaction Fee\nParallel Execution\nContract Proposal\nConsensus\nContract Threshold\nRandom Number\nContract CrossChain\nToken Fee\nProfit Dividend\nDividend Pool\nCross Chain Consensus\nUser Contract\nTutorials\nNode Operator\nUnderstanding aelfACSContract Deployment\nACS0 - Contract Deployment Standard\n\nACS0 manages contract deployment and updates.\n\nInterface​\n\nContracts using ACS0 need to implement these methods:\n\nMethods​\nMethod Name\tRequest\tResponse\tDescription\nDeploySystemSmartContract\tacs0.SystemContractDeploymentInput\taelf.Address\tDeploys a system smart contract and returns its address.\nDeploySmartContract\tacs0.ContractDeploymentInput\taelf.Address\tDeploys a smart contract and returns its address.\nUpdateSmartContract\tacs0.ContractUpdateInput\taelf.Address\tUpdates a smart contract.\nProposeNewContract\tacs0.ContractDeploymentInput\taelf.Hash\tCreates a proposal to deploy a new contract and returns its ID.\nProposeContractCodeCheck\tacs0.ContractCodeCheckInput\taelf.Hash\tCreates a proposal to check contract code and returns its ID.\nProposeUpdateContract\tacs0.ContractUpdateInput\taelf.Hash\tCreates a proposal to update a contract and returns its ID.\nReleaseApprovedContract\tacs0.ReleaseContractInput\tgoogle.protobuf.Empty\tReleases an approved contract proposal.\nReleaseCodeCheckedContract\tacs0.ReleaseContractInput\tgoogle.protobuf.Empty\tReleases a proposal that passed the code check.\nValidateSystemContractAddress\tacs0.ValidateSystemContractAddressInput\tgoogle.protobuf.Empty\tValidates if the input system contract exists.\nSetContractProposerRequiredState\tgoogle.protobuf.BoolValue\tgoogle.protobuf.Empty\tSets contract deployment authority.\nCurrentContractSerialNumber\tgoogle.protobuf.Empty\tgoogle.protobuf.Int64Value\tGets the current serial number of the genesis contract.\nGetContractInfo\taelf.Address\tacs0.ContractInfo\tGets information about a contract.\nGetContractAuthor\taelf.Address\taelf.Address\tGets the author of a contract.\nGetContractHash\taelf.Address\taelf.Hash\tGets the code hash of a contract by address.\nGetContractAddressByName\taelf.Hash\taelf.Address\tGets the address of a system contract by name.\nGetSmartContractRegistrationByAddress\taelf.Address\taelf.SmartContractRegistration\tGets the registration of a smart contract by address.\nGetSmartContractRegistrationByCodeHash\taelf.Hash\taelf.SmartContractRegistration\tGets the registration of a smart contract by code hash.\nDeployUserSmartContract\tacs0.ContractDeploymentInput\tacs0.DeployUserSmartContractOutput\tDeploys a user smart contract and returns the contract code hash.\nUpdateUserSmartContract\tacs0.ContractUpdateInput\tgoogle.protobuf.Empty\tUpdates a user smart contract.\nReleaseApprovedUserSmartContract\tacs0.ReleaseContractInput\tgoogle.protobuf.Empty\tReleases a proposal that passed the code check.\nPerformDeployUserSmartContract\tacs0.ContractDeploymentInput\taelf.Address\tDeploys a user contract.\nPerformUpdateUserSmartContract\tacs0.ContractUpdateInput\tgoogle.protobuf.Empty\tUpdates a user contract.\nSetContractAuthor\tacs0.SetContractAuthorInput\tgoogle.protobuf.Empty\tSets the author of a contract.\nTypes​\nacs0.AuthorUpdated​\nField\tType\tDescription\naddress\taelf.address\tContract code byte array.\nold_author\taelf.address\tContract code category (0: C#).\nacs0.CodeCheckRequired​\nField\tType\tDescription\ncode\tbytes\tContract code byte array.\nproposed_contract_input_hash\taelf.Hash\tProposed contract ID.\ncategory\tsint32\tContract code category (0: C#).\nis_system_contract\tbool\tIs it a system contract?\nis_user_contract\tbool\tIs it a user contract?\nacs0.CodeUpdated​\nField\tType\tDescription\naddress\taelf.Address\tContract address.\nold_code_hash\taelf.Hash\tOld contract code byte array.\nnew_code_hash\taelf.Hash\tNew contract code byte array.\nversion\tint32\tContract version.\nacs0.ContractCodeCheckInput#​\nField\tType\tDescription\ncontract_input\tbytes\tContract code byte array.\nis_contract_deployment\tbool\tIs the contract being deployed or updated?\ncode_check_release_method\tstring\tMethod to call after code check (DeploySmartContract or UpdateSmartContract).\nproposed_contract_input_hash\taelf.Hash\tProposed contract ID.\ncategory\tsint32\tContract code category (0: C#).\nis_system_contract\tbool\tIs it a system contract?\nacs0.ContractDeployed​\nField\tType\tDescription\nauthor\taelf.Address\tContract author.\ncode_hash\taelf.Hash\tContract code hash.\naddress\taelf.Address\tContract address.\nversion\tint32\tContract version.\nname\taelf.Hash\tContract name (must be unique).\ncontract_version\tstring\tContract version.\nacs0.ContractDeploymentInput​\nField\tType\tDescription\ncategory\tsint32\tContract code category (0: C#).\ncode\tbytes\tContract code byte array.\nacs0.DeployUserSmartContractOutput​\nField\tType\tDescription\ncode_hash\taelf.Hash\tDeployed/updated contract code hash.\nacs0.ContractInfo​\nField\tType\tDescription\nserial_number\tint64\tContract serial number.\nauthor\taelf.Address\tContract author.\ncategory\tsint32\tContract code category (0: C#).\ncode_hash\taelf.Hash\tContract code hash.\nis_system_contract\tbool\tIs it a system contract?\nversion\tint32\tContract version.\ncontract_version\tstring\tContract version.\ncontract_type\tstring\tContract type.\ndeployed_by\taelf.Address\tDeployer address.\ndeployed_on\tgoogle.protobuf.Timestamp\tDeployment time.\nacs0.ContractUpdateInput​\nField\tType\tDescription\naddress\taelf.Address\tContract address.\ncode\tbytes\tContract code byte array.\ncategory\tsint32\tContract code category (0: C#).\nis_system_contract\tbool\tIs it a system contract?\nis_user_contract\tbool\tIs it a user contract?\nacs0.ReleaseContractInput​\nField\tType\tDescription\nproposal_id\taelf.Hash\tProposal ID to be released.\nacs0.SetContractAuthorInput​\nField\tType\tDescription\naddress\taelf.Address\tContract address.\nauthor\taelf.Address\tNew author address.\nacs0.SystemContractDeploymentInput​\nField\tType\tDescription\ncategory\tsint32\tContract code category (0: C#).\ncode\tbytes\tContract code byte array.\nname\taelf.Hash\tContract name (must be unique).\nacs0.ValidateSystemContractAddressInput​\nField\tType\tDescription\nsystem_contract_hash_name\taelf.Hash\tContract name hash.\naddress\taelf.Address\tContract address.\naelf.Address​\nField\tType\tDescription\nvalue\tbytes\tAddress value in bytes.\naelf.BinaryMerkleTree​\nField\tType\tDescription\nnodes\tHash\tLeaf nodes.\nroot\tHash\tRoot node hash.\nleaf_count\tint32\tNumber of leaf nodes.\naelf.Hash​\nField\tType\tDescription\nvalue\tbytes\tHash value in bytes.\naelf.LogEvent​\nField\tType\tDescription\naddress\tAddress\tContract address.\nname\tstring\tLog event name.\nindexed\tbytes\tIndexed data for bloom filter.\nnon_indexed\tbytes\tNon-indexed data.\naelf.MerklePath​\nField\tType\tDescription\nmerkle_path_nodes\tMerklePathNode\tMerkle path nodes.\naelf.MerklePathNode​\nField\tType\tDescription\nhash\tHash\tNode hash.\nis_left_child_node\tbool\tIs it a left child node?\naelf.SInt32Value​\nField\tType\tDescription\nvalue\tsint32\tSigned 32-bit integer value.\naelf.SInt64Value​\nField\tType\tDescription\nvalue\tsint64\tSigned 64-bit integer value.\naelf.ScopedStatePath​\nField\tType\tDescription\naddress\tAddress\tScope address (contract address).\npath\tStatePath\tContract state path.\naelf.SmartContractRegistration​\nField\tType\tDescription\ncategory\tsint32\tContract code category (0: C#).\ncode\tbytes\tContract code byte array.\ncode_hash\tHash\tContract code hash.\nis_system_contract\tbool\tIs it a system contract?\nversion\tint32\tContract version.\naelf.StatePath​\nField\tType\tDescription\nparts\tstring\tState path parts.\naelf.Transaction​\nField\tType\tDescription\nfrom\tAddress\tSender address.\nto\tAddress\tContract address.\nref_block_number\tint64\tReferenced block height.\nref_block_prefix\tbytes\tReferenced block hash prefix.\nmethod_name\tstring\tSmart contract method name.\nparams\tbytes\tSmart contract method parameters.\nsignature\tbytes\tTransaction signature.\naelf.TransactionExecutingStateSet​\nField\tType\tDescription\nwrites\tTransactionExecutingStateSet.WritesEntry\tChanged states.\nreads\tTransactionExecutingStateSet.ReadsEntry\tRead states.\ndeletes\tTransactionExecutingStateSet.DeletesEntry\tDeleted states.\naelf.TransactionExecutingStateSet.DeletesEntry​\nField\tType\tDescription\nkey\tstring\tState key.\nvalue\tbool\tDeletion state (true/false).\naelf.TransactionExecutingStateSet.ReadsEntry​\nField\tType\tDescription\nkey\tstring\tState key.\nvalue\tbool\tRead state (true/false).\naelf.TransactionExecutingStateSet.WritesEntry​\nField\tType\tDescription\nkey\tstring\tState key.\nvalue\tbytes\tWritten state value.\naelf.TransactionResult​\nField\tType\tDescription\ntransaction_id\tHash\tTransaction ID.\nstatus\tTransactionResultStatus\tTransaction result status.\nlogs\tLogEvent\tLog events.\nbloom\tbytes\tBloom filter for logs.\nreturn_value\tbytes\tTransaction execution return value.\nblock_number\tint64\tBlock height.\nblock_hash\tHash\tBlock hash.\nerror\tstring\tError message.\naelf.TransactionResultStatus​\nName\tValue\tDescription\nNOT_EXISTED\t0\tTransaction result does not exist.\nPENDING\t1\tTransaction in pool waiting to be packaged.\nFAILED\t2\tTransaction execution failed.\nMINED\t3\tTransaction successfully executed and packaged.\nCONFLICT\t4\tConflicts with other transactions during parallel execution.\nPENDING_VALIDATION\t5\tWaiting for validation.\nNODE_VALIDATION_FAILED\t6\tValidation failed.\nExample​\n\nACS0 defines methods for contract deployment and updates. aelf provides the Genesis Contract as an implementation of ACS0.\n\nPrevious\nACS\nNext\nTransaction Fee\nInterface\nMethods\nTypes\nacs0.ContractCodeCheckInput#\nExample\nPlatform\nTechnology\nAudit Report\nPrivacy\nTerms of Use\nCookie Policy\nDeveloper Resources\nQuick Start\nLearn\nDocs\nTools\nResources\nEcosystem\nOverview\ndApps\naelf Ventures\nBlog\nConnect\nContact Us\nCopyright © 2024 aelf"
    },
    {
      "title": "AELF Docs",
      "url": "https://docs.aelf.com/learn/smart-contract/requirements-and-restrictions/",
      "html": "Skip to main content\nQuick Start\nLearn\nDocs\nTools\nResources\nBlog\nSearch\nUnderstanding aelf\nCore\nCross Chain\nConsensus\nNetwork\nBoot Sequence\nAddresses\nTransactions\nSmart Contract\nArchitecture\nService\nEvents\nMessages\nRestrictions\nProject Requirements\nClass Structure\nType and Namespace\nOther Restrictions\nACS\nTutorials\nNode Operator\nUnderstanding aelfSmart ContractRestrictions\nRequirements and Restrictions\n📄️ Project Requirements\n\nProtobuf and Overflow Checks\n\n📄️ Class Structure\n\nCode check restrictions\n\n📄️ Type and Namespace\n\nRestrictions\n\n📄️ Other Restrictions\n\nMethod, contract patcher & state size\n\nPrevious\nMessages\nNext\nProject Requirements\nPlatform\nTechnology\nAudit Report\nPrivacy\nTerms of Use\nCookie Policy\nDeveloper Resources\nQuick Start\nLearn\nDocs\nTools\nResources\nEcosystem\nOverview\ndApps\naelf Ventures\nBlog\nConnect\nContact Us\nCopyright © 2024 aelf"
    },
    {
      "title": "AELF Docs",
      "url": "https://docs.aelf.com/learn/smart-contract/messages/",
      "html": "Skip to main content\nQuick Start\nLearn\nDocs\nTools\nResources\nBlog\nSearch\nUnderstanding aelf\nCore\nCross Chain\nConsensus\nNetwork\nBoot Sequence\nAddresses\nTransactions\nSmart Contract\nArchitecture\nService\nEvents\nMessages\nRestrictions\nACS\nTutorials\nNode Operator\nUnderstanding aelfSmart ContractMessages\nSmart Contract Messages\n\nIn aelf, we use protobuf messages to call smart contracts and serialize their state. Here's a simple example of a message definition:\n\nmessage CreateInput {\n    string symbol = 1;\n    sint64 totalSupply = 2;\n    sint32 decimals = 3;\n}\n\n\nThis message has three fields:\n\nsymbol (string)\ntotalSupply (sint64)\ndecimals (sint32).\n\nYou can use any protobuf-supported types, including composite messages (messages containing other messages).\n\nWe use the proto3 version of protobuf for message and service definitions. You can refer to the full protobuf language reference for more details.\n\nPrevious\nEvents\nNext\nRestrictions\nPlatform\nTechnology\nAudit Report\nPrivacy\nTerms of Use\nCookie Policy\nDeveloper Resources\nQuick Start\nLearn\nDocs\nTools\nResources\nEcosystem\nOverview\ndApps\naelf Ventures\nBlog\nConnect\nContact Us\nCopyright © 2024 aelf"
    },
    {
      "title": "Events | AELF Docs",
      "url": "https://docs.aelf.com/learn/smart-contract/event/",
      "html": "Skip to main content\nQuick Start\nLearn\nDocs\nTools\nResources\nBlog\nSearch\nUnderstanding aelf\nCore\nCross Chain\nConsensus\nNetwork\nBoot Sequence\nAddresses\nTransactions\nSmart Contract\nArchitecture\nService\nEvents\nMessages\nRestrictions\nACS\nTutorials\nNode Operator\nUnderstanding aelfSmart ContractEvents\nSmart Contract Events\nEvent Option​\n\nEvents in aelf smart contracts are used to represent occurrences during execution. These events are logged in the transaction traces.\n\nExample of an event definition:\n\nmessage Transferred {\n    option (aelf.is_event) = true;\n    aelf.Address from = 1 [(aelf.is_indexed) = true];\n    aelf.Address to = 2 [(aelf.is_indexed) = true];\n    string symbol = 3 [(aelf.is_indexed) = true];\n    sint64 amount = 4;\n    string memo = 5;\n}\n\noption (aelf.is_event) = true; indicates that Transferred is an event.\n\nTo trigger this event in a contract:\n\nContext.Fire(new Transferred()\n{\n    From = from,\n    To = to,\n    ...\n});\n\n\nExternal code can monitor this event after the transaction execution.\n\nPrevious\nService\nNext\nMessages\nEvent Option\nPlatform\nTechnology\nAudit Report\nPrivacy\nTerms of Use\nCookie Policy\nDeveloper Resources\nQuick Start\nLearn\nDocs\nTools\nResources\nEcosystem\nOverview\ndApps\naelf Ventures\nBlog\nConnect\nContact Us\nCopyright © 2024 aelf"
    },
    {
      "title": "AELF Docs",
      "url": "https://docs.aelf.com/learn/smart-contract/service/",
      "html": "Skip to main content\nQuick Start\nLearn\nDocs\nTools\nResources\nBlog\nSearch\nUnderstanding aelf\nCore\nCross Chain\nConsensus\nNetwork\nBoot Sequence\nAddresses\nTransactions\nSmart Contract\nArchitecture\nService\nEvents\nMessages\nRestrictions\nACS\nTutorials\nNode Operator\nUnderstanding aelfSmart ContractService\nSmart Contract Service\n\nWhen writing a smart contract in aelf, the first step is to define it so our tools can generate it. aelf contracts are defined and generated using gRPC and protobuf.\n\nExample: Multi-Token Contract​\n\nHere is a simplified part of our multi-token contract definition:\n\nsyntax = \"proto3\";\n\npackage token;\noption csharp_namespace = \"AElf.Contracts.MultiToken.Messages\";\n\nservice TokenContract {\n    option (aelf.csharp_state) = \"AElf.Contracts.MultiToken.TokenContractState\";\n\n    // Actions\n    rpc Create (CreateInput) returns (google.protobuf.Empty) { }\n    rpc Transfer (TransferInput) returns (google.protobuf.Empty) { }\n\n    // Views\n    rpc GetBalance (GetBalanceInput) returns (GetBalanceOutput) {\n        option (aelf.is_view) = true;\n    }\n}\n\nService Methods​\n\nThere are two types of methods in a service:\n\nActions​\nThese methods take input and output protobuf messages.\nThey usually modify the state of the chain.\n\nExample:\n\nrpc Create (CreateInput) returns (google.protobuf.Empty) { }\n\nTakes a protobuf message as input and returns a protobuf message.\ngoogle.protobuf.Empty signifies returning nothing.\nConvention: append Input to protobuf types used as parameters.\nViews​\nThese methods do not modify the state of the chain.\nThey are used to query the state.\n\nExample:\n\nrpc GetBalance (GetBalanceInput) returns (GetBalanceOutput) {\n    option (aelf.is_view) = true;\n}\n\nAnnotated with a view option to indicate it's read-only.\nPrevious\nArchitecture\nNext\nEvents\nExample: Multi-Token Contract\nService Methods\nActions\nViews\nPlatform\nTechnology\nAudit Report\nPrivacy\nTerms of Use\nCookie Policy\nDeveloper Resources\nQuick Start\nLearn\nDocs\nTools\nResources\nEcosystem\nOverview\ndApps\naelf Ventures\nBlog\nConnect\nContact Us\nCopyright © 2024 aelf"
    },
    {
      "title": "AELF Docs",
      "url": "https://docs.aelf.com/learn/smart-contract/architecture/",
      "html": "Skip to main content\nQuick Start\nLearn\nDocs\nTools\nResources\nBlog\nSearch\nUnderstanding aelf\nCore\nCross Chain\nConsensus\nNetwork\nBoot Sequence\nAddresses\nTransactions\nSmart Contract\nArchitecture\nService\nEvents\nMessages\nRestrictions\nACS\nTutorials\nNode Operator\nUnderstanding aelfSmart ContractArchitecture\nSmart Contract Architecture\n\nA blockchain platform works like a distributed database that stores all smart contracts. Each contract has a unique address used for state queries and updates. Methods in the contract code handle permission checks and logic.\n\nSmart Contract Parts in aelf​\n\nInterface:\n\nSupports multiple languages.\nUses Protobuf format for cross-language definitions.\n\nState:\n\nLanguage-specific SDK provides state prototypes.\nDevelopers can query and update the state directly through these prototypes.\n\nBusiness Logic:\n\nProtobuf plugins generate the smart contract skeleton.\nDevelopers fill in the logic by overriding methods.\n\nSmart contracts in aelf are divided across the Kernel, the runtime, and the SDK. The Kernel handles core components and execution abstractions. Contracts rely on runtime modules and the SDK.\n\nA smart contract consists of methods that interact with state variables. Transactions trigger these methods to modify the blockchain state.\n\nArchitecture Overview​\n\naelf defines Smart Contracts as micro-services, making them language-independent. For example, the Consensus Protocol is a service defined by a smart contract.\n\nChain Interactions​\n\nSmart contracts interact with the chain and access contextual information via a bridge and a bridge host. The SDKs implement features to communicate through the bridge.\n\nKey contextual information provided by the bridge includes:\n\nSelf: Address of the current contract.\nSender: Address that sent the transaction.\nOrigin: Address that signed the transaction.\nOriginTransactionId and TransactionId: IDs of the transactions involved.\n\nThe bridge also allows:\n\nFiring events (similar to logging).\nCalling methods on other contracts in a read-only manner.\nSending inline transactions, which can persist state changes.\nState​\n\nSmart contracts read and/or modify state. The language SDKs provide state helpers and access through the bridge’s StateProvider.\n\nRuntime and Execution​\n\nWhen a block’s transactions are executed, each transaction generates a trace containing:\n\nReturn value of the called method.\nError outputs, if any.\nResults from inner calls in InlineTraces.\nEvents launched in Logs.\nSDK​\n\naelf has a native C# SDK for developing smart contracts in C#. It includes:\n\nHelpers to communicate with the bridge.\nType infrastructure like ContractState, MappedState, and SingletonState.\n\nAny developer or company can create an SDK and runtime for a specific language by adapting it to communicate with the bridge through gRPC.\n\nPrevious\nSmart Contract\nNext\nService\nSmart Contract Parts in aelf\nArchitecture Overview\nChain Interactions\nState\nRuntime and Execution\nSDK\nPlatform\nTechnology\nAudit Report\nPrivacy\nTerms of Use\nCookie Policy\nDeveloper Resources\nQuick Start\nLearn\nDocs\nTools\nResources\nEcosystem\nOverview\ndApps\naelf Ventures\nBlog\nConnect\nContact Us\nCopyright © 2024 aelf"
    },
    {
      "title": "AELF Docs",
      "url": "https://docs.aelf.com/tools/chain-sdk/javascript-sdk/",
      "html": "Skip to main content\nQuick Start\nLearn\nDocs\nTools\nResources\nBlog\nSearch\nTools\nChain SDK\nJavascript SDK\nC# SDK\nGo SDK\nJAVA SDK\nPHP SDK\nPython SDK\naelf Deploy Tool\naelf CLI\nSmart Contract\naelf Testnet Faucet\naelf Design\naelf Playground\nContract SDK\nToolsChain SDKJavascript SDK\naelf-sdk.js - aelf JavaScript API\nIntroduction​\n\nThe aelf-sdk.js library for aelf is similar to web3.js for Ethereum. It allows you to interact with a local or remote aelf node using an HTTP connection.\n\nThis guide will help you install and use aelf-sdk.js, with an API reference and examples.\n\nFor more details, check out the repository: aelf-sdk.js.\n\nAdding aelf-sdk.js​\n\nFirst, you need to add aelf-sdk.js to your project. You can do this using the following methods\n\nUsing npm​\nnpm install aelf-sdk\n\nPure JS​\n\nAdd the script link in your HTML:\n\n<script src=\"https://unpkg.com/aelf-sdk@latest/dist/aelf.umd.js\"></script>\n\n\nThen, create an aelf instance and set a provider.\n\n// In Node.js\nconst AElf = require('aelf-sdk');\nconst aelf = new AElf(new AElf.providers.HttpProvider('http://127.0.0.1:8000'));\n\n// In browser\n// <script src=\"https://unpkg.com/aelf-sdk@latest/dist/aelf.umd.js\"></script>\n\nExamples​\n\nYou can find more examples in the ./examples directory.\n\nCreate Instance​\nimport AElf from 'aelf-sdk';\n\n// Create a new instance of AElf\nconst aelf = new AElf(new AElf.providers.HttpProvider('http://127.0.0.1:1235'));\n\nCreate or Load a Wallet​\n// Create a new wallet\nconst newWallet = AElf.wallet.createNewWallet();\n\n// Load a wallet by private key\nconst privateKeyWallet = AElf.wallet.getWalletByPrivateKey('your-private-key');\n\n// Load a wallet by mnemonic\nconst mnemonicWallet = AElf.wallet.getWalletByMnemonic('your-mnemonic');\n\nGet a System Contract Address​\nconst tokenContractName = 'AElf.ContractNames.Token';\nlet tokenContractAddress;\n\n(async () => {\n  // Get chain status\n  const chainStatus = await aelf.chain.getChainStatus();\n  // Get genesis contract address\n  const GenesisContractAddress = chainStatus.GenesisContractAddress;\n  // Get genesis contract instance\n  const zeroContract = await aelf.chain.contractAt(GenesisContractAddress, newWallet);\n  // Get contract address by the read-only method 'GetContractAddressByName' of genesis contract\n  tokenContractAddress = await zeroContract.GetContractAddressByName.call(AElf.utils.sha256(tokenContractName));\n})();\n\nGet a Contract Instance​\nconst wallet = AElf.wallet.createNewWallet();\nlet tokenContract;\n\n// Async method\n(async () => {\n  tokenContract = await aelf.chain.contractAt(tokenContractAddress, wallet);\n})();\n\n// Promise method\naelf.chain.contractAt(tokenContractAddress, wallet)\n  .then(result => {\n    tokenContract = result;\n  });\n\n// Callback method\naelf.chain.contractAt(tokenContractAddress, wallet, (error, result) => {\n  if (error) throw error;\n  tokenContract = result;\n});\n\nUse Contract Instance​\n\nHow to use a contract instance. You can call methods in two ways: read-only and send transaction.\n\n(async () => {\n  // Read-only method: Get the balance of an address\n  const balanceResult = await tokenContract.GetBalance.call({\n    symbol: \"ELF\",\n    owner: \"7s4XoUHfPuqoZAwnTV7pHWZAaivMiL8aZrDSnY9brE1woa8vz\"\n  });\n  console.log(balanceResult);\n  /**\n  {\n    \"symbol\": \"ELF\",\n    \"owner\": \"7s4XoUHfPuqoZAwnTV7pHWZAaivMiL8aZrDSnY9brE1woa8vz\",\n    \"balance\": \"1000000000000\"\n  }\n  */\n\n  // Send transaction method: Transfer tokens\n  const transactionId = await tokenContract.Transfer({\n    symbol: \"ELF\",\n    to: \"7s4XoUHfPuqoZAwnTV7pHWZAaivMiL8aZrDSnY9brE1woa8vz\",\n    amount: \"1000000000\",\n    memo: \"transfer in demo\"\n  });\n  console.log(transactionId);\n  /**\n  {\n    \"TransactionId\": \"123123\"\n  }\n  */\n})();\n\nChange the Node Endpoint​\nimport AElf from 'aelf-sdk';\n\nconst aelf = new AElf(new AElf.providers.HttpProvider('http://127.0.0.1:1235'));\naelf.setProvider(new AElf.providers.HttpProvider('http://127.0.0.1:8000'));\n\nWeb API​\n\nYou can access the Web API of your aelf node at {chainAddress}/swagger/index.html.\n\nFor example, if your local node address is http://127.0.0.1:1235, you can view the Web API at http://127.0.0.1:1235/swagger/index.html.\n\nparameters and returns based on the URL: https://aelf-public-node.aelf.io/swagger/index.html\n\nThe methods below use an instance of aelf. If you don't have one, create it as shown:\n\nimport AElf from 'aelf-sdk';\n\n// Create a new instance of AElf, change the URL if needed\nconst aelf = new AElf(new AElf.providers.HttpProvider('http://127.0.0.1:1235'));\n\n1. Get Chain Status​\n\nGet the current status of the blockchain.\n\nWeb API Path: /api/blockChain/chainStatus\n\nMethod: GET\n\nParameters: None\n\nReturns: Object\n\nChainId - String\nBranches - Object\nNotLinkedBlocks - Object\nLongestChainHeight - Number\nLongestChainHash - String\nGenesisBlockHash - String\nGenesisContractAddress - String\nLastIrreversibleBlockHash - String\nLastIrreversibleBlockHeight - Number\nBestChainHash - String\nBestChainHeight - Number\nExample:​\naelf.chain.getChainStatus()\n  .then(res => {\n    console.log(res);\n  });\n\n2. Get Contract File Descriptor Set​\n\nGet the protobuf definitions related to a contract.\n\nWeb API Path: /api/blockChain/contractFileDescriptorSet\nMethod: GET\nParameters: contractAddress (String)\nReturns: String.\nExample:​\naelf.chain.getContractFileDescriptorSet(contractAddress)\n  .then(res => {\n    console.log(res);\n  });\n\n3. Get Block Height​\n\nGet the current best height of the chain.\n\nWeb API Path: /api/blockChain/blockHeight\nMethod: GET\nParameters: None\nReturns: Number.\nExample:​\naelf.chain.getBlockHeight()\n  .then(res => {\n    console.log(res);\n  });\n\n4. Get Block​\n\nGet block information by block hash.\n\nWeb API Path: /api/blockChain/block\n\nMethod: GET\n\nParameters:\n\nblockHash (String)\nincludeTransactions (Boolean)\ntrue require transaction ids list in the block\nfalse Doesn’t require transaction ids list in the block\n\nReturns: Object\n\nBlockHash - String\n\nHeader - Object\n\nPreviousBlockHash - String\nMerkleTreeRootOfTransactions - String\nMerkleTreeRootOfWorldState - String\nExtra - Array\nHeight - Number\nTime - google.protobuf.Timestamp\nChainId - String\nBloom - String\nSignerPubkey - String\n\nBody - Object\n\nTransactionsCount - Number\nTransactions - Array\ntransactionId - String\nExample:​\naelf.chain.getBlock(blockHash, false)\n  .then(res => {\n    console.log(res);\n  });\n\n5. Get Block By Height​\n\nGet block information by block height.\n\nWeb API Path: /api/blockChain/blockByHeight\n\nMethod: GET\n\nParameters:\n\nblockHash (String)\nincludeTransactions (Boolean)\ntrue require transaction ids list in the block\nfalse Doesn’t require transaction ids list in the block\n\nReturns: Object\n\nBlockHash - String\n\nHeader - Object\n\nPreviousBlockHash - String\nMerkleTreeRootOfTransactions - String\nMerkleTreeRootOfWorldState - String\nExtra - Array\nHeight - Number\nTime - google.protobuf.Timestamp\nChainId - String\nBloom - String\nSignerPubkey - String\n\nBody - Object\n\nTransactionsCount - Number\nTransactions - Array\ntransactionId - String\nExample:​\naelf.chain.getBlockByHeight(12, false)\n  .then(res => {\n    console.log(res);\n  });\n\n6. Get Transaction Result​\n\nWeb API Path: /api/blockChain/transactionResult\n\nMethod: GET\n\nParameters: transactionId (String)\n\nReturns: Object\n\nTransactionId - String\nStatus - String\nLogs - Array\nAddress - String\nName - String\nIndexed - Array\nNonIndexed - Number\nBloom - String\nBlockNumber - Number\nTransaction - Object\nFrom - String\nTo - String\nRefBlockNumber - Number\nRefBlockPrefix - String\nMethodName - String\nParams - Object\nSignature - String\nReadableReturnValue - Object\nError - String\nExample:​\naelf.chain.getTxResult(transactionId)\n  .then(res => {\n    console.log(res);\n  });\n\n7. Get Multiple Transaction Results​\nWeb API Path: /api/blockChain/transactionResults\nMethod: GET\nParameters:\nblockHash (String)\noffset (Number)\nlimit (Number)\nReturns:\nArray - The array of method descriptions:\nthe transaction result object\nExample:​\naelf.chain.getTxResults(blockHash, 0, 2)\n  .then(res => {\n    console.log(res);\n  });\n\n8. Get Transaction Pool Status​\nWeb API Path: /api/blockChain/transactionPoolStatus\nMethod: GET\nParameters: None\n9. Send Transaction​\nWeb API Path: /api/blockChain/sendTransaction\nMethod: POST\nParameters: Object (Serialized protobuf data with RawTransaction string)\nRawTransaction - String\n10. Send Multiple Transactions​\nWeb API Path: /api/blockChain/sendTransactions\nMethod: POST\nParameters: Object (Serialized protobuf data with RawTransaction string)\nRawTransaction - String\n11. Call Read-Only Method​\n\nCall a read-only method on a contract.\n\nMethod: POST\nParameters: Object (Serialized protobuf data with RawTransaction string)\nRawTransaction - String\nReturns: Method call result\n12. Get Peers​\n\nGet peer info about the connected network nodes.\n\nMethod: GET\nParameters: withMetrics (Boolean)\ntrue with metrics\nfalse without metrics\n13. Add Peer​\n\nAttempts to add a node to the connected network nodes\n\nMethod: POST\nParameters: Object The object with the following structure :\nAddress - String\n14. Remove Peer​\n\nAttempts to remove a node from the connected network nodes\n\nMethod: DELETE\nParameters: address (String)\n15. Calculate Transaction Fee​\nWeb API Path: /api/blockChain/calculateTransactionFee\nMethod: POST\nParameters: CalculateTransactionFeeInput (Object with RawTransaction string):\nRawTransaction - String\nReturns: CalculateTransactionFeeOutput (Object with fee details):\nSuccess - Bool\nTransactionFee - Array\nResourceFee - Array\nExample​\naelf.chain.calculateTransactionFee(rawTransaction)\n   .then(res => {\n      console.log(res);\n   });\n\n16. Network Info​\nMethod: GET\nParameters: None\nReturns: Network connection info\nAElf.wallet​\n\nAElf.wallet is a static property of AElf.\n\n1. createNewWallet​\n\nReturns:\n\nObject\n\nmnemonic - String: The mnemonic phrase for the wallet.\nBIP44Path - String: The BIP44 path, formatted as m/purpose’/coin_type’/account’/change/address_index.\nchildWallet - Object: The Hierarchical Deterministic (HD) wallet object.\nkeyPair - String: The elliptic curve (EC) key pair.\nprivateKey - String: The private key for the wallet.\naddress - String: The wallet address.\nExample:​\nimport AElf from 'aelf-sdk';\nconst wallet = AElf.wallet.createNewWallet();\nconsole.log(wallet);\n\n2. getWalletByMnemonic​\n\nRetrieves a wallet using a mnemonic phrase.\n\nParameters:\n\nmnemonic - String: The mnemonic phrase of the wallet.\n\nReturns:\n\nObject: The complete wallet object.\nExample:​\nconst wallet = AElf.wallet.getWalletByMnemonic(mnemonic);\nconsole.log(wallet);\n\n3. getWalletByPrivateKey​\n\nRetrieves a wallet using a private key.\n\nParameters:\n\nprivateKey - String: The mnemonic phrase of the wallet.\n\nReturns:\n\nObject: The complete wallet object, with an empty mnemonic.\nExample:​\nconst wallet = AElf.wallet.getWalletByPrivateKey(privateKey);\nconsole.log(wallet);\n\n4. signTransaction​\n\nSigns a transaction using the wallet's key pair.\n\nParameters:\n\nrawTxn - String: The raw transaction data.\nkeyPair - String: The key pair to sign the transaction.\n\nReturns:\n\nObject: The signed transaction object.\nExample:​\nconst result = AElf.wallet.signTransaction(rawTxn, keyPair);\nconsole.log(result);\n\n5. AESEncrypt​\n\nEncrypts a string using the AES algorithm.\n\nParameters:\n\ninput - String: The input string to encrypt.\npassword - String: The password to use for encryption.\n\nReturns:\n\nString: The encrypted string.\n6. AESDecrypt​\n\nDecrypts a string using the AES algorithm.\n\nParameters:\n\ninput - String: The encrypted string.\npassword - String: The password used for encryption.\n\nReturns:\n\nString: The decrypted string.\n\nThese are the detailed functions and their usages for the AElf.wallet API. If you have any specific questions or need further clarification, feel free to ask!\n\nAElf.pbjs​\n\nReference to protobuf.js. For detailed usage, refer to the protobuf.js documentation.\n\nAElf.pbUtils​\n\nProvides basic format methods for aelf. For detailed code, see src/utils/proto.js.\n\nAElf.utils​\n\nContains utility methods for aelf. For detailed code, see src/utils/utils.js.\n\nCheck address​\n\nExample to check if an address is valid using base58 utility from aelf.\n\nExample:​\nconst AElf = require('aelf-sdk');\nconst { base58 } = AElf.utils;\n\ntry {\n  base58.decode('$address'); // replace '$address' with actual address\n  console.log('Valid address');\n} catch (error) {\n  console.error('Invalid address', error);\n}\n\nAElf.version​\nimport AElf from 'aelf-sdk';\nconsole.log(AElf.version); // outputs the version, e.g., 3.2.23\n\nRequirements​\n\nTo use aelf SDK, you need:\n\nNode.js\nNPM\nSupport​\n\n \n\nAbout contributing​\n\nRead out [contributing guide]\n\nAbout Version​\n\nAElf SDK follows Semantic Versioning. For more details, refer to semver.org.\n\nPrevious\nChain SDK\nNext\nC# SDK\nIntroduction\nAdding aelf-sdk.js\nUsing npm\nPure JS\nExamples\nCreate Instance\nCreate or Load a Wallet\nGet a System Contract Address\nGet a Contract Instance\nUse Contract Instance\nChange the Node Endpoint\nWeb API\n1. Get Chain Status\n2. Get Contract File Descriptor Set\n3. Get Block Height\n4. Get Block\n5. Get Block By Height\n6. Get Transaction Result\n7. Get Multiple Transaction Results\n8. Get Transaction Pool Status\n9. Send Transaction\n10. Send Multiple Transactions\n11. Call Read-Only Method\n12. Get Peers\n13. Add Peer\n14. Remove Peer\n15. Calculate Transaction Fee\n16. Network Info\nAElf.wallet\n1. createNewWallet\n2. getWalletByMnemonic\n3. getWalletByPrivateKey\n4. signTransaction\n5. AESEncrypt\n6. AESDecrypt\nAElf.pbjs\nAElf.pbUtils\nAElf.utils\nCheck address\nAElf.version\nRequirements\nSupport\nAbout contributing\nAbout Version\nPlatform\nTechnology\nAudit Report\nPrivacy\nTerms of Use\nCookie Policy\nDeveloper Resources\nQuick Start\nLearn\nDocs\nTools\nResources\nEcosystem\nOverview\ndApps\naelf Ventures\nBlog\nConnect\nContact Us\nCopyright © 2024 aelf"
    },
    {
      "title": "AELF Docs",
      "url": "https://docs.aelf.com/tools/aelf-cli/introduction/",
      "html": "Skip to main content\nQuick Start\nLearn\nDocs\nTools\nResources\nBlog\nSearch\nTools\nChain SDK\naelf Deploy Tool\naelf CLI\nIntroduction to CLI\nCommands\nSmart Contract\naelf Testnet Faucet\naelf Design\naelf Playground\nContract SDK\nToolsaelf CLIIntroduction to CLI\nIntroduction to the CLI\n\nThe aelf-command tool is a Command Line Interface (CLI) designed for interacting with an aelf node. This guide will introduce you to its key features and show you how to install and use the tool.\n\nFeatures​\nConfiguration Management: Easily get or set common configurations like endpoint, account, data directory, and password.\nUser-Friendly Prompts: For new users, missing parameters will be prompted interactively.\nAccount Management: Create new accounts or load existing ones using a private key or mnemonic.\nWallet Information: Display wallet details including private key, address, public key, and mnemonic.\nEncryption: Encrypt account information into keyStore format and save it to a file.\nBlockchain Interaction:\nRetrieve the current best height of the chain.\nGet block information by height or block hash.\nGet transaction results by transaction ID.\nSend transactions or call read-only methods on smart contracts.\nDeploy smart contracts.\nOpen a REPL (Read-Eval-Print Loop) for using JavaScript to interact with the chain.\nFriendly UI: Enhanced user interactions with chalk and ora for a better visual experience.\nChain Status: Retrieve the current chain status.\nProposal Management: Create proposals on any contract method.\nTransaction Deserialization: Deserialize results returned by executing a transaction.\nSocket.io Server: Start a socket.io server to provide services for dApps.\nInstallation​\n\nTo install the aelf-command tool globally, use npm:\n\nnpm install aelf-command -g\n\nUsing aelf-command​\nFirst Step​\n\nYou need to create a new account or load an existing account using a private key or mnemonic.\n\nCreate a New Wallet\n\naelf-command create\n\n\nOutput example:\n\nYour wallet info is:\nMnemonic:            great mushroom loan crisp ... door juice embrace\nPrivate Key:         e038eea7e151eb451ba2901f7...b08ba5b76d8f288\nPublic Key:          0478903d96aa2c8c0...6a3e7d810cacd136117ea7b13d2c9337e1ec88288111955b76ea\nAddress:             2Ue31YTuB5Szy7cnr3SCEGU2gtGi5uMQBYarYUR5oGin1sys6H\n✔ Save account info into a file? … no / yes\n✔ Enter a password … ********\n✔ Confirm password … ********\n✔\nAccount info has been saved to \"/Users/young/.local/share/aelf/keys/2Ue31YTuB5Szy7cnr...Gi5uMQBYarYUR5oGin1sys6H.json\"\n\n\nLoad Wallet from Private Key\n\naelf-command load e038eea7e151eb451ba2901f7...b08ba5b76d8f288\n\n\nOutput example:\n\nYour wallet info is:\nPrivate Key:         e038eea7e151eb451ba2901f7...b08ba5b76d8f288\nPublic Key:          0478903d96aa2c8c0...6a3e7d810cacd136117ea7b13d2c9337e1ec88288111955b76ea\nAddress:             2Ue31YTuB5Szy7cnr3SCEGU2gtGi5uMQBYarYUR5oGin1sys6H\n✔ Save account info into a file?\n✔ Enter a password … ********\n✔ Confirm password … ********\n✔\nAccount info has been saved to \"/Users/young/.local/share/aelf/keys/2Ue31YTuB5Szy7cnr...Gi5uMQBYarYUR5oGin1sys6H.json\"\n\n\nShow Wallet Info\n\naelf-command wallet -a 2Ue31YTuB5Szy7cnr3SCEGU2gtGi5uMQBYarYUR5oGin1sys6H\n\n\nOutput example:\n\nYour wallet info is:\nPrivate Key:         e038eea7e151eb451ba2901f7...b08ba5b76d8f288\nPublic Key:          0478903d96aa2c8c0...6a3e7d810cacd136117ea7b13d2c9337e1ec88288111955b76ea\nAddress:             2Ue31YTuB5Szy7cnr3SCEGU2gtGi5uMQBYarYUR5oGin1sys6H\n\n\nHere you can decide whether to encrypt the account info and save it to a file.\n\nExamples​\n\nInteractive Console\n\naelf-command console -a 2Ue31YTuB5Szy7cnr3SCEGU2gtGi5uMQBYarYUR5oGin1sys6H\n✔ Enter the URI of an AElf node: http://127.0.0.1:8000\n✔ Enter the password you typed when creating a wallet … ********\n✔ Succeed!\nWelcome to aelf interactive console. Ctrl + C to terminate the program. Double tap Tab to list objects\n\n   ╔═══════════════════════════════════════════════════════════╗\n   ║                                                           ║\n   ║   NAME       | DESCRIPTION                                ║\n   ║   AElf       | imported from aelf-sdk                     ║\n   ║   aelf       | the instance of an aelf-sdk, connect to    ║\n   ║              | http://127.0.0.1:8000                      ║\n   ║   _account   | the instance of an AElf wallet, address    ║\n   ║              | is                                         ║\n   ║              | 2Ue31YTuB5Szy7cnr3SCEGU2gtGi5uMQBYarYUR…   ║\n   ║              | 5oGin1sys6H                                ║\n   ║                                                           ║\n   ╚═══════════════════════════════════════════════════════════╝\n   \n\n\nDefault Parameters\n\naelf-command console\n✔ Enter the URI of an AElf node: http://127.0.0.1:8000\n✔ Enter a valid wallet address, if you don't have, create one by aelf-command create … 2Ue31YTuB5Szy7cnr3SCEGU2gtGi5uMQBYarYUR5oGin1sys6H\n✔ Enter the password you typed when creating a wallet … ********\n✔ Succeed!\nWelcome to aelf interactive console. Ctrl + C to terminate the program. Double tap Tab to list objects\n\n   ╔═══════════════════════════════════════════════════════════╗\n   ║                                                           ║\n   ║   NAME       | DESCRIPTION                                ║\n   ║   AElf       | imported from aelf-sdk                     ║\n   ║   aelf       | the instance of an aelf-sdk, connect to    ║\n   ║              | http://13.231.179.27:8000                  ║\n   ║   _account   | the instance of an AElf wallet, address    ║\n   ║              | is                                         ║\n   ║              | 2Ue31YTuB5Szy7cnr3SCEGU2gtGi5uMQBYarYUR…   ║\n   ║              | 5oGin1sys6H                                ║\n   ║                                                           ║\n   ╚═══════════════════════════════════════════════════════════╝\n\nHelp​\n\nTo get help, use:\n\naelf-command -h\n\n\nOutput example:\n\nUsage: aelf-command [command] [options]\n\nOptions:\n  -v, --version                                            output the version number\n  -e, --endpoint <URI>                                     The URI of an aelf node. Eg: http://127.0.0.1:8000\n  -a, --account <account>                                  The address of aelf wallet\n  -p, --password <password>                                The password of encrypted keyStore\n  -d, --datadir <directory>                                The directory that contains the aelf related files. Defaults to {home}/.local/share/aelf\n  -h, --help                                               output usage information\n\nCommands:\n  call [contract-address|contract-name] [method] [params]     Call a read-only method on a contract.\n  send [contract-address|contract-name] [method] [params]     Execute a method on a contract.\n  get-blk-height                                              Get the current block height of specified chain\n  get-chain-status                                            Get the current chain status\n  get-blk-info [height|block-hash] [include-txs]              Get a block info\n  get-tx-result [tx-id]                                       Get a transaction result\n  console                                                     Open a node REPL\n  create [options] [save-to-file]                             Create a new account\n  wallet                                                      Show wallet details which include private key, address, public key and mnemonic\n  load [private-key|mnemonic] [save-to-file]                  Load wallet from a private key or mnemonic\n  proposal [proposal-contract] [organization] [expired-time]  Send a proposal to an origination with a specific contract method\n  deploy [category] [code-path]                               Deprecated! Please use  `aelf-command send` , check details in aelf-command `README.md`\n  config <flag> [key] [value]                                 Get, set, delete or list aelf-command config\n  event [tx-id]                                               Deserialize the result returned by executing a transaction\n  dapp-server [options]                                       Start a dAPP SOCKET.IO server\n\n\nTo get help for a sub-command, such as call, use:\n\naelf-command call -h\n\n\nOutput example:\n\nUsage: aelf-command call [options] [contract-address|contract-name] [method] [params]\n\nCall a read-only method on a contract.\n\nOptions:\n  -h, --help  output usage information\n\nExamples:\n\naelf-command call <contractName|contractAddress> <method> <params>\naelf-command call <contractName|contractAddress> <method>\naelf-command call <contractName|contractAddress>\naelf-command call\n\n\nFor the interactive console:\n\naelf-command console -h\n\n\nOutput example:\n\nUsage: aelf-command console [options]\n\nOpen a node REPL\n\nOptions:\n  -h, --help  output usage information\n\nExamples:\n\naelf-command console\n\nPrevious\naelf CLI\nNext\nCommands\nFeatures\nInstallation\nUsing aelf-command\nFirst Step\nExamples\nHelp\nPlatform\nTechnology\nAudit Report\nPrivacy\nTerms of Use\nCookie Policy\nDeveloper Resources\nQuick Start\nLearn\nDocs\nTools\nResources\nEcosystem\nOverview\ndApps\naelf Ventures\nBlog\nConnect\nContact Us\nCopyright © 2024 aelf"
    },
    {
      "title": "AELF Docs",
      "url": "https://docs.aelf.com/learn/cross-chain/cross-chain-transfer/",
      "html": "Skip to main content\nQuick Start\nLearn\nDocs\nTools\nResources\nBlog\nSearch\nUnderstanding aelf\nCore\nCross Chain\nIntroduction\nArchitecture\nCross Chain Verification\nVerify\nCross Chain Transfer\nConsensus\nNetwork\nBoot Sequence\nAddresses\nTransactions\nSmart Contract\nACS\nTutorials\nNode Operator\nUnderstanding aelfCross ChainCross Chain Transfer\nCross Chain Transfer\n\nCross chain transfer is one of the most commonly used cases when it comes to cross chain verification. aelf already supports cross chain transfer functionality in its contract. This section will explain how to transfer tokens across chains. It assumes a side chain is already deployed and has been indexed by the main chain.\n\nThe transfer process will always use the same contract methods and follow these two steps:\n\nInitiate the transfer\nReceive the tokens\nPrepare​\n\nThere are a few preparation steps required before a cross chain transfer, which need to be done only once for each chain. If these steps are already completed, you can skip this part.\n\nLet's say you want to transfer token FOO from chain A to chain B. Before you start, make sure you understand how cross chain transaction verification works. Any input containing MerklePath in the following steps means that cross chain verification is needed. Refer to the cross chain verification documentation for more details.\n\nValidate Token Contract address on chain A\n\nSend transaction tx_1 to the Genesis Contract with the method ValidateSystemContractAddress. You need to provide system_contract_hash_name and the address of the Token Contract. tx_1 should be successfully packed in the block.\n\nrpc ValidateSystemContractAddress(ValidateSystemContractAddressInput) returns (google.protobuf.Empty){}\n\nmessage ValidateSystemContractAddressInput {\n    aelf.Hash system_contract_hash_name = 1;\n    aelf.Address address = 2;\n}\n\n\nRegister the token contract address of chain A on chain B\n\nCreate a proposal for the RegisterCrossChainTokenContractAddress for the default parliament organization on chain B. Refer to the Parliament contract documentation for more details. Apart from cross chain verification context, you also need to provide the origin data of tx_1 and the Token Contract address on chain A.\n\nrpc RegisterCrossChainTokenContractAddress (RegisterCrossChainTokenContractAddressInput) returns (google.protobuf.Empty) {}\n\nmessage RegisterCrossChainTokenContractAddressInput {\n    int32 from_chain_id = 1;\n    int64 parent_chain_height = 2;\n    bytes transaction_bytes = 3;\n    aelf.MerklePath merkle_path = 4;\n    aelf.Address token_contract_address = 5;\n}\n\n\nValidate TokenInfo of FOO on chain A\n\nSend transaction tx_2 to the Token Contract with the method ValidateTokenInfoExists on chain A. You need to provide TokenInfo of FOO. tx_2 should be successfully packed in the block.\n\nrpc ValidateTokenInfoExists(ValidateTokenInfoExistsInput) returns (google.protobuf.Empty){}\n\nmessage ValidateTokenInfoExistsInput {\n    string symbol = 1;\n    string token_name = 2;\n    int64 total_supply = 3;\n    int32 decimals = 4;\n    aelf.Address issuer = 5;\n    bool is_burnable = 6;\n    int32 issue_chain_id = 7;\n}\n\n\nCreate token FOO on chain B\n\nSend transaction tx_3 to the Token Contract with the method CrossChainCreateToken on chain B. You need to provide the origin data of tx_2 and the cross chain verification context of tx_2.\n\nrpc CrossChainCreateToken(CrossChainCreateTokenInput) returns (google.protobuf.Empty) {}\n\nmessage CrossChainCreateTokenInput {\n    int32 from_chain_id = 1;\n    int64 parent_chain_height = 2;\n    bytes transaction_bytes = 3;\n    aelf.MerklePath merkle_path = 4;\n}\n\nInitiate the Transfer​\n\nOn the token contract of the source chain, the CrossChainTransfer method is used to trigger the transfer:\n\nrpc CrossChainTransfer (CrossChainTransferInput) returns (google.protobuf.Empty) { }\n\nmessage CrossChainTransferInput {\n    aelf.Address to = 1;\n    string symbol = 2;\n    sint64 amount = 3;\n    string memo = 4;\n    int32 to_chain_id = 5;\n    int32 issue_chain_id = 6;\n}\n\nThe fields of the input:​\nto: the target address to receive the token\nsymbol: the symbol of the token to be transferred\namount: the amount of the token to be transferred\nmemo: a memo field for this transfer\nto_chain_id: the destination chain ID where the tokens will be received\nissue_chain_id: the chain ID where the token was issued\nReceive on the Destination Chain​\n\nOn the destination chain where the tokens need to be received, the CrossChainReceiveToken method is used to trigger the reception:\n\nrpc CrossChainReceiveToken (CrossChainReceiveTokenInput) returns (google.protobuf.Empty) { }\n\nmessage CrossChainReceiveTokenInput {\n    int32 from_chain_id = 1;\n    int64 parent_chain_height = 2;\n    bytes transfer_transaction_bytes = 3;\n    aelf.MerklePath merkle_path = 4;\n}\n\nrpc GetBoundParentChainHeightAndMerklePathByHeight (aelf.Int64Value) returns (CrossChainMerkleProofContext) {\n    option (aelf.is_view) = true;\n}\n\nmessage CrossChainMerkleProofContext {\n    int64 bound_parent_chain_height = 1;\n    aelf.MerklePath merkle_path_from_parent_chain = 2;\n}\n\nThe fields of the input:​\n\nfrom_chain_id: the source chain ID from which the cross chain transfer was launched\n\nparent_chain_height: the height of the block on the main chain that contains the CrossChainTransfer transaction (for main chain to side chain transfer). For side chain to side chain or side chain to main chain transfer, it is the result of GetBoundParentChainHeightAndMerklePathByHeight (input is the height of the CrossChainTransfer), accessible in the bound_parent_chain_height field.\n\ntransfer_transaction_bytes: the serialized form of the CrossChainTransfer transaction.\n\nmerkle_path: obtained from the source chain. The construction of merkle path data differs among cases:\n\nMain chain to side chain transfer: merkle path from the main chain’s web API GetMerklePathByTransactionIdAsync (with CrossChainTransfer transaction ID as input).\nSide chain to side chain or side chain to main chain transfer:\nmerkle path from the source chain’s web API GetMerklePathByTransactionIdAsync (with CrossChainTransfer transaction ID as input).\noutput of GetBoundParentChainHeightAndMerklePathByHeight method in the CrossChain Contract (with CrossChainTransfer transaction’s block height as input). Path nodes are in the merkle_path_from_parent_chain field of the CrossChainMerkleProofContext object.\nConcatenate the above two merkle paths.\nPrevious\nVerify\nNext\nConsensus\nPrepare\nInitiate the Transfer\nThe fields of the input:\nReceive on the Destination Chain\nThe fields of the input:\nPlatform\nTechnology\nAudit Report\nPrivacy\nTerms of Use\nCookie Policy\nDeveloper Resources\nQuick Start\nLearn\nDocs\nTools\nResources\nEcosystem\nOverview\ndApps\naelf Ventures\nBlog\nConnect\nContact Us\nCopyright © 2024 aelf"
    },
    {
      "title": "Verify | AELF Docs",
      "url": "https://docs.aelf.com/learn/cross-chain/verify/",
      "html": "Skip to main content\nQuick Start\nLearn\nDocs\nTools\nResources\nBlog\nSearch\nUnderstanding aelf\nCore\nCross Chain\nIntroduction\nArchitecture\nCross Chain Verification\nVerify\nCross Chain Transfer\nConsensus\nNetwork\nBoot Sequence\nAddresses\nTransactions\nSmart Contract\nACS\nTutorials\nNode Operator\nUnderstanding aelfCross ChainVerify\nCross Chain Transaction Verification\n\nThis section provides guidance on verifying transactions across different blockchain chains, assuming that a side chain has already been deployed and indexed by the main chain.\n\nSending a Transaction​\n\nAny transaction with the status \"Mined\" can be verified, provided that the transaction has been indexed.\n\nVerifying the Transaction​\n\nThere are two scenarios for verification:\n\nVerifying a transaction on the main chain.\nVerifying a transaction on a side chain.\nrpc VerifyTransaction (VerifyTransactionInput) returns (google.protobuf.BoolValue) {\n  option (aelf.is_view) = true;\n}\n\nmessage VerifyTransactionInput {\n    aelf.Hash transaction_id = 1;\n    aelf.MerklePath path = 2;\n    int64 parent_chain_height = 3;\n    int32 verified_chain_id = 4;\n}\n\n\nThe VerifyTransaction method is used for verification and returns whether the transaction was mined and indexed by the destination chain. The method is the same for both scenarios; only the input values differ.\n\nVerifying a Main Chain Transaction​\n\nTo verify a main chain transaction on a side chain, use the VerifyTransaction method on the side chain with the following input values:\n\nparent_chain_height: The height of the block on the main chain where the transaction was packed.\ntransaction_id: The ID of the transaction to verify.\npath: The Merkle path obtained from the main chain's API using GetMerklePathByTransactionIdAsync with the transaction ID.\nverified_chain_id: The chain ID of the main chain.\n\nYou can retrieve the Merkle path of a transaction in a block by using the chain's API method GetMerklePathByTransactionIdAsync.\n\nVerifying a Side Chain Transaction​\n\nFor verifying a side chain transaction:\n\nObtain the Merkle path using GetMerklePathByTransactionIdAsync, similar to main chain verification.\nRetrieve the CrossChainMerkleProofContext of the transaction from the source chain using GetBoundParentChainHeightAndMerklePathByHeight.\nrpc GetBoundParentChainHeightAndMerklePathByHeight (google.protobuf.Int64Value) returns (CrossChainMerkleProofContext) {\n    option (aelf.is_view) = true;\n}\n\nmessage CrossChainMerkleProofContext {\n    int64 bound_parent_chain_height = 1;\n    aelf.MerklePath merkle_path_from_parent_chain = 2;\n}\n\n\nUsing the result from the above API, call VerifyTransaction on the target chain with:\n\ntransaction_id: The ID of the transaction to verify.\nparent_chain_height: Use the bound_parent_chain_height field from CrossChainMerkleProofContext.\npath: Concatenate the two Merkle paths in order:\nThe Merkle path of the transaction (obtained from GetMerklePathByTransactionIdAsync).\nThe merkle_path_from_parent_chain field from CrossChainMerkleProofContext.\nverified_chain_id: The chain ID of the side chain where the transaction was mined.\nPrevious\nCross Chain Verification\nNext\nCross Chain Transfer\nSending a Transaction\nVerifying the Transaction\nVerifying a Main Chain Transaction\nVerifying a Side Chain Transaction\nPlatform\nTechnology\nAudit Report\nPrivacy\nTerms of Use\nCookie Policy\nDeveloper Resources\nQuick Start\nLearn\nDocs\nTools\nResources\nEcosystem\nOverview\ndApps\naelf Ventures\nBlog\nConnect\nContact Us\nCopyright © 2024 aelf"
    },
    {
      "title": "Cross Chain Verification | AELF Docs",
      "url": "https://docs.aelf.com/learn/cross-chain/cross-chain-verification/",
      "html": "Skip to main content\nQuick Start\nLearn\nDocs\nTools\nResources\nBlog\nSearch\nUnderstanding aelf\nCore\nCross Chain\nIntroduction\nArchitecture\nCross Chain Verification\nVerify\nCross Chain Transfer\nConsensus\nNetwork\nBoot Sequence\nAddresses\nTransactions\nSmart Contract\nACS\nTutorials\nNode Operator\nUnderstanding aelfCross ChainCross Chain Verification\nCross Chain Verification\n\nVerification is the key feature that enables side chains. Because side chains do not have direct knowledge about other side chains, they need a way to verify information from other chains. Side chains need the ability to verify that a transaction was included in another side chain's block.\n\nIndexing​\nThe role of the main chain node is to index all the side chains' blocks.\nThis way, it knows exactly the current state of all the side chains.\nSide chains also index main chain blocks, which is how they gain knowledge about the inclusion of transactions in other chains.\nIndexing is a continuous process:\nThe main chain permanently gathers information from the side chains.\nThe side chains permanently gather information from the main chain.\nWhen a side chain wants to verify a transaction from another side chain, it must wait until the correct main chain block has been indexed.\nMerkle Tree​\nA Merkle tree is a basic binary tree structure.\nFor cross-chain in aelf, the leaf value is the hash from transaction data.\nThe node value (which is not a leaf node) is the hash calculated from its children's values up to the tree root.\n\nMerkle Root​\nWhen a transaction is included in a side chain's block, the block will also include a Merkle root of the transactions in this block.\nThis root is local to this side chain's blockchain and, by itself, of little value to other side chains because they follow a different protocol.\nCommunication between side chains goes through the main chain in the form of a Merkle path.\nDuring the indexing process, the main chain calculates the root with the data from side chains, and side chains in turn get the root in future indexing.\nThis root is used for the final check in cross-chain transaction verification.\nMerkle Path​\nA Merkle path is the node collection for one leaf node to calculate to the root.\nA correct Merkle path is necessary to complete any work related to cross-chain verification.\nFor the transaction tx from chain A:\nYou need the whole Merkle path root for tx to calculate the final root if you want to verify the existence of this transaction on other chains.\nVerify the root by checking whether it is equal to the one obtained from indexing before.\n\nPrevious\nArchitecture\nNext\nVerify\nIndexing\nMerkle Tree\nMerkle Root\nMerkle Path\nPlatform\nTechnology\nAudit Report\nPrivacy\nTerms of Use\nCookie Policy\nDeveloper Resources\nQuick Start\nLearn\nDocs\nTools\nResources\nEcosystem\nOverview\ndApps\naelf Ventures\nBlog\nConnect\nContact Us\nCopyright © 2024 aelf"
    },
    {
      "title": "Architecture | AELF Docs",
      "url": "https://docs.aelf.com/learn/cross-chain/architecture/",
      "html": "Skip to main content\nQuick Start\nLearn\nDocs\nTools\nResources\nBlog\nSearch\nK\nUnderstanding aelf\nCore\nCross Chain\nIntroduction\nArchitecture\nCross Chain Verification\nVerify\nCross Chain Transfer\nConsensus\nNetwork\nBoot Sequence\nAddresses\nTransactions\nSmart Contract\nACS\nTutorials\nNode Operator\nUnderstanding aelfCross ChainArchitecture\nSide Chain and Main Chain Node Documentation\nOverview​\n\nConceptually, a side chain node and a main chain node are similar. Both are independent blockchains with their own peer-to-peer networks and possibly their own ecosystems. This setup can be implemented at multiple levels. In terms of peer-to-peer networks, all side chains operate in parallel to each other but are linked to a main chain node through a cross-chain communication mechanism.\n\nThrough this link, messages are exchanged, and indexing is performed to ensure that transactions from the main chain or other side chains are verifiable in the side chain. Implementers can use aelf libraries and frameworks to build these chains.\n\nKey Role of the Main Chain:\n\nThe main chain's primary purpose is to index the side chains.\nOnly the main chain indexes data about all the side chains.\nSide chains are independent and do not have knowledge about each other.\nWhen side chains need to verify transactions from other chains, they use the main chain as a bridge to provide cross-chain verification information.\nNode Level Architecture​\n\nIn the current architecture, both the side chain node and the main chain node have one server and exactly one client. This forms the basis for aelf's two-way communication between the main chain and side chains. Both the server and the client are implemented as node plugins (a node has a collection of plugins). Interaction (listening and requesting) can start once both nodes are running.\n\nThe diagram above illustrates two nodes run by an entity: one main chain node and one side chain node. Note that the nodes don't have to be in the same physical location.\n\nSide Chain Lifetime​\n\nThe lifetime of a side chain involves the following steps:\n\nRequest side chain creation.\nWait for acceptance on the main chain.\nStart and initialize the side chain. It will be indexed by the main chain automatically.\nCross-chain verification is allowed only if the side chain is indexed correctly.\nCommunication​\n\nWhen the side chain node starts, it will initiate various communications. Here are the main points of the protocol:\n\nInitial Request: When the side chain node starts for the first time, it will request the main chain node for a chain initialization context.\nHandshake: After initialization, the side chain is launched and will perform a handshake with the main chain node to signal that it is ready to be indexed.\nIndexing Process: During indexing, information about irreversible blocks will be exchanged between the side chain and the main chain. The main chain will write the final result in a block, which is calculated using the cross-chain data from all side chains. The side chain will also record the data in a contract from the main chain.\n\naelf provides cross-chain communication implementation using gRPC.\n\nrpc RequestIndexingFromParentChain (CrossChainRequest) returns (stream acs7.ParentChainBlockData) {}\n\nrpc RequestIndexingFromSideChain (CrossChainRequest) returns (stream acs7.SideChainBlockData) {}\n\nCache​\n\nFor effective indexing, a cache layer is used to store cross-chain data received from remote nodes, ensuring the data is available and correct. The cross-chain data is cached by chain ID and block height with a count limit. The cache layer provides the data if it is cached when the node needs it, thus decoupling the communication part and node running logic.\n\nCross-Chain Contract​\n\nApart from the data in blocks, most cross-chain data will be stored by the cross-chain contract. Cross-chain data cached by the node is packed into transactions during the mining process, and the calculated result is stored by the contract. The cross-chain data in the block is the result of side chain indexing calculations from this contract. Cross-chain verification can only work correctly with data from this contract.\n\nData Flow​\n\nConceptually, the node operates as described in the following diagram. The main/side chain node receives cross-chain data from the other side and stores it in local memory. The indexing transaction is packed by the miner, and the cross-chain data is written into the State through the Crosschain Contract.\n\nPrevious\nIntroduction\nNext\nCross Chain Verification\nOverview\nNode Level Architecture\nSide Chain Lifetime\nCommunication\nCache\nCross-Chain Contract\nData Flow\nPlatform\nTechnology\nAudit Report\nPrivacy\nTerms of Use\nCookie Policy\nDeveloper Resources\nQuick Start\nLearn\nDocs\nTools\nResources\nEcosystem\nOverview\ndApps\naelf Ventures\nBlog\nConnect\nContact Us\nCopyright © 2024 aelf"
    },
    {
      "title": "AELF Docs",
      "url": "https://docs.aelf.com/learn/cross-chain/introduction/",
      "html": "Skip to main content\nQuick Start\nLearn\nDocs\nTools\nResources\nBlog\nSearch\nUnderstanding aelf\nCore\nCross Chain\nIntroduction\nArchitecture\nCross Chain Verification\nVerify\nCross Chain Transfer\nConsensus\nNetwork\nBoot Sequence\nAddresses\nTransactions\nSmart Contract\nACS\nTutorials\nNode Operator\nUnderstanding aelfCross ChainIntroduction\nIntroduction\n\nOne of the major issues with current blockchain systems is scalability. This is mainly due to congestion problems in existing blockchains. The core problem is that when a single chain needs to sequentially order and process transactions, a popular dApp consuming a lot of resources can negatively impact other dApps.\n\nTo address this issue, aelf introduced side chains in its initial design. The concept is that each side-chain handles one or more similar business scenarios, distributing different tasks across multiple chains to improve overall processing efficiency.\n\nKey Points:​\nIndependent and Specialized: Side-chains are designed to be independent and specialized, ensuring that the dApps running on them perform efficiently and smoothly.\nNetwork Link: There is a network link between the main-chain node and side-chain nodes, with communication indirectly facilitated through a Merkle root.\n\nThe diagram above illustrates the conceptual idea behind side chains.\n\nSide chains are isolated but still need a way to interact with each other. To enable cross-chain verification scenarios, aelf introduces a communication mechanism through Merkle roots and indexing.\n\nOverview​\n\nThe following sections of this documentation will provide:\n\nAn overview of the architecture of aelf's side chains.\nA guide explaining how to set up a main-chain and a side chain node.\nPrevious\nCross Chain\nNext\nArchitecture\nKey Points:\nOverview\nPlatform\nTechnology\nAudit Report\nPrivacy\nTerms of Use\nCookie Policy\nDeveloper Resources\nQuick Start\nLearn\nDocs\nTools\nResources\nEcosystem\nOverview\ndApps\naelf Ventures\nBlog\nConnect\nContact Us\nCopyright © 2024 aelf"
    },
    {
      "title": "Core Implementation | AELF Docs",
      "url": "https://docs.aelf.com/learn/core/implementation/",
      "html": "Skip to main content\nQuick Start\nLearn\nDocs\nTools\nResources\nBlog\nSearch\nUnderstanding aelf\nCore\nCore Introduction\nCore Implementation\nCross Chain\nConsensus\nNetwork\nBoot Sequence\nAddresses\nTransactions\nSmart Contract\nACS\nTutorials\nNode Operator\nUnderstanding aelfCoreCore Implementation\nDesign Principles\n\nThe diagram above shows the conceptual structure of the node and the separation between the OS and Kernel.\n\nOS​\n\nThe OS layer implements the application and infrastructure layers for the network. It also handles high-level network events and jobs, such as synchronizing the chain in response to a block announcement. Additionally, the OS layer includes the RPC implementation for the exposed API.\n\nKernel​\n\nThe Kernel contains smart contract execution primitives and definitions. It also defines the components necessary for accessing the blockchain's data. Various managers use the storage layer to access the underlying database.\n\nThe Kernel also introduces the concept of plugins. The diagram shows that side chain modules are implemented as plugins.\n\nStructure of the Project​\n\nTo understand aelf's structure, this section provides an overview of the solution.\n\nConceptually, aelf is built on two main layers: OS and Kernel.\n\nOS Layer:\nContains high-level definitions for a node and endpoints like RPC and P2P.\nKernel Layer:\nContains logic and definitions for smart contracts and consensus.\n\naelf has a native runtime for smart contracts implemented in C#, for contracts written in C#. This implementation is found in the AElf.Runtime.CSharp. projects.\n\nA significant part of aelf is the side chain framework. It is mainly implemented in the AElf.CrossChain namespace, defining the main abstractions in the core project and an implementation with gRPC in the AElf.Crosschain.Grpc project.\n\nThe AElf.Test solution folder contains all the tests. Ensuring maximum coverage of the main functional aspects is crucial for maintaining the quality of our system.\n\nOther projects implement libraries we use, like the crypto library, and others for infrastructure, like the database library. While not as critical, they are still worth exploring.\n\nJobs and Event Handlers​\n\nEvent handlers implement the logic that reacts to external and internal events. They represent the higher levels of the application, being called by the framework in a domain-agnostic manner. Event handlers, primarily using other services, influence the state of the chain.\n\nModules​\n\nOur architecture is based on modules that are wired together at runtime. Any new module must inherit from AElfModule.\n\nTo implement a new module, follow these steps:\n\nWrite the event handler or the job.\nImplement the interface and create a manager or infrastructure layer interface if needed.\nImplement the infrastructure layer interface in the same project if no additional dependencies are required.\nImplement the infrastructure layer interface in another project if it requires third-party dependencies (e.g., adding gRPC, MongoDB, or MySQL in the new project).\n\nExample: The P2P network module.\n\nThe networking code is defined across two modules: CoreOSAElfModule and GrpcNetworkModule. The OS core defines and implements the application service (used by other components of the node) as it is part of the application/domain logic. The infrastructure layer (like the server endpoint) is defined in the OS core modules but implemented in another project that relies on a third party, such as gRPC.\n\nTesting​\n\nWhen writing a new component, event handler, or method, it is important for aelf's quality to consider the corresponding unit test. As previously mentioned, we have a solution-wide test folder where we place all the tests.\n\nPrevious\nCore Introduction\nNext\nCross Chain\nOS\nKernel\nStructure of the Project\nJobs and Event Handlers\nModules\nTesting\nPlatform\nTechnology\nAudit Report\nPrivacy\nTerms of Use\nCookie Policy\nDeveloper Resources\nQuick Start\nLearn\nDocs\nTools\nResources\nEcosystem\nOverview\ndApps\naelf Ventures\nBlog\nConnect\nContact Us\nCopyright © 2024 aelf"
    },
    {
      "title": "Parliament Contract | AELF Docs",
      "url": "https://docs.aelf.com/docs/smart-contract-api/parliament-contract/",
      "html": "Skip to main content\nQuick Start\nLearn\nDocs\nTools\nResources\nBlog\nSearch\nK\nDocs Reference\nSmart Contract API\nAssociation Contract\nReferendum Contract\nParliament Contract\nConsensus Contract\nElection Contract\nGenesis Contract\nMulti Token Contract\nProfit Contract\nCross Chain Contract\nTreasury Contract\nVote Contract\nToken Holder Contract\nEconomic Contract\nToken Converter Contract\nConfiguration Contract\nWeb API\nDocs ReferenceSmart Contract APIParliament Contract\nParliament Contract\n\nThe production nodes use the Parliament contract to govern important matters. In the initial state, the production nodes are members of the parliament, and only when two-thirds of the production nodes vote in favor of a given decision, will it be executed.\n\nImplement aelf Standards ACS1 and ACS3.\n\nContract Methods​\nMethod Name\tRequest Type\tResponse Type\tDescription\nInitialize\tParliament.InitializeInput\tgoogle.protobuf.Empty\tInitialize parliament proposer whitelist and create the first parliament organization with specific proposer_authority_required.\nCreateOrganization\tParliament.CreateOrganizationInput\taelf.Address\tCreate an organization and return its address.\nApproveMultiProposals\tParliament.ProposalIdList\tgoogle.protobuf.Empty\tBatch approval proposal.\nCreateOrganizationBySystemContract\tParliament.CreateOrganizationBySystemContractInput\taelf.Address\tCreates an organization by system contract and return its address.\nGetOrganization\taelf.Address\tParliament.Organization\tGet the organization according to the organization address.\nGetDefaultOrganizationAddress\tgoogle.protobuf.Empty\taelf.Address\tGet the default organization address.\nValidateAddressIsParliamentMember\taelf.Address\tgoogle.protobuf.BoolValue\tValidates if the provided address is a parliament member.\nGetProposerWhiteList\tgoogle.protobuf.Empty\tacs3.ProposerWhiteList\tReturns the list of whitelisted proposers.\nGetNotVotedPendingProposals\tParliament.ProposalIdList\tParliament.ProposalIdList\tFilter still pending ones not yet voted by the sender from provided proposals.\nGetNotVotedProposals\tParliament.ProposalIdList\tParliament.ProposalIdList\tFilter not yet voted ones by the sender from provided proposals.\nCalculateOrganizationAddress\tParliament.CreateOrganizationInput\taelf.Address\tCalculates with input and return the organization address.\nGetReleaseThresholdReachedProposals\tParliament.ProposalIdList\tParliament.ProposalIdList\tFilter reached release threshold proposals.\nGetAvailableProposals\tParliament.ProposalIdList\tParliament.ProposalIdList\tFilter available proposals.\nAElf.Standards.ACS1​\nMethod Name\tRequest Type\tResponse Type\tDescription\nSetMethodFee\tacs1.MethodFees\tgoogle.protobuf.Empty\tSet the method fees for the specified method. Note that this will override all fees of the method.\nChangeMethodFeeController\tAuthorityInfo\tgoogle.protobuf.Empty\tChange the method fee controller, the default is parliament and default organization.\nGetMethodFee\tgoogle.protobuf.StringValue\tacs1.MethodFees\tQuery method fee information by method name.\nGetMethodFeeController\tgoogle.protobuf.Empty\tAuthorityInfo\tQuery the method fee controller.\nAElf.Standards.ACS3​\nMethod Name\tRequest Type\tResponse Type\tDescription\nCreateProposal\tacs3.CreateProposalInput\taelf.Hash\tCreate a proposal for which organization members can vote. When the proposal is released, a transaction will be sent to the specified contract. Return id of the newly created proposal.\nApprove\taelf.Hash\tgoogle.protobuf.Empty\tApprove a proposal according to the proposal ID.\nReject\taelf.Hash\tgoogle.protobuf.Empty\tReject a proposal according to the proposal ID.\nAbstain\taelf.Hash\tgoogle.protobuf.Empty\tAbstain a proposal according to the proposal ID.\nRelease\taelf.Hash\tgoogle.protobuf.Empty\tRelease a proposal according to the proposal ID and send a transaction to the specified contract.\nChangeOrganizationThreshold\tacs3.ProposalReleaseThreshold\tgoogle.protobuf.Empty\tChange the thresholds associated with proposals. All fields will be overwritten by the input value and this will affect all current proposals of the organization. Note: only the organization can execute this through a proposal.\nChangeOrganizationProposerWhiteList\tacs3.ProposerWhiteList\tgoogle.protobuf.Empty\tChange the white list of organization proposer. This method overrides the list of whitelisted proposers.\nCreateProposalBySystemContract\tacs3.CreateProposalBySystemContractInput\taelf.Hash\tCreate a proposal by system contracts, and return id of the newly created proposal.\nClearProposal\taelf.Hash\tgoogle.protobuf.Empty\tRemove the specified proposal. If the proposal is in effect, the cleanup fails.\nGetProposal\taelf.Hash\tacs3.ProposalOutput\tGet the proposal according to the proposal ID.\nValidateOrganizationExist\taelf.Address\tgoogle.protobuf.BoolValue\tCheck the existence of an organization.\nValidateProposerInWhiteList\tacs3.ValidateProposerInWhiteListInput\tgoogle.protobuf.BoolValue\tCheck if the proposer is whitelisted.\nContract Types​\nAElf.Contracts.Parliament​\nParliament.CreateOrganizationBySystemContractInput​\nField\tType\tDescription\tLabel\norganization_creation_input\tCreateOrganizationInput\tThe parameters of creating organization.\t\norganization_address_feedback_method\tstring\tThe organization address callback method which replies the organization address to caller contract.\t\nParliament.CreateOrganizationInput​\nField\tType\tDescription\tLabel\nproposal_release_threshold\tacs3.ProposalReleaseThreshold\tThe threshold for releasing the proposal.\t\nproposer_authority_required\tbool\tSetting this to true can allow anyone to create proposals.\t\nparliament_member_proposing_allowed\tbool\tSetting this to true can allow parliament member to create proposals.\t\ncreation_token\taelf.Hash\tThe creation token is for organization address generation.\t\nParliament.InitializeInput​\nField\tType\tDescription\tLabel\nprivileged_proposer\taelf.Address\tPrivileged proposer would be the first address in parliament proposer whitelist.\t\nproposer_authority_required\tbool\tThe setting indicates if proposals need authority to be created for first/default parliament organization.\t\nParliament.Organization​\nField\tType\tDescription\tLabel\nproposer_authority_required\tbool\tIndicates if proposals need authority to be created.\t\norganization_address\taelf.Address\tThe organization address.\t\norganization_hash\taelf.Hash\tThe organization id.\t\nproposal_release_threshold\tacs3.ProposalReleaseThreshold\tThe threshold for releasing the proposal.\t\nparliament_member_proposing_allowed\tbool\tIndicates if parliament member can propose to this organization.\t\ncreation_token\taelf.Hash\tThe creation token is for organization address generation.\t\nParliament.ProposalIdList​\nField\tType\tDescription\tLabel\nproposal_ids\taelf.Hash\tThe list of proposal ids.\trepeated\nParliament.ProposalInfo​\nField\tType\tDescription\tLabel\nproposal_id\taelf.Hash\tThe proposal ID.\t\ncontract_method_name\tstring\tThe method that this proposal will call when being released.\t\nto_address\taelf.Address\tThe address of the target contract.\t\nparams\tbytes\tThe parameters of the release transaction.\t\nexpired_time\tgoogle.protobuf.Timestamp\tThe date at which this proposal will expire.\t\nproposer\taelf.Address\tThe address of the proposer of this proposal.\t\norganization_address\taelf.Address\tThe address of this proposals organization.\t\napprovals\taelf.Address\tAddress list of approved.\trepeated\nrejections\taelf.Address\tAddress list of rejected.\trepeated\nabstentions\taelf.Address\tAddress list of abstained.\trepeated\nproposal_description_url\tstring\tUrl is used for proposal describing.\t\nAElf.Standards.ACS1​\nacs1.MethodFee​\nField\tType\tDescription\tLabel\nsymbol\tstring\tThe token symbol of the method fee.\t\nbasic_fee\tint64\tThe amount of fees to be charged.\t\nacs1.MethodFees​\nField\tType\tDescription\tLabel\nmethod_name\tstring\tThe name of the method to be charged.\t\nfees\tMethodFee\tList of fees to be charged.\trepeated\nis_size_fee_free\tbool\tOptional based on the implementation of SetMethodFee method.\t\nAElf.Standards.ACS3​\nacs3.CreateProposalBySystemContractInput​\nField\tType\tDescription\tLabel\nproposal_input\tCreateProposalInput\tThe parameters of creating proposal.\t\norigin_proposer\taelf.Address\tThe actor that triggers the call.\t\nacs3.CreateProposalInput​\nField\tType\tDescription\tLabel\ncontract_method_name\tstring\tThe name of the method to call after release.\t\nto_address\taelf.Address\tThe address of the contract to call after release.\t\nparams\tbytes\tThe parameters of the method to be called after the release.\t\nexpired_time\tgoogle.protobuf.Timestamp\tThe timestamp at which this proposal will expire.\t\norganization_address\taelf.Address\tThe address of the organization.\t\nproposal_description_url\tstring\tURL used for proposal description.\t\ntoken\taelf.Hash\tThe token for proposal ID generation and calculation.\t\nacs3.OrganizationCreated​\nField\tType\tDescription\tLabel\norganization_address\taelf.Address\tThe address of the created organization.\t\nacs3.OrganizationHashAddressPair​\nField\tType\tDescription\tLabel\norganization_hash\taelf.Hash\tThe ID of the organization.\t\norganization_address\taelf.Address\tThe address of the organization.\t\nacs3.OrganizationThresholdChanged​\nField\tType\tDescription\tLabel\norganization_address\taelf.Address\tThe organization address\t\nproposer_release_threshold\tProposalReleaseThreshold\tThe new release threshold.\t\nacs3.OrganizationWhiteListChanged​\nField\tType\tDescription\tLabel\norganization_address\taelf.Address\tThe organization address.\t\nproposer_white_list\tProposerWhiteList\tThe new proposer whitelist.\t\nacs3.ProposalCreated​\nField\tType\tDescription\tLabel\nproposal_id\taelf.Hash\tThe id of the created proposal.\t\norganization_address\taelf.Address\tThe organization address of the created proposal.\t\nacs3.ProposalOutput​\nField\tType\tDescription\tLabel\nproposal_id\taelf.Hash\tThe id of the proposal.\t\ncontract_method_name\tstring\tThe method that this proposal will call when being released.\t\nto_address\taelf.Address\tThe address of the target contract.\t\nparams\tbytes\tThe parameters of the release transaction.\t\nexpired_time\tgoogle.protobuf.Timestamp\tThe date at which this proposal will expire.\t\norganization_address\taelf.Address\tThe address of this proposals organization.\t\nproposer\taelf.Address\tThe address of the proposer of this proposal.\t\nto_be_released\tbool\tIndicates if this proposal is releasable.\t\napproval_count\tint64\tApproval count for this proposal.\t\nrejection_count\tint64\tRejection count for this proposal.\t\nabstention_count\tint64\tAbstention count for this proposal.\t\nacs3.ProposalReleaseThreshold​\nField\tType\tDescription\tLabel\nminimal_approval_threshold\tint64\tThe value for the minimum approval threshold.\t\nmaximal_rejection_threshold\tint64\tThe value for the maximal rejection threshold.\t\nmaximal_abstention_threshold\tint64\tThe value for the maximal abstention threshold.\t\nminimal_vote_threshold\tint64\tThe value for the minimal vote threshold.\t\nacs3.ProposalReleased​\nField\tType\tDescription\tLabel\nproposal_id\taelf.Hash\tThe id of the released proposal.\t\norganization_address\taelf.Address\tThe organization address of the released proposal.\t\nacs3.ProposerWhiteList​\nField\tType\tDescription\tLabel\nproposers\taelf.Address\tThe address of the proposers\trepeated\nacs3.ReceiptCreated​\nField\tType\tDescription\tLabel\nproposal_id\taelf.Hash\tThe id of the proposal.\t\naddress\taelf.Address\tThe sender address.\t\nreceipt_type\tstring\tThe type of receipt\t\ntime\tgoogle.protobuf.Timestamp\tThe timestamp of this method call.\t\norganization_address\taelf.Address\tThe address of the organization.\t\nacs3.ValidateProposerInWhiteListInput​\nField\tType\tDescription\tLabel\nproposer\taelf.Address\tThe address to search/check.\t\norganization_address\taelf.Address\tThe address of the organization.\t\nAElf.Types​\naelf.Address​\nField\tType\tDescription\tLabel\nvalue\tbytes\t\t\naelf.BinaryMerkleTree​\nField\tType\tDescription\tLabel\nnodes\tHash\tThe leaf nodes.\trepeated\nroot\tHash\tThe root node hash.\t\nleaf_count\tint32\tThe count of leaf node.\t\naelf.Hash​\nField\tType\tDescription\tLabel\nvalue\tbytes\t\t\naelf.LogEvent​\nField\tType\tDescription\tLabel\naddress\tAddress\tThe contract address.\t\nname\tstring\tThe name of the log event.\t\nindexed\tbytes\tThe indexed data, used to calculate bloom.\trepeated\nnon_indexed\tbytes\tThe non indexed data.\t\naelf.MerklePath​\nField\tType\tDescription\tLabel\nmerkle_path_nodes\tMerklePathNode\tThe merkle path nodes.\trepeated\naelf.MerklePathNode​\nField\tType\tDescription\tLabel\nhash\tHash\tThe node hash.\t\nis_left_child_node\tbool\tWhether it is a left child node.\t\naelf.SInt32Value​\nField\tType\tDescription\tLabel\nvalue\tsint32\t\t\naelf.SInt64Value​\nField\tType\tDescription\tLabel\nvalue\tsint64\t\t\naelf.ScopedStatePath​\nField\tType\tDescription\tLabel\naddress\tAddress\tThe scope address, which will be the contract address.\t\npath\tStatePath\tThe path of contract state.\t\naelf.SmartContractRegistration​\nField\tType\tDescription\tLabel\ncategory\tsint32\tThe category of contract code(0: C#).\t\ncode\tbytes\tThe byte array of the contract code.\t\ncode_hash\tHash\tThe hash of the contract code.\t\nis_system_contract\tbool\tWhether it is a system contract.\t\nversion\tint32\tThe version of the current contract.\t\naelf.StatePath​\nField\tType\tDescription\tLabel\nparts\tstring\tThe partial path of the state path.\trepeated\naelf.Transaction​\nField\tType\tDescription\tLabel\nfrom\tAddress\tThe address of the sender of the transaction.\t\nto\tAddress\tThe address of the contract when calling a contract.\t\nref_block_number\tint64\tThe height of the referenced block hash.\t\nref_block_prefix\tbytes\tThe first four bytes of the referenced block hash.\t\nmethod_name\tstring\tThe name of a method in the smart contract at the To address.\t\nparams\tbytes\tThe parameters to pass to the smart contract method.\t\nsignature\tbytes\tWhen signing a transaction it's actually a subset of the fields: from/to and the target method as well as the parameter that were given. It also contains the reference block number and prefix.\t\naelf.TransactionExecutingStateSet​\nField\tType\tDescription\tLabel\nwrites\tTransactionExecutingStateSet.WritesEntry\tThe changed states.\trepeated\nreads\tTransactionExecutingStateSet.ReadsEntry\tThe read states.\trepeated\ndeletes\tTransactionExecutingStateSet.DeletesEntry\tThe deleted states.\trepeated\naelf.TransactionExecutingStateSet.DeletesEntry​\nField\tType\tDescription\tLabel\nkey\tstring\t\t\nvalue\tbool\t\t\naelf.TransactionExecutingStateSet.ReadsEntry​\nField\tType\tDescription\tLabel\nkey\tstring\t\t\nvalue\tbool\t\t\naelf.TransactionExecutingStateSet.WritesEntry​\nField\tType\tDescription\tLabel\nkey\tstring\t\t\nvalue\tbytes\t\t\naelf.TransactionResult​\nField\tType\tDescription\tLabel\ntransaction_id\tHash\tThe transaction id.\t\nstatus\tTransactionResultStatus\tThe transaction result status.\t\nlogs\tLogEvent\tThe log events.\trepeated\nbloom\tbytes\tBloom filter for transaction logs. A transaction log event can be defined in the contract and stored in the bloom filter after the transaction is executed. Through this filter, we can quickly search for and determine whether a log exists in the transaction result.\t\nreturn_value\tbytes\tThe return value of the transaction execution.\t\nblock_number\tint64\tThe height of the block hat packages the transaction.\t\nblock_hash\tHash\tThe hash of the block hat packages the transaction.\t\nerror\tstring\tFailed execution error message.\t\naelf.TransactionResultStatus​\nName\tNumber\tDescription\nNOT_EXISTED\t0\tThe execution result of the transaction does not exist.\nPENDING\t1\tThe transaction is in the transaction pool waiting to be packaged.\nFAILED\t2\tTransaction execution failed.\nMINED\t3\tThe transaction was successfully executed and successfully packaged into a block.\nCONFLICT\t4\tWhen executed in parallel, there are conflicts with other transactions.\nPENDING_VALIDATION\t5\tThe transaction is waiting for validation.\nNODE_VALIDATION_FAILED\t6\tTransaction validation failed.\nAuthorityInfo​\nField\tType\tDescription\tLabel\ncontract_address\taelf.Address\tThe contract address of the controller.\t\nowner_address\taelf.Address\tThe address of the owner of the contract.\t\nPrevious\nReferendum Contract\nNext\nConsensus Contract\nContract Methods\nAElf.Standards.ACS1\nAElf.Standards.ACS3\nContract Types\nAElf.Contracts.Parliament\nParliament.CreateOrganizationBySystemContractInput\nParliament.CreateOrganizationInput\nParliament.InitializeInput\nParliament.Organization\nParliament.ProposalIdList\nParliament.ProposalInfo\nAElf.Standards.ACS1\nacs1.MethodFee\nacs1.MethodFees\nAElf.Standards.ACS3\nacs3.CreateProposalBySystemContractInput\nacs3.CreateProposalInput\nacs3.OrganizationCreated\nacs3.OrganizationHashAddressPair\nacs3.OrganizationThresholdChanged\nacs3.OrganizationWhiteListChanged\nacs3.ProposalCreated\nacs3.ProposalOutput\nacs3.ProposalReleaseThreshold\nacs3.ProposalReleased\nacs3.ProposerWhiteList\nacs3.ReceiptCreated\nacs3.ValidateProposerInWhiteListInput\nAElf.Types\naelf.Address\naelf.BinaryMerkleTree\naelf.Hash\naelf.LogEvent\naelf.MerklePath\naelf.MerklePathNode\naelf.SInt32Value\naelf.SInt64Value\naelf.ScopedStatePath\naelf.SmartContractRegistration\naelf.StatePath\naelf.Transaction\naelf.TransactionExecutingStateSet\naelf.TransactionExecutingStateSet.DeletesEntry\naelf.TransactionExecutingStateSet.ReadsEntry\naelf.TransactionExecutingStateSet.WritesEntry\naelf.TransactionResult\naelf.TransactionResultStatus\nAuthorityInfo\nPlatform\nTechnology\nAudit Report\nPrivacy\nTerms of Use\nCookie Policy\nDeveloper Resources\nQuick Start\nLearn\nDocs\nTools\nResources\nEcosystem\nOverview\ndApps\naelf Ventures\nBlog\nConnect\nContact Us\nCopyright © 2024 aelf"
    },
    {
      "title": "AELF Docs",
      "url": "https://docs.aelf.com/learn/core/introduction/",
      "html": "Skip to main content\nQuick Start\nLearn\nDocs\nTools\nResources\nBlog\nSearch\nUnderstanding aelf\nCore\nCore Introduction\nCore Implementation\nCross Chain\nConsensus\nNetwork\nBoot Sequence\nAddresses\nTransactions\nSmart Contract\nACS\nTutorials\nNode Operator\nUnderstanding aelfCoreCore Introduction\nApplication Pattern\n\nWe follow generally accepted good practices in programming, especially those that align with our project needs. Some of these practices are specific to C#, while others pertain to general Object-Oriented Programming (OOP) principles like SOLID and DRY.\n\nDomain-Driven Design (DDD)​\n\nAlthough it's uncommon for blockchain projects, we adhere to a Domain-Driven Design (DDD) approach in our development style. This approach is partly due to the compatibility of our main framework with DDD, making it a natural design philosophy for us.\n\nKey Points of DDD:​\nFour Traditional Layers:\nPresentation: This corresponds to any type of dApp (Decentralized Application).\nApplication: Exposed services mapped to different domains.\nDomain: Specific events related to our blockchain system and domain objects.\nInfrastructure: Third-party libraries for database, networking, etc.\n\nFor more details, refer to our coding standards listed in our GitHub issue.\n\nFrameworks and Libraries​\n\nThe primary programming language used for developing aelf is C#, and it's built with the dotnet core framework. This choice was made due to the excellent performance of the framework. Dotnet core is also cross-platform, supporting Windows, MacOS, and Linux. It is a dynamic and open-source framework, offering many advantages of modern development patterns and backed by major players in the IT industry.\n\nKey Frameworks and Tools:​\n\nABP Framework:\n\nWe use the ABP application framework.\nIt is a natural fit for building blockchain nodes, which are sets of endpoints like RPC, P2P, and cross-chain communication, with higher-level protocols on top.\n\nTesting:\n\nWe use the XUnit framework for unit tests.\nAdditionally, we have custom-made frameworks for testing smart contracts.\n\nCommunication:\n\nFor cross-chain and P2P network communication, we use gRPC.\nWe use Protobuf for serialization purposes.\n\nBy following these practices and utilizing these tools, we ensure that our development process is efficient, reliable, and scalable.\n\nPrevious\nCore\nNext\nCore Implementation\nDomain-Driven Design (DDD)\nKey Points of DDD:\nFrameworks and Libraries\nKey Frameworks and Tools:\nPlatform\nTechnology\nAudit Report\nPrivacy\nTerms of Use\nCookie Policy\nDeveloper Resources\nQuick Start\nLearn\nDocs\nTools\nResources\nEcosystem\nOverview\ndApps\naelf Ventures\nBlog\nConnect\nContact Us\nCopyright © 2024 aelf"
    },
    {
      "title": "AELF Docs",
      "url": "https://docs.aelf.com/docs/smart-contract-api/cross-chain-contract/",
      "html": "Skip to main content\nQuick Start\nLearn\nDocs\nTools\nResources\nBlog\nSearch\nDocs Reference\nSmart Contract API\nAssociation Contract\nReferendum Contract\nParliament Contract\nConsensus Contract\nElection Contract\nGenesis Contract\nMulti Token Contract\nProfit Contract\nCross Chain Contract\nTreasury Contract\nVote Contract\nToken Holder Contract\nEconomic Contract\nToken Converter Contract\nConfiguration Contract\nWeb API\nDocs ReferenceSmart Contract APICross Chain Contract\nCross-Chain Contract\n\nImplement aelf Standards ACS1 and ACS7.\n\nContract Methods​\nMethod Name\tRequest Type\tResponse Type\tDescription\nInitialize\tCrossChain.InitializeInput\tgoogle.protobuf.Empty\tPropose once cross chain indexing.\nSetInitialSideChainLifetimeControllerAddress\taelf.Address\tgoogle.protobuf.Empty\tSet the initial SideChainLifetimeController address which should be parliament organization by default.\nSetInitialIndexingControllerAddress\taelf.Address\tgoogle.protobuf.Empty\tSet the initial CrossChainIndexingController address which should be parliament organization by default.\nChangeCrossChainIndexingController\tAuthorityInfo\tgoogle.protobuf.Empty\tChange the cross chain indexing controller.\nChangeSideChainLifetimeController\tAuthorityInfo\tgoogle.protobuf.Empty\tChange the lifetime controller of the side chain.\nChangeSideChainIndexingFeeController\tCrossChain.ChangeSideChainIndexingFeeControllerInput\tgoogle.protobuf.Empty\tChange indexing fee adjustment controller for specific side chain.\nAcceptCrossChainIndexingProposal\tCrossChain.AcceptCrossChainIndexingProposalInput\tgoogle.protobuf.Empty\tWhen the indexing proposal is released, clean up the pending proposal.\nGetSideChainCreator\tgoogle.protobuf.Int32Value\taelf.Address\tGet the side chain creator address according to side chain id.\nGetChainStatus\tgoogle.protobuf.Int32Value\tCrossChain.GetChainStatusOutput\tGet the current status of side chain according to side chain id.\nGetSideChainHeight\tgoogle.protobuf.Int32Value\tgoogle.protobuf.Int64Value\tGet the side chain height according to side chain id.\nGetParentChainHeight\tgoogle.protobuf.Empty\tgoogle.protobuf.Int64Value\tGet the height of parent chain.\nGetParentChainId\tgoogle.protobuf.Empty\tgoogle.protobuf.Int32Value\tGet the chain id of parent chain.\nGetSideChainBalance\tgoogle.protobuf.Int32Value\tgoogle.protobuf.Int64Value\tGet the balance of side chain indexing according to side chain id.\nGetSideChainIndexingFeeDebt\tgoogle.protobuf.Int32Value\tgoogle.protobuf.Int64Value\tGet the fee debt of side chain indexing according to side chain id.\nGetIndexingProposalStatus\tgoogle.protobuf.Empty\tCrossChain.GetIndexingProposalStatusOutput\tGet the status of the current indexing proposal.\nGetSideChainIndexingFeePrice\tgoogle.protobuf.Int32Value\tgoogle.protobuf.Int64Value\tGet the side chain indexing fee price according to side chain id.\nGetSideChainLifetimeController\tgoogle.protobuf.Empty\tAuthorityInfo\tGet the lifetime controller of the side chain.\nGetCrossChainIndexingController\tgoogle.protobuf.Empty\tAuthorityInfo\tGet the cross chain indexing controller.\nGetSideChainIndexingFeeController\tgoogle.protobuf.Int32Value\tAuthorityInfo\tGet the indexing fee controller of side chain according to side chain id.\nAElf.Standards.ACS1​\nMethod Name\tRequest Type\tResponse Type\tDescription\nSetMethodFee\tacs1.MethodFees\tgoogle.protobuf.Empty\tSet the method fees for the specified method. Note that this will override all fees of the method.\nChangeMethodFeeController\tAuthorityInfo\tgoogle.protobuf.Empty\tChange the method fee controller, the default is parliament and default organization.\nGetMethodFee\tgoogle.protobuf.StringValue\tacs1.MethodFees\tQuery method fee information by method name.\nGetMethodFeeController\tgoogle.protobuf.Empty\tAuthorityInfo\tQuery the method fee controller.\nAElf.Standards.ACS7​\nMethod Name\tRequest Type\tResponse Type\tDescription\nProposeCrossChainIndexing\tacs7.CrossChainBlockData\tgoogle.protobuf.Empty\tPropose once cross chain indexing.\nReleaseCrossChainIndexingProposal\tacs7.ReleaseCrossChainIndexingProposalInput\tgoogle.protobuf.Empty\tRelease the proposed indexing if already approved.\nRequestSideChainCreation\tacs7.SideChainCreationRequest\tgoogle.protobuf.Empty\tRequest side chain creation.\nReleaseSideChainCreation\tacs7.ReleaseSideChainCreationInput\tgoogle.protobuf.Empty\tRelease the side chain creation request if already approved and it will call the method CreateSideChain.\nCreateSideChain\tacs7.CreateSideChainInput\tgoogle.protobuf.Int32Value\tCreate the side chain and returns the newly created side chain ID.\nRecharge\tacs7.RechargeInput\tgoogle.protobuf.Empty\tRecharge for the specified side chain.\nDisposeSideChain\tgoogle.protobuf.Int32Value\tgoogle.protobuf.Int32Value\tDispose a side chain according to side chain id.\nAdjustIndexingFeePrice\tacs7.AdjustIndexingFeeInput\tgoogle.protobuf.Empty\tAdjust side chain indexing fee.\nVerifyTransaction\tacs7.VerifyTransactionInput\tgoogle.protobuf.BoolValue\tVerify cross chain transaction.\nGetSideChainIdAndHeight\tgoogle.protobuf.Empty\tacs7.ChainIdAndHeightDict\tGets all the side chain id and height of the current chain.\nGetSideChainIndexingInformationList\tgoogle.protobuf.Empty\tacs7.SideChainIndexingInformationList\tGet indexing information of side chains.\nGetAllChainsIdAndHeight\tgoogle.protobuf.Empty\tacs7.ChainIdAndHeightDict\tGet id and recorded height of all chains.\nGetIndexedSideChainBlockDataByHeight\tgoogle.protobuf.Int64Value\tacs7.IndexedSideChainBlockData\tGet block data of indexed side chain according to height.\nGetBoundParentChainHeightAndMerklePathByHeight\tgoogle.protobuf.Int64Value\tacs7.CrossChainMerkleProofContext\tGet merkle path bound up with side chain according to height.\nGetChainInitializationData\tgoogle.protobuf.Int32Value\tacs7.ChainInitializationData\tGet initialization data for specified side chain.\n\nContract Types\n\nAElf.Contracts.CrossChain​\nCrossChain.AcceptCrossChainIndexingProposalInput​\nField\tType\tDescription\tLabel\nchain_id\tint32\tThe chain id of accepted indexing.\t\nCrossChain.ChainIndexingProposal​\nField\tType\tDescription\tLabel\nproposal_id\taelf.Hash\tThe id of cross chain indexing proposal.\t\nproposer\taelf.Address\tThe proposer of cross chain indexing.\t\nproposed_cross_chain_block_data\tacs7.CrossChainBlockData\tThe cross chain data proposed.\t\nstatus\tCrossChainIndexingProposalStatus\tThe status of cross chain indexing proposal.\t\nchain_id\tint32\tThe chain id of the indexing.\t\nCrossChain.ChangeSideChainIndexingFeeControllerInput​\nField\tType\tDescription\tLabel\nchain_id\tint32\tThe side chain id.\t\nauthority_info\tAuthorityInfo\tThe changed controller of indexing fee.\t\nCrossChain.CrossChainIndexingControllerChanged​\nField\tType\tDescription\tLabel\nauthority_info\tAuthorityInfo\tThe changed controller of indexing.\t\nCrossChain.Disposed​\nField\tType\tDescription\tLabel\nchain_id\tint32\tThe disposed side chain id.\t\nCrossChain.GetChainStatusOutput​\nField\tType\tDescription\tLabel\nstatus\tSideChainStatus\tThe status of side chain.\t\nCrossChain.GetIndexingProposalStatusOutput​\nField\tType\tDescription\tLabel\nchain_indexing_proposal_status\tGetIndexingProposalStatusOutput.ChainIndexingProposalStatusEntry\tThe collection of pending indexing proposal, the key is chain id.\trepeated\nCrossChain.GetIndexingProposalStatusOutput.ChainIndexingProposalStatusEntry​\nField\tType\tDescription\tLabel\nkey\tint32\t\t\nvalue\tPendingChainIndexingProposalStatus\t\t\nCrossChain.GetPendingCrossChainIndexingProposalOutput​\nField\tType\tDescription\tLabel\nproposal_id\taelf.Hash\tThe proposal id of cross chain indexing.\t\nproposer\taelf.Address\tThe proposer of cross chain indexing proposal.\t\nto_be_released\tbool\tTrue if the proposal can be released, otherwise false.\t\nproposed_cross_chain_block_data\tacs7.CrossChainBlockData\tThe cross chain data proposed.\t\nexpired_time\tgoogle.protobuf.Timestamp\tThe proposal expiration time.\t\nCrossChain.InitializeInput​\nField\tType\tDescription\tLabel\nparent_chain_id\tint32\tThe id of parent chain.\t\ncreation_height_on_parent_chain\tint64\tThe height of side chain created on parent chain.\t\nis_privilege_preserved\tbool\tTrue if chain privilege needed, otherwise false.\t\nCrossChain.ParentChainIndexed​\nField\tType\tDescription\tLabel\nchain_id\tbytes\tIndexed parent chain id.\t\nindexed_height\tint64\tIndexed block height.\t\nCrossChain.PendingChainIndexingProposalStatus​\nField\tType\tDescription\tLabel\nproposal_id\taelf.Hash\tThe id of cross chain indexing proposal.\t\nproposer\taelf.Address\tThe proposer of cross chain indexing.\t\nto_be_released\tbool\tTrue if the proposal can be released, otherwise false.\t\nproposed_cross_chain_block_data\tacs7.CrossChainBlockData\tThe cross chain data proposed.\t\nexpired_time\tgoogle.protobuf.Timestamp\tThe proposal expiration time.\t\nCrossChain.ProposedCrossChainIndexing​\nField\tType\tDescription\tLabel\nchain_indexing_proposal_collections\tProposedCrossChainIndexing.ChainIndexingProposalCollectionsEntry\tThe collection of chain indexing proposal, the key is chain id.\trepeated\nCrossChain.ProposedCrossChainIndexing.ChainIndexingProposalCollectionsEntry​\nField\tType\tDescription\tLabel\nkey\tint32\t\t\nvalue\tChainIndexingProposal\t\t\nCrossChain.SideChainCreatedEvent​\nField\tType\tDescription\tLabel\ncreator\taelf.Address\tThe proposer who propose to create the side chain.\t\nchainId\tint32\tThe created side chain id.\t\nCrossChain.SideChainCreationRequestState​\nField\tType\tDescription\tLabel\nside_chain_creation_request\tacs7.SideChainCreationRequest\tThe parameters of creating side chain.\t\nexpired_time\tgoogle.protobuf.Timestamp\tThe expiration date of the proposal.\t\nproposer\taelf.Address\tThe proposer who proposed to create the side chain.\t\nCrossChain.SideChainIndexed​\nField\tType\tDescription\tLabel\nchain_id\tbytes\tIndexed side chain id.\t\nindexed_height\tint64\tIndexed block height.\t\nCrossChain.SideChainIndexingFeeControllerChanged​\nField\tType\tDescription\tLabel\nchain_id\tint32\tThe side chain id.\t\nauthority_info\tAuthorityInfo\tThe changed controller of side chain indexing fee.\t\nCrossChain.SideChainInfo​\nField\tType\tDescription\tLabel\nproposer\taelf.Address\tThe proposer who propose to create the side chain.\t\nside_chain_status\tCrossChain.SideChainStatus\tThe status of side chain.\t\nside_chain_id\tint32\tThe side chain id.\t\ncreation_timestamp\tgoogle.protobuf.Timestamp\tThe time of side chain created.\t\ncreation_height_on_parent_chain\tint64\tThe height of side chain created on parent chain.\t\nindexing_price\tint64\tThe price of indexing fee.\t\nis_privilege_preserved\tbool\tTrue if chain privilege needed, otherwise false.\t\narrears_info\tCrossChain.SideChainInfo.ArrearsInfoEntry\tCreditor and amounts for the chain indexing fee debt\trepeated\nindexing_fee_controller\tAuthorityInfo\tThe controller of indexing fee.\t\nCrossChain.SideChainInfo.ArrearsInfoEntry​\nField\tType\tDescription\tLabel\nkey\tstring\t\t\nvalue\tint64\t\t\nCrossChain.SideChainLifetimeControllerChanged​\nField\tType\tDescription\tLabel\nauthority_info\tAuthorityInfo\tThe changed controller of side chain lifetime.\t\nCrossChain.CrossChainIndexingProposalStatus​\nName\tNumber\tDescription\nNON_PROPOSED\t0\t\nPENDING\t1\tThe proposal is pending.\nACCEPTED\t2\tThe proposal has been released.\nCrossChain.SideChainStatus​\nName\tNumber\tDescription\nFATAL\t0\tCurrently no meaning.\nACTIVE\t1\tThe side chain is being indexed.\nINDEXING_FEE_DEBT\t2\tThe side chain is in debt for indexing fee.\nTERMINATED\t3\tThe side chain is disposed.\nAElf.Standards.ACS1​\nacs1.MethodFee​\nField\tType\tDescription\tLabel\nsymbol\tstring\tThe token symbol of the method fee.\t\nbasic_fee\tint64\tThe amount of fees to be charged.\t\nacs1.MethodFees​\nField\tType\tDescription\tLabel\nmethod_name\tstring\tThe name of the method to be charged.\t\nfees\tacs1.MethodFee\tList of fees to be charged.\trepeated\nis_size_fee_free\tbool\tOptional based on the implementation of SetMethodFee method.\t\nAElf.Standards.ACS7​\nacs7.AdjustIndexingFeeInput​\nField\tType\tDescription\tLabel\nside_chain_id\tint32\tThe side chain id to adjust.\t\nindexing_fee\tint64\tThe new price of indexing fee.\t\nacs7.ChainIdAndHeightDict​\nField\tType\tDescription\tLabel\nid_height_dict\tChainIdAndHeightDict.IdHeightDictEntry\tA collection of chain ids and heights, where the key is the chain id and the value is the height.\trepeated\nacs7.ChainIdAndHeightDict.IdHeightDictEntry​\nField\tType\tDescription\tLabel\nkey\tint32\t\t\nvalue\tint64\t\t\nacs7.ChainInitializationConsensusInfo​\nField\tType\tDescription\tLabel\ninitial_consensus_data\tbytes\tInitial consensus data.\t\nacs7.ChainInitializationData​\nField\tType\tDescription\tLabel\nchain_id\tint32\tThe id of side chain.\t\ncreator\taelf.Address\tThe side chain creator.\t\ncreation_timestamp\tgoogle.protobuf.Timestamp\tThe timestamp for side chain creation.\t\ncreation_height_on_parent_chain\tint64\tThe height of side chain creation on parent chain.\t\nchain_creator_privilege_preserved\tbool\tCreator privilege boolean flag: True if chain creator privilege preserved, otherwise false.\t\nparent_chain_token_contract_address\taelf.Address\tParent chain token contract address.\t\nchain_initialization_consensus_info\tChainInitializationConsensusInfo\tInitial consensus information.\t\nnative_token_info_data\tbytes\tThe native token info.\t\nresource_token_info\tResourceTokenInfo\tThe resource token information.\t\nchain_primary_token_info\tChainPrimaryTokenInfo\tThe chain primary token information.\t\nacs7.ChainPrimaryTokenInfo​\nField\tType\tDescription\tLabel\nchain_primary_token_data\tbytes\tThe side chain primary token data.\t\nside_chain_token_initial_issue_list\tSideChainTokenInitialIssue\tThe side chain primary token initial issue list.\trepeated\nacs7.CreateSideChainInput​\nField\tType\tDescription\tLabel\nside_chain_creation_request\tSideChainCreationRequest\tThe request information of the side chain creation.\t\nproposer\taelf.Address\tThe proposer of the side chain creation.\t\nacs7.CrossChainBlockData​\nField\tType\tDescription\tLabel\nside_chain_block_data_list\tSideChainBlockData\tThe side chain block data list to index.\trepeated\nparent_chain_block_data_list\tParentChainBlockData\tThe parent chain block data list to index.\trepeated\nacs7.CrossChainExtraData​\nField\tType\tDescription\tLabel\ntransaction_status_merkle_tree_root\taelf.Hash\tMerkle tree root of side chain block transaction status root.\t\nacs7.CrossChainIndexingDataProposedEvent​\nField\tType\tDescription\tLabel\nproposed_cross_chain_data\tCrossChainBlockData\tProposed cross chain data to be indexed.\t\nproposal_id\taelf.Hash\tThe proposal id.\t\nacs7.CrossChainMerkleProofContext​\nField\tType\tDescription\tLabel\nbound_parent_chain_height\tint64\tThe height of parent chain bound up with side chain.\t\nmerkle_path_from_parent_chain\taelf.MerklePath\tThe merkle path generated from parent chain.\t\nacs7.IndexedParentChainBlockData​\nField\tType\tDescription\tLabel\nlocal_chain_height\tint64\tThe height of the local chain when indexing the parent chain.\t\nparent_chain_block_data_list\tParentChainBlockData\tParent chain block data.\trepeated\nacs7.IndexedSideChainBlockData​\nField\tType\tDescription\tLabel\nside_chain_block_data_list\tSideChainBlockData\tSide chain block data.\trepeated\nacs7.ParentChainBlockData​\nField\tType\tDescription\tLabel\nheight\tint64\tThe height of parent chain.\t\ncross_chain_extra_data\tCrossChainExtraData\tThe merkle tree root computing from side chain roots.\t\nchain_id\tint32\tThe parent chain id.\t\ntransaction_status_merkle_tree_root\taelf.Hash\tThe merkle tree root computing from transactions status in parent chain block.\t\nindexed_merkle_path\tParentChainBlockData.IndexedMerklePathEntry\tIndexed block height from side chain and merkle path for this side chain block.\trepeated\nextra_data\tParentChainBlockData.ExtraDataEntry\tExtra data map.\trepeated\nacs7.ParentChainBlockData.ExtraDataEntry​\nField\tType\tDescription\tLabel\nkey\tstring\t\t\nvalue\tbytes\t\t\nacs7.ParentChainBlockData.IndexedMerklePathEntry​\nField\tType\tDescription\tLabel\nkey\tint64\t\t\nvalue\taelf.MerklePath\t\t\nacs7.RechargeInput​\nField\tType\tDescription\tLabel\nchain_id\tint32\tThe chain id to recharge.\t\namount\tint64\tThe amount to recharge.\t\nacs7.ReleaseCrossChainIndexingProposalInput​\nField\tType\tDescription\tLabel\nchain_id_list\tint32\tList of chain ids to release.\trepeated\nacs7.ReleaseSideChainCreationInput​\nField\tType\tDescription\tLabel\nproposal_id\taelf.Hash\tThe proposal id of side chain creation.\t\nacs7.ResourceTokenInfo​\nField\tType\tDescription\tLabel\nresource_token_list_data\tbytes\tThe resource token information.\t\ninitial_resource_amount\tInitialResourceAmountEntry\tThe initial resource token amount.\trepeated\nacs7.ResourceTokenInfo.InitialResourceAmountEntry​\nField\tType\tDescription\tLabel\nkey\tstring\t\t\nvalue\tint32\t\t\nacs7.SideChainBlockData​\nField\tType\tDescription\tLabel\nheight\tint64\tThe height of side chain block.\t\nblock_header_hash\taelf.Hash\tThe hash of side chain block.\t\ntransaction_status_merkle_tree_root\taelf.Hash\tThe merkle tree root computing from transactions status in side chain block.\t\nchain_id\tint32\tThe id of side chain.\t\nacs7.SideChainCreationRequest​\nField\tType\tDescription\tLabel\nindexing_price\tint64\tThe cross chain indexing price.\t\nlocked_token_amount\tint64\tInitial locked balance for a new side chain.\t\nis_privilege_preserved\tbool\tCreator privilege boolean flag: True if chain creator privilege preserved, otherwise false.\t\nside_chain_token_creation_request\tSideChainTokenCreationRequest\tSide chain token information.\t\nside_chain_token_initial_issue_list\tSideChainTokenInitialIssue\tA list of accounts and amounts that will be issued when the chain starts.\trepeated\ninitial_resource_amount\tInitialResourceAmountEntry\tThe initial rent resources.\trepeated\nacs7.SideChainCreationRequest.InitialResourceAmountEntry​\nField\tType\tDescription\tLabel\nkey\tstring\t\t\nvalue\tint32\t\t\nacs7.SideChainIndexingInformation​\nField\tType\tDescription\tLabel\nchain_id\tint32\tThe side chain id.\t\nindexed_height\tint64\tThe indexed height.\t\nacs7.SideChainIndexingInformationList​\nField\tType\tDescription\tLabel\nindexing_information_list\tSideChainIndexingInformation\tA list contains indexing information of side chains.\trepeated\nacs7.SideChainTokenCreationRequest​\nField\tType\tDescription\tLabel\nside_chain_token_symbol\tstring\tToken symbol of the side chain to be created\t\nside_chain_token_name\tstring\tToken name of the side chain to be created\t\nside_chain_token_total_supply\tint64\tToken total supply of the side chain to be created\t\nside_chain_token_decimals\tint32\tToken decimals of the side chain to be created\t\nacs7.SideChainTokenInitialIssue​\nField\tType\tDescription\tLabel\naddress\taelf.Address\tThe account that will be issued.\t\namount\tint64\tThe amount that will be issued.\t\nacs7.VerifyTransactionInput​\nField\tType\tDescription\tLabel\ntransaction_id\taelf.Hash\tThe cross chain transaction id to verify.\t\npath\taelf.MerklePath\tThe merkle path of the transaction.\t\nparent_chain_height\tint64\tThe height of parent chain that indexing this transaction.\t\nverified_chain_id\tint32\tThe chain if to verify.\t\nAElf.Types​\naelf.Address​\nField\tType\tDescription\tLabel\nvalue\tbytes\t\t\naelf.BinaryMerkleTree​\nField\tType\tDescription\tLabel\nnodes\tHash\tThe leaf nodes.\trepeated\nroot\tHash\tThe root node hash.\t\nleaf_count\tint32\tThe count of leaf node.\t\naelf.Hash​\nField\tType\tDescription\tLabel\nvalue\tbytes\t\t\naelf.LogEvent​\nField\tType\tDescription\tLabel\naddress\tAddress\tThe contract address.\t\nname\tstring\tThe name of the log event.\t\nindexed\tbytes\tThe indexed data, used to calculate bloom.\trepeated\nnon_indexed\tbytes\tThe non-indexed data.\t\naelf.MerklePath​\nField\tType\tDescription\tLabel\nmerkle_path_nodes\tMerklePathNode\tThe merkle path nodes.\trepeated\naelf.MerklePathNode​\nField\tType\tDescription\tLabel\nhash\tHash\tThe node hash.\t\nis_left_child_node\tbool\tWhether it is a left child node.\t\naelf.SInt32Value​\nField\tType\tDescription\tLabel\nvalue\tsint32\t\t\naelf.SInt64Value​\nField\tType\tDescription\tLabel\nvalue\tsint64\t\t\naelf.ScopedStatePath​\nField\tType\tDescription\tLabel\naddress\tAddress\tThe scope address, which will be the contract address.\t\npath\tStatePath\tThe path of contract state.\t\naelf.SmartContractRegistration​\nField\tType\tDescription\tLabel\ncategory\tsint32\tThe category of contract code (0: C#).\t\ncode\tbytes\tThe byte array of the contract code.\t\ncode_hash\tHash\tThe hash of the contract code.\t\nis_system_contract\tbool\tWhether it is a system contract.\t\nversion\tint32\tThe version of the current contract.\t\naelf.StatePath​\nField\tType\tDescription\tLabel\nparts\tstring\tThe partial path of the state path.\trepeated\naelf.Transaction​\nField\tType\tDescription\tLabel\nfrom\tAddress\tThe address of the sender of the transaction.\t\nto\tAddress\tThe address of the contract when calling a contract.\t\nref_block_number\tint64\tThe height of the referenced block hash.\t\nref_block_prefix\tbytes\tThe first four bytes of the referenced block hash.\t\nmethod_name\tstring\tThe name of a method in the smart contract at the To address.\t\nparams\tbytes\tThe parameters to pass to the smart contract method.\t\nsignature\tbytes\tWhen signing a transaction it’s actually a subset of the fields: from/to and the target method as well as the parameter that were given. It also contains the reference block number and prefix.\t\naelf.TransactionExecutingStateSet​\nField\tType\tDescription\tLabel\nwrites\tTransactionExecutingStateSet.WritesEntry\tThe changed states.\trepeated\nreads\tTransactionExecutingStateSet.ReadsEntry\tThe read states.\trepeated\ndeletes\tTransactionExecutingStateSet.DeletesEntry\tThe deleted states.\trepeated\naelf.TransactionExecutingStateSet.DeletesEntry​\nField\tType\tDescription\tLabel\nkey\tstring\t\t\nvalue\tbool\t\t\naelf.TransactionExecutingStateSet.ReadsEntry​\nField\tType\tDescription\tLabel\nkey\tstring\t\t\nvalue\tbool\t\t\naelf.TransactionExecutingStateSet.WritesEntry​\nField\tType\tDescription\tLabel\nkey\tstring\t\t\nvalue\tbytes\t\t\naelf.TransactionResult​\nField\tType\tDescription\tLabel\ntransaction_id\tHash\tThe transaction id.\t\nstatus\tTransactionResultStatus\tThe transaction result status.\t\nlogs\tLogEvent\tThe log events.\trepeated\nbloom\tbytes\tBloom filter for transaction logs. A transaction log event can be defined in the contract and stored in the bloom filter after the transaction is executed.\t\nreturn_value\tbytes\tThe return value of the transaction execution.\t\nblock_number\tint64\tThe height of the block that packages the transaction.\t\nblock_hash\tHash\tThe hash of the block that packages the transaction.\t\nerror\tstring\tFailed execution error message.\t\naelf.TransactionResultStatus​\nName\tNumber\tDescription\nNOT_EXISTED\t0\tThe execution result of the transaction does not exist.\nPENDING\t1\tThe transaction is in the transaction pool waiting to be packaged.\nFAILED\t2\tTransaction execution failed.\nMINED\t3\tThe transaction was successfully executed and successfully packaged into a block.\nCONFLICT\t4\tWhen executed in parallel, there are conflicts with other transactions.\nPENDING_VALIDATION\t5\tThe transaction is waiting for validation.\nNODE_VALIDATION_FAILED\t6\tTransaction validation failed.\nAuthorityInfo​\nField\tType\tDescription\tLabel\ncontract_address\taelf.Address\tThe contract address of the controller.\t\nowner_address\taelf.Address\tThe address of the owner of the contract.\t\nPrevious\nProfit Contract\nNext\nTreasury Contract\nContract Methods\nAElf.Standards.ACS1\nAElf.Standards.ACS7\nAElf.Contracts.CrossChain\nCrossChain.AcceptCrossChainIndexingProposalInput\nCrossChain.ChainIndexingProposal\nCrossChain.ChangeSideChainIndexingFeeControllerInput\nCrossChain.CrossChainIndexingControllerChanged\nCrossChain.Disposed\nCrossChain.GetChainStatusOutput\nCrossChain.GetIndexingProposalStatusOutput\nCrossChain.GetIndexingProposalStatusOutput.ChainIndexingProposalStatusEntry\nCrossChain.GetPendingCrossChainIndexingProposalOutput\nCrossChain.InitializeInput\nCrossChain.ParentChainIndexed\nCrossChain.PendingChainIndexingProposalStatus\nCrossChain.ProposedCrossChainIndexing\nCrossChain.ProposedCrossChainIndexing.ChainIndexingProposalCollectionsEntry\nCrossChain.SideChainCreatedEvent\nCrossChain.SideChainCreationRequestState\nCrossChain.SideChainIndexed\nCrossChain.SideChainIndexingFeeControllerChanged\nCrossChain.SideChainInfo\nCrossChain.SideChainInfo.ArrearsInfoEntry\nCrossChain.SideChainLifetimeControllerChanged\nCrossChain.CrossChainIndexingProposalStatus\nCrossChain.SideChainStatus\nAElf.Standards.ACS1\nacs1.MethodFee\nacs1.MethodFees\nAElf.Standards.ACS7\nacs7.AdjustIndexingFeeInput\nacs7.ChainIdAndHeightDict\nacs7.ChainIdAndHeightDict.IdHeightDictEntry\nacs7.ChainInitializationConsensusInfo\nacs7.ChainInitializationData\nacs7.ChainPrimaryTokenInfo\nacs7.CreateSideChainInput\nacs7.CrossChainBlockData\nacs7.CrossChainExtraData\nacs7.CrossChainIndexingDataProposedEvent\nacs7.CrossChainMerkleProofContext\nacs7.IndexedParentChainBlockData\nacs7.IndexedSideChainBlockData\nacs7.ParentChainBlockData\nacs7.ParentChainBlockData.ExtraDataEntry\nacs7.ParentChainBlockData.IndexedMerklePathEntry\nacs7.RechargeInput\nacs7.ReleaseCrossChainIndexingProposalInput\nacs7.ReleaseSideChainCreationInput\nacs7.ResourceTokenInfo\nacs7.ResourceTokenInfo.InitialResourceAmountEntry\nacs7.SideChainBlockData\nacs7.SideChainCreationRequest\nacs7.SideChainCreationRequest.InitialResourceAmountEntry\nacs7.SideChainIndexingInformation\nacs7.SideChainIndexingInformationList\nacs7.SideChainTokenCreationRequest\nacs7.SideChainTokenInitialIssue\nacs7.VerifyTransactionInput\nAElf.Types\naelf.Address\naelf.BinaryMerkleTree\naelf.Hash\naelf.LogEvent\naelf.MerklePath\naelf.MerklePathNode\naelf.SInt32Value\naelf.SInt64Value\naelf.ScopedStatePath\naelf.SmartContractRegistration\naelf.StatePath\naelf.Transaction\naelf.TransactionExecutingStateSet\naelf.TransactionExecutingStateSet.DeletesEntry\naelf.TransactionExecutingStateSet.ReadsEntry\naelf.TransactionExecutingStateSet.WritesEntry\naelf.TransactionResult\naelf.TransactionResultStatus\nAuthorityInfo\nPlatform\nTechnology\nAudit Report\nPrivacy\nTerms of Use\nCookie Policy\nDeveloper Resources\nQuick Start\nLearn\nDocs\nTools\nResources\nEcosystem\nOverview\ndApps\naelf Ventures\nBlog\nConnect\nContact Us\nCopyright © 2024 aelf"
    },
    {
      "title": "Tutorials | AELF Docs",
      "url": "https://docs.aelf.com/tutorials/",
      "html": "Skip to main content\nQuick Start\nLearn\nDocs\nTools\nResources\nBlog\nSearch\nUnderstanding aelf\nCore\nCross Chain\nConsensus\nNetwork\nBoot Sequence\nAddresses\nTransactions\nSmart Contract\nACS\nTutorials\nNode Operator\nTutorials\nTutorials\n🗃️ Node Operator\n\nOperate a node\n\nPrevious\nUser Contract\nNext\nNode Operator\nPlatform\nTechnology\nAudit Report\nPrivacy\nTerms of Use\nCookie Policy\nDeveloper Resources\nQuick Start\nLearn\nDocs\nTools\nResources\nEcosystem\nOverview\ndApps\naelf Ventures\nBlog\nConnect\nContact Us\nCopyright © 2024 aelf"
    },
    {
      "title": "AELF Docs",
      "url": "https://docs.aelf.com/quick-start/node-operators/",
      "html": "Skip to main content\nQuick Start\nLearn\nDocs\nTools\nResources\nBlog\nSearch\nQuick Start\nFor Developers\nFor Node Operators\nOperations\nRun a Mainnet Node\nSimulation in the Local Environment\nCreation of a Side Chain\nQuick StartFor Node Operators\nFor Node Operators\n📄️ Operations\n\nSteps to Become a BP\n\n📄️ Run a Mainnet Node\n\nHow to Join the Mainnet\n\n📄️ Simulation in the Local Environment\n\nSet up a Full Node\n\n📄️ Creation of a Side Chain\n\nHow to create a side chain ?\n\nPrevious\nVote Contract\nNext\nOperations\nPlatform\nTechnology\nAudit Report\nPrivacy\nTerms of Use\nCookie Policy\nDeveloper Resources\nQuick Start\nLearn\nDocs\nTools\nResources\nEcosystem\nOverview\ndApps\naelf Ventures\nBlog\nConnect\nContact Us\nCopyright © 2024 aelf"
    },
    {
      "title": "For Developers | AELF Docs",
      "url": "https://docs.aelf.com/quick-start/developers/",
      "html": "Skip to main content\nQuick Start\nLearn\nDocs\nTools\nResources\nBlog\nSearch\nQuick Start\nFor Developers\nHello World Contract\nLottery Game Contract\nVote Contract\nFor Node Operators\nQuick StartFor Developers\nFor Developers\n\nWelcome to the technical documentation for developing smart contracts on aelf blockchain. This guide will walk you through writing your very first smart contracts, starting from a simple \"Hello\" contract to a more complex voting contract. Each section is designed to build on the knowledge from the previous one, ensuring a smooth learning curve.\n\n📄️ Hello World Contract\n\nSimplest contract to get you started\n\n📄️ Lottery Game Contract\n\nModerately complex smart contract\n\n📄️ Vote Contract\n\nSlightly more complex contract\n\nPrevious\nQuick Start\nNext\nHello World Contract\nPlatform\nTechnology\nAudit Report\nPrivacy\nTerms of Use\nCookie Policy\nDeveloper Resources\nQuick Start\nLearn\nDocs\nTools\nResources\nEcosystem\nOverview\ndApps\naelf Ventures\nBlog\nConnect\nContact Us\nCopyright © 2024 aelf"
    },
    {
      "title": "AELF Docs",
      "url": "https://docs.aelf.com/legal/cookie-policy/",
      "html": "Skip to main content\nQuick Start\nLearn\nDocs\nTools\nResources\nBlog\nSearch\nCookie Policy\n\nLast updated: 25 June 2024\n\nThis Cookie Policy explains how Aelf Pte Ltd (\"Company,\" \"we,\" \"us,\" and \"our\") uses cookies and similar technologies to recognize you when you visit our website at https://www.aelf.com (\"Website\"). It explains what these technologies are and why we use them, as well as your rights to control our use of them. This may help us to provide you with a good experience when you browse our Websites and may also allow us to improve our Websites. By continuing to browse the Websites, you are agreeing to our use of cookies as well as the terms of this policy (the “Cookie Policy”). Please note that in some cases we may use cookies to collect personal information, or that becomes personal information if we combine it with other information.\n\nWhat are cookies?\n\nCookies are small data files that are placed on your computer or mobile device when you visit a website. Cookies are widely used by website owners in order to make their websites work, or to work more efficiently, as well as to provide reporting information.\n\nCookies set by the website owner are called \"first-party cookies.\" Cookies set by parties other than the website owner are called \"third-party cookies.\" Third-party cookies enable third-party features or functionality to be provided on or through the website (e.g., advertising, interactive content, and analytics). The parties that set these third-party cookies can recognize your computer both when it visits the website in question and also when it visits certain other websites.\n\nWhy do we use cookies?\n\nWe use first- and third-party cookies for several reasons. Some cookies are required for technical reasons in order for our Website to operate, and we refer to these as \"essential\" or \"strictly necessary\" cookies. Other cookies also enable us to track and target the interests of our users to enhance the experience on our Online Properties. Third parties serve cookies through our Website for advertising, analytics, and other purposes. This is described in more detail below.\n\nHow can I control cookies?\n\nYou have the right to decide whether to accept or reject cookies. You can exercise your cookie rights by setting your preferences in the Cookie Consent Manager. The Cookie Consent Manager allows you to select which categories of cookies you accept or reject. Essential cookies cannot be rejected as they are strictly necessary to provide you with services.\n\nThe Cookie Consent Manager can be found in the notification banner and on our website. If you choose to reject cookies, you may still use our website though your access to some functionality and areas of our website may be restricted. You may also set or amend your web browser controls to accept or refuse cookies.\n\nThe specific types of first- and third-party cookies served through our Website and the purposes they perform are described in the table below (please note that the specific cookies served may vary depending on the specific Online Properties you visit):\n\nHow can I control cookies on my browser?\n\nAs the means by which you can refuse cookies through your web browser controls vary from browser to browser, you should visit your browser's help menu for more information. The following is information about how to manage cookies on the most popular browsers:\n\n- Chrome\n\n- Internet Explorer\n\n- Firefox\n\n- Safari\n\n- Edge\n\n- Opera\n\nIn addition, most advertising networks offer you a way to opt out of targeted advertising. If you would like to find out more information, please visit:\n\n- Digital Advertising Alliance\n\n- Digital Advertising Alliance of Canada\n\n- European Interactive Digital Advertising Alliance\n\nWhat about other tracking technologies, like web beacons?\n\nCookies are not the only way to recognize or track visitors to a website. We may use other, similar technologies from time to time, like web beacons (sometimes called \"tracking pixels\" or \"clear gifs\"). These are tiny graphics files that contain a unique identifier that enables us to recognize when someone has visited our Website or opened an email including them. This allows us, for example, to monitor the traffic patterns of users from one page within a website to another, to deliver or communicate with cookies, to understand whether you have come to the website from an online advertisement displayed on a third-party website, to improve site performance, and to measure the success of email marketing campaigns. In many instances, these technologies are reliant on cookies to function properly, and so declining cookies will impair their functioning.\n\nDo you use Flash cookies or Local Shared Objects?\n\nWebsites may also use so-called \"Flash Cookies\" (also known as Local Shared Objects or \"LSOs\") to, among other things, collect and store information about your use of our services, fraud prevention, and for other site operations.\n\nIf you do not want Flash Cookies stored on your computer, you can adjust the settings of your Flash player to block Flash Cookies storage using the tools contained in the Website Storage Settings Panel. You can also control Flash Cookies by going to the Global Storage Settings Panel and following the instructions (which may include instructions that explain, for example, how to delete existing Flash Cookies (referred to \"information\" on the Macromedia site), how to prevent Flash LSOs from being placed on your computer without your being asked, and (for Flash Player 8 and later) how to block Flash Cookies that are not being delivered by the operator of the page you are on at the time).\n\nPlease note that setting the Flash Player to restrict or limit acceptance of Flash Cookies may reduce or impede the functionality of some Flash applications, including, potentially, Flash applications used in connection with our services or online content.\n\nDo you serve targeted advertising?\n\nThird parties may serve cookies on your computer or mobile device to serve advertising through our Website. These companies may use information about your visits to this and other websites in order to provide relevant advertisements about goods and services that you may be interested in. They may also employ technology that is used to measure the effectiveness of advertisements. They can accomplish this by using cookies or web beacons to collect information about your visits to this and other sites in order to provide relevant advertisements about goods and services of potential interest to you. The information collected through this process does not enable us or them to identify your name, contact details, or other details that directly identify you unless you choose to provide these.\n\nHow often will you update this Cookie Policy?\n\nWe may update this Cookie Policy from time to time in order to reflect, for example, changes to the cookies we use or for other operational, legal, or regulatory reasons. Please therefore revisit this Cookie Policy regularly to stay informed about our use of cookies and related technologies.\n\nThe date at the top of this Cookie Policy indicates when it was last updated.\n\nWhere can I get further information?\n\nIf you have any questions about our use of cookies or other technologies, please contact us here.\n\nPlatform\nTechnology\nAudit Report\nPrivacy\nTerms of Use\nCookie Policy\nDeveloper Resources\nQuick Start\nLearn\nDocs\nTools\nResources\nEcosystem\nOverview\ndApps\naelf Ventures\nBlog\nConnect\nContact Us\nCopyright © 2024 aelf"
    },
    {
      "title": "AELF Docs",
      "url": "https://docs.aelf.com/legal/terms-of-use/",
      "html": "Skip to main content\nQuick Start\nLearn\nDocs\nTools\nResources\nBlog\nSearch\nTerms of Use\n\nTerms of Use\n\nLast updated: 25 June 2024\n\nNOTICE OF BINDING TERMS OF USE: By accessing, browsing or using our Site, you acknowledge that you have read, understand and agree to be bound by these Terms of Use, including the binding arbitration agreement in Section 13. The use of our Site, includes but is not limited to our Website (at http://www.aelf.com) and other software or internet-based locations and features as identified below. You should carefully read these “Terms of Use” before using any infrastructure available through the Site, including as you may access it directly or indirectly, such as where it may be embedded in any associated web applications or wallets you use.\n\nIf you do not understand and accept all these Terms and Conditions, then you should avoid using our Site, refrain from downloading any materials from our Site, and promptly redirect your web browser (or other internet-based application you may be using) away from our Site.\n\nNOTICE OF BINDING ARBITRATION: Any claim, dispute, or controversy of any nature arising out of these Terms of Use must be resolved by final and binding arbitration in accordance with the requirements described in Section 13.\n\n1. Agreement to Terms of Use\n\n1.1. Your Assent to these Terms of Use. These Terms of Use constitute a legally binding agreement between you, whether personally or on behalf of an entity or group (“you” or “your”) and Aelf Pte Ltd (“we,” “us,” “our,” or “aelf”) concerning your use of our Site (as defined in clause 1.4). You are strictly prohibited from, and agree to refrain from, using or accessing any part of the Site if you do not consent to these Terms of Use.\n\n1.2. Entire Agreement. These Terms of Use, together with any other terms, policies, or notices to which you may agree in writing, as applicable (including but not limited to those documents incorporated by clause 1.11, below) constitute the sole and entire agreement between you and aelf and supersede all prior and contemporaneous understandings between the parties on your use of the Site. Any additional terms, conditions, licenses, limitations, disclaimers and obligations contained within and on the Site are incorporated into these Terms of Use by reference, including the Privacy Policy. You agree that, by accessing the Site, you represent and warrant that you have read, understood, and agreed to all provisions of these Terms of Use.\n\n1.3. Contact Us. Please reach out to us here.\n\n1.4. Our Site. These Terms of Use govern your use of our “Site,” which DOES NOT INCLUDE the aelf chain or the blockchain-based protocols of the underlying aelf network, but which DOES INCLUDE the software and internet-based information, services, and features (and related communications) available through each of the following:\n\na. Our website at http://www.aelf.com or any subdomain thereof controlled by us (the “Website”);\n\nb. Our blockchain explorer available at http://explorer.aelf.io (the “Explorer”);\n\nc. Other communication by us on infrastructure not operated by us including accounts on social media platforms (such as Twitter, Facebook, YouTube, Medium and the like) and communication tools (such as Discord and Telegram) and other public forums moderated by us (collectively, “Social Media”).\n\n1.5. Disclaimer of Responsibility for the Chain. aelf has no control over the operation of the aelf chain and offers no warranties in relation to its use, and your use of the aelf chain is not governed by these Terms of Use. The aelf chain forms a decentralised, permissionless distributed ledger technology ecosystem with no single source of truth or central authority or point of control. By accepting these Terms of Use, you represent that you understand and accept this disclaimer and the disclosures provided in the Important Notice relevant to your use of the aelf chain. aelf is not responsible for any action in which you might engage using the aelf chain, or for any actions of unauthorised users of any account or credentials belonging to you to access any part of the Site, and aelf expressly disclaims and all corresponding liability.\n\n1.6. Your Agreement to Modifications. We may make changes to these Terms of Use at any time, and, by accessing the Site, you agree to be bound by the most current version. “Last Updated” section at the beginning of these Terms of Use will reflect the last date when such amendments are made, which shall be effective immediately, unless explicitly stated otherwise. It is your responsibility to check these Terms of Use and remain informed of any amendments as long as you continue accessing or using the Site or any Services. If you disagree with these Terms of Use or with any subsequent amendments, changes, or updates, you may not use the Site or any of the Services; your only recourse in the case of disagreement is to stop accessing the Site. In the event of any inconsistency between these Terms of Use and any other pages or policies on the Site, these Terms shall prevail.\n\n1.7. Changes to our Site. We may update or change any component of the Site from time to time to reflect changes to our products, user needs or business priorities, without providing notice to you.\n\n1.8. Access Restrictions. The information and features provided on the Site are not intended for distribution to or use by any person or entity in any jurisdiction or country where distribution or use would be contrary to law or regulation, such as applicable sanctions, or require us to hold any special licence or registration within your jurisdiction. We make no claims that the Site or any of its content or features are accessible or appropriate in the user’s jurisdiction. Access to the Site may not be legal by certain persons or in certain countries. If you access the Site, you are solely responsible for ensuring that your access to and use of the Site does not violate any applicable laws or regulations in any jurisdiction to which you may be subject.\n\n1.9. Representation of inapplicability of Sanctions. Without limiting any other provision in these Terms and Conditions, by using the Site, you represent and warrant that (a) you are not located in a country that is subject to a U.S. Government embargo/trade sanction, and (b) you are not identified as a Specially Designated National or placed on any U.S. Government list of prohibited, sanctioned, or restricted parties politically exposed person under anti-money laundering legislation or a sanctioned person.\n\n1.10. Representation of Capacity and Authority. The Site is only to be used by persons who are at least 18 years old. By using the Site, you agree to these Terms of Use and represent and warrant that you are at least 18 years old, and that you have both the authority (on your own behalf or as an agent of an entity) and capacity to assent to these Terms and Conditions.\n\n1.11. Incorporation of Other Terms. As between you and aelf, all other terms, conditions, policies, or notices to which you may agree, including but not limited to each of the following, are expressly incorporated into these Terms and Conditions by reference:\n\na. Our Privacy Policy, available here, which governs our use of any personal data we collect about you or you provide to us, and, under which you consent to our use of your personal information and warrant that all data you provide is accurate (our “Privacy Policy”);\n\nb. Our Cookie Policy available here, which sets out how aelf uses cookies and similar technologies to recognize you when you visit our Website.\n\nc. Any applicable terms, disclosures, and other documents that may be posted on the Site from time to time; and\n\nd. Any other terms and conditions to which you may separately agree and govern your use of the software, products, services, content, tools and market data provided through the Site.\n\n1.12. References to Your Account. Any reference to an “account” in these Terms of Use refers to an account or credential maintained and used uniquely to identify you and permit your access to any component of the Site. On the other hand, any reference to an “account” in these Terms of Use is completely unrelated to your connection and therefore accounts with any Social Media, the aelf chain, or any Wallet you may hold or interact with through aelf.\n\n2. Acceptable Use\n\n2.1. Use Restricted to Site Purposes. You may not access or use any part of the Site other than for the purpose or purposes expressly stated or readily implied by us through the Site or in other communications to you.\n\n2.2. Your Revocable Licence. Your use of our Site, including related software components, is subject to a limited, revocable licence granted to you under these Terms of Use. We do not sell this licence to you, and you acknowledge that we do not transfer or assign any title or ownership rights to any part of the Site to you.\n\n2.3. Prohibited Uses. aelf is not responsible or liable for your acts or behaviours, or the acts or behaviours of other Site users or other third parties, including but not limited to, Social Media or Third Party Products (as defined in clause 4.5). As a user of the Site, you agree not to do any of the following:\n\na. Make any unauthorised use of the Site, such as collecting other users’ usernames or email addresses to send unsolicited communications or creating user accounts (including any accounts when using Social Media) under false pretences;\n\nb. Systematically retrieve data or other content from the Site or users of the Site to compile a database or directory without our written permission;\n\nc. Circumvent, disable, or otherwise interfere with our Site’s security-related features, including features that prevent or restrict using or copying any Site-related data or content or enforce limitations on their use or copy;\n\nd. Use any Site information or features to bully, stalk, harass, abuse, assault, or harm any person, group or organization;\n\ne. Use any Site information or features in any effort to compete with us, create your own revenue-generating endeavour or commercial enterprise, or offer any substitute for any of the products, services or features we offer, either within or outside the Site;\n\nf. Harass, annoy, intimidate, or threaten any other Site user or any of our employees, agents, contractors, partners, or suppliers;\n\ng. Delete the copyright or other proprietary rights notice from your replication or use of any information or other content available on or through the Site;\n\nh. Decipher, decompile, disassemble, or reverse engineer any of the software comprising or in any way making up any part of the Site;\n\ni. Upload or transmit (or attempt to upload or transmit) any information, code, or other materials that function as a mechanism for passive or active information collection, including but not limited to clear graphics interchange formats (or GIFs), 1×1 pixels, web bugs, cookies, or other, similar devices (sometimes referred to as spyware or passive collection mechanisms);\n\nj. Upload or transmit (or attempt to upload or transmit) viruses, Trojan horses, or other material that interferes with any person, organization, or group’s uninterrupted use and enjoyment of the Site;\n\nk. Use, launch, or engage in any automated use of the Site’s system, such as using scripts to send comments or messages, robots, scrapers, or offline readers, or deploying similar data gathering or extraction tools;\n\nl. Disparage, tarnish, or otherwise harm the Site, or us or our agents, employees, partners, or suppliers, or use the Site to violate other persons’ privacy or other legal rights;\n\nm. Use the Site in a manner inconsistent with, or that violates, any applicable law or regulation;\n\nn. Trick, defraud, or mislead us and other Site users, especially in any attempt to learn sensitive account information, such as user passwords or other credentials;\n\no. Make improper use of our support services or submit false reports of abuse or misconduct;\n\np. Interfere with, disrupt, or create an undue burden on any component of the Site or networks connected to the Site;\n\nq. Attempt to impersonate another user or person, use the username or credentials of another user, or impersonate or attempt to impersonate aelf or any aelf agent or employee (including, without limitation, by using any associated email addresses or usernames);\n\nr. Use the Site to advertise or sell goods and services;\n\ns. Access or attempt to access any part of the Site that you are restricted from accessing;\n\nt. Misrepresent your or any other Site user’s experience, skills, or information;\n\nu. Falsely imply a relationship with us or another company with whom you do not have a relationship.\n\nv. Engage in any overtly discriminatory, racist, sexist, misogynistic, objectifying, homophobic, or transphobic act or permeate any other form of bigotry or hatred;\n\nw. Act in any way to release personal information, including real-world information about other users or any aelf agents or employees;\n\nx. Engage in, advocate for, or induce any act that would be deemed illegal in any jurisdiction to which you may be subject, including but not limited to any theft, aggravated sexual act, self–harm, insurrection, property damage, violent act, intimidation, libel, or other harm;\n\ny. Expose any persons under 18 years old to dangerous situations, including but not limited to grooming, inappropriate content, or sexualization (regardless of jurisdiction); or\n\nz. Impersonate or attempt to impersonate any other person (using an email address, name, username, title, or other identifying information or credential).\n\n2.4. Unauthorised Access or Use. You understand and agree that you are strictly prohibited from (a) making any attempt to gain unauthorised access to the Site or any networks, servers, or computer systems connected to the Site and (b) making any modifications, adaptations, additions, or enhancements to the Site or our Site Content for any reason (including error correction), including the modification of the paper or digital copies you may have downloaded.\n\n3. Your Responsibilities\n\n3.1. Responsibility for Your Conduct. You accept and acknowledge that you are solely responsible for your conduct and all activity associated with your Site accounts and credentials, any Wallet you may hold, and your use of the Site and, if applicable, the aelf chain. You alone are responsible for any unauthorised access to and use of your accounts and credentials, and you accept all risk resulting from any other access to or use of (whether authorised or unauthorised) the Site or related third-party services, to the maximum extent permitted by law. You agree to use the Site for purposes that are legal, proper, and in accordance with any applicable laws or regulations and the provisions of these Terms and Conditions.\n\n3.2 Responsibility for Your Credentials. You understand and accept that you are responsible for securing your own private keys or other credentials you use to access any component of the Site, the aelf chain, your Wallet, or third-party applications. You represent and warrant that you are familiar with and accept the risks associated with digital applications, digital identity, private keys, and the importance of keeping these secure, and other related risks.\n\n4. Our Content\n\n4.1. Rights to Site Content. Unless otherwise indicated by us in writing, we own all rights to our Site and all related content and features, including but not limited to source code, databases, functionality, software, website designs, audio, video, text, photographs, logos, and graphics available on, through, or in connection with any part of the Site (altogether, “Site Content”). Except where specifically attributed to someone else, we own all necessary moral, proprietary, and licensing rights related to Site Content, which is protected by copyright, trademark, and other applicable intellectual property laws and international conventions all around the world. You are not permitted to use our trademarks or copyrighted material without first receiving our written consent or the consent of the owner of the marks.\n\n4.2. Use of Open-Source Code. Some components of the Site and related services or features may include certain open source components that are subject to open source software licenses owned by one or more third parties (the “Open Source Code”). Your use of any Open-Source Code or any components of our Site is not subject to the provisions of these Terms and Conditions but, instead, is subject to the licence terms accompanying the Open-Source Code. Nothing in these Terms and Conditions limits your rights under, or grants you rights superseding, the terms of any Open-Source Code.\n\n4.3. Copying Our Site or Content. Unless otherwise expressly provided in these Terms and Conditions, you are prohibited from, and agree not to, copy, reproduce, aggregate, republish, upload, post, publicly display, encode, translate, transmit, distribute, sell, licence, or otherwise commercially exploit any part of the Site or any Site Content without first obtaining our express written permission.\n\n4.4. Your Limited Licence. If you are eligible to use the Site, we grant you a limited licence to access and use the Site and our Site Content in accordance with these Terms and Conditions, and to download or print a copy of any Site Content that you are authorised to access, but solely to the extent you use the copies for your own personal, non-commercial use.\n\n4.5. Third-Party Products. In addition to or as part of our Site Content, third parties may advertise, make commercial offers, or provide you with information, products, or services, including through third-party integrations and links to other websites (collectively, “Third-Party Products”). Third-Party Products may be governed by separate agreements or licences with those third parties. We offer no guarantee and assume no responsibility or liability of any kind for Third-Party Products or their providers, including but not limited to your use of any content or features available through third-party sites. You understand and agree that you are responsible for the consequences of your use of any Third-Party Products, and that we bear no responsibility or liability for Third-Party Products or the actions of any third parties. We are not responsible for the actions of any third party or their compliance or noncompliance with any applicable laws or regulations.\n\n4.6. Purposes of Content. All Site Content is provided to you for informational purposes only. To the extent permitted by law and subject to clauses 8.6 and 8.7, we disclaim all liability in relation to your use of any Site Content. All other information, services, or features of third parties (whether available through our Website, on any Social Media, or by other means) is also for informational and educational purposes only. No party of any Site Content or third-party content should be construed as an endorsement by aelf to use any part of the Site or any products or services whatsoever. No Third-Party Products should be considered an endorsement of aelf. To the extent you use Third-Party Products or otherwise engage with third parties or third-party sites, links, or pop-ups, you do so at YOUR OWN RISK.\n\n4.7. Notifying Us of improper Copyright or Trademark use. If you are, or are authorised to act on behalf of, a copyright or trademark owner, and if you believe in good faith that your copyrighted work or trademark has been copied in a way that constitutes infringement of your intellectual property rights, then please provide us with written notice via mail or email (as specified in clause 1.3). Upon receipt of your notice, we will take whatever action we deem appropriate under the circumstances and applicable law, in our sole discretion.\n\n4.8. Disclaimer of Warranties. Although we make reasonable efforts to update the information on our Site, we make no representations, warranties, or guarantees, whether express or implied, that our Site Content is accurate, complete, or up to date. The Site is provided to you AS IS and AS AVAILABLE, with all faults. We expressly disclaim all liability for any inaccuracies in the Site, Site Content, or information processed through our systems or provided by any third party. We disclaim all warranties, express or implied, with respect to the Site, Site Content, and Third-Party Products including but not limited to any warranty of fitness for a particular purpose, merchantability, or good and workmanlike product or service. Additionally, we do not guarantee our Site will be secure or free from bugs, viruses, or other malware. You should not interpret any Site Content or any communications from us as advice of any kind, including but not limited to financial advice. You should seek professional or specialist advice before you ever consider acting or not acting on the basis of any Site Content. We are not liable for any errors in actions taken in reliance Site Content or any communications you may receive from us, including with respect to the release of any tokens or funds.\n\n5. Your Content\n\n5.1. Our Use of Your Content. The Site may provide you with opportunities to upload, display, or transmit data or other content (together, “User Content”). As part of these Terms and Conditions and subject to our Privacy Policy, you grant us a perpetual, irrevocable, worldwide, fully paid, non-exclusive, and non-sublicensable right and license to use and exploit any User Content in any form. We retain the unlimited right and exclusive discretion to copy, reproduce, fix, modify, adapt, translate, reformat, prepare derivatives of, manufacture, publish, distribute, sell, licence, transfer, lease, or transmit any User Content. We also reserve the right to incorporate any User Content as part of the Site or any Site Content, or into any other material.\n\n5.2. Your Feedback. No User Content you submit will be deemed to establish any additional or separate contractual relationship between you and us outside the provisions of these Terms and Conditions.\n\n5.3. Your Waiver of Moral Rights. Except to the extent prohibited by law, you agree to waive any intellectual property interest or other “moral rights” you may have in the User Content in any competent jurisdiction.\n\n5.4. Your Right to Submit Content. You represent and warrant that no User Content you upload through the Site in any way infringes on the copyright, trademark, patent, trade secret, or other intellectual property right of any third party.\n\n5.5. Prohibited Content. You represent and warrant that you will not use or contribute User Content that is unlawful, tortious, defamatory, obscene, invasive of personal privacy, threatening, harassing, abusive, hateful, racist, or otherwise objectionable, inappropriate, or which would otherwise violate clause 2.3.\n\n5.6. Our Removal of Content. We may remove any User Content or related content or elements from our Site at our sole discretion, and you understand and agree that we are not liable for removing or not removing any User Content or other content for any reason. We reserve the right to review any User Content. We may, in our discretion, take any appropriate action against you if you upload User Content in violation of these Terms and Conditions.\n\n6. Site Management\n\n6.1. Our Functions. We reserve the right, but not the obligation to do any of the following:\n\na. Monitor the Site for breaches or violations of these Terms of Use;\n\nb. Take appropriate legal action against anyone who, in our sole discretion, violates any applicable laws or these Terms of Use, including without limitation, reporting such user to law enforcement authorities;\n\nc. In our sole discretion and without limitation, disable access to the Site to address any hacks, exploits, system vulnerabilities, or anything that is in any way a burden to our systems; and\n\nd. Otherwise manage the Site in a manner designed to protect our rights and property and to facilitate the proper functioning of our Site.\n\n6.2. Site Uptime. We cannot guarantee or make any assurances of any kind that our Site will always be available and free from defects, viruses and malware and we expressly disclaim all warranties under clause 4.8. We may experience hardware, software, or other problems or need to perform maintenance related to the Site, which may result in interruptions, delays, or errors. You agree that we have no liability whatsoever for any loss, damage, or inconvenience caused by your inability to access or use the Site during any downtime or discontinuance of the Site. We are not obligated to maintain and support the Site or supply any corrections, updates, or releases.\n\n7. Information Collection\n\n7.1. Privacy of Your Information. To use certain features of the Site, you may be required to provide us with your personal information, including but not limited to your name, address, and contact details. Our use of your personal information is subject to the terms of our Privacy Policy which is incorporated in these Terms of Use. Any data collected about you or from you by third parties on our behalf is also subject to our Privacy Policy.\n\n7.2. Collecting Anonymised Data. When you use the Site, we may monitor your computer or mobile device’s memory to ensure the Site is performing properly. During this process, we may collect anonymised data from you or your device and use it to inform our Site’s continued development.\n\n8. Limitation of Liability\n\n8.1. Scope of Limitations. All warranties, terms, conditions and undertakings, express or implied (including by statute, custom or usage, a course of dealing, or common law), which we expressly disclaim in clause 4.8, as well as the liability we disclaim under this Section 8, are excluded to the fullest extent permitted by applicable law.\n\n8.2. Force Majeure. We will not be responsible for any delay or failure to comply with our obligations under these Terms of Use if our delay or failure is caused by an event reasonably beyond our control.\n\n8.3. Your Acceptance of Risks. You warrant that you understand and accept the inherent security risks of providing information over the internet and dealing online, and you agree that we have no liability or responsibility for any breach of security unless it is due to our gross negligence. Any information you send or receive while using the Site may not be secure and may be intercepted or later acquired by unauthorised parties. Your use of the Site and any related features or tools is at your own risk. You accept that in using any of the Site, Wallet or Chain, you are additionally subject to and understand and accept all other associated risks such as ownership expectations, technology risk, token risk and market risk as described in clause 4 (Assumption of risks) in our Supplemental Wallet Terms.\n\n8.4. Liability Cap. Notwithstanding anything to the contrary contained in these Terms and Conditions, our liability to you (for any cause whatsoever and regardless of the form of action) will at all times be limited to no more than a total aggregate amount equal to the greater of (a) the sum of $10,000 (USD) or (b) the amount paid, if any, by you to us for the use of any part of the Site during the 6-month period preceding the rise of any lawful cause of action.\n\n8.5. Our Responsibility for Loss or Damage. Regardless of whether you are a consumer or business user, we do not exclude or in any way limit our liability to you where it would be unlawful, such as liability for death or personal injury caused by our negligence or the negligence of our employees, agents, or contractors, or for fraud or fraudulent misrepresentation. We will not be responsible or liable to you for any losses you incur resulting from your use of the Site, your Wallet (if applicable), any other wallet (whether or not accessible from our Site) or any third-party dApps (whether or not accessible from our Site). To the extent permitted by law, we will not be responsible for any loss or damage, whether in contract, tort (including negligence), breach of statutory duty, or otherwise, even if foreseeable, arising under or in connection with your use of, or inability to use, our Site, or with your use of or reliance on any content displayed or otherwise obtained on or through our Site. Our exclusion from liability includes but is not limited to the following:\n\na. Loss of profits, sales, business, or revenue;\n\nb. Business interruption;\n\nc. Loss of anticipated savings;\n\nd. Loss of business opportunity, goodwill or reputation;\n\ne. Any indirect or consequential loss or damage;\n\nf. Any damage suffered from unauthorised access or activities by third parties, including the use of viruses, phishing, brute forcing, or other means of attack against the Site, the Chain, or your Wallet;\n\ng. Any user error, such as forgotten private keys or incorrectly construed smart contracts or other transactions;\n\nh. Any server failure or data loss, including loss of private keys;\n\ni. Corrupted wallet files; and\n\nj. Infringement of intellectual property rights by other users.\n\n8.6. Our Additional Responsibility if You Are a Consumer. If you are a consumer user of the Site, you agree that we have no liability to you for any loss of profit, loss of business or business opportunity, or business interruption resulting from your use of our Site for any commercial or business purposes. As a consumer, you may have legal rights in specific jurisdictions in relation to goods that are faulty or not as described. Nothing in these Terms of Use will affect these legal rights.\n\n9. User Representations\n\n9.1. Your Representations and Warranties. By using the Site, you represent and warrant each of the following (in addition to any other representations or warranties made by you in these Terms of Use):\n\na. Any registration information you submit is and will be true, accurate, current, and complete;\n\nb. You will maintain the accuracy of your information and promptly update your registration if your information changes or as otherwise necessary;\n\nc. You have the legal capacity, and agree, to comply with these Terms of Use, including that you are at least 18 years old and will not access the Site through automated or non-human means, whether through a bot, script, or otherwise;\n\nd. You will not use the Site for any illegal or unauthorised purpose; and\n\ne. Your use of the Site will not violate any applicable law or regulation.\n\n9.2. Misrepresentations. If you provide any information that is untrue, inaccurate, not current, incomplete, or misleading, we have the right to suspend or terminate your account and refuse any and all current or future access to and use of the Site (or any part of the Site).\n\n10. Indemnification\n\n10.1. Our Indemnity. You agree to defend, release, indemnify, and hold harmless us, our subsidiaries, affiliates, and all our respective officers, agents, partners, and employees, from and against any loss, damage, liability, claim, or demand, including for reasonable attorneys’ fees, made by third party arising from any of the following:\n\na. Your use of the Site, and any unauthorised use of any of your accounts or credentials to access and use the Site;\n\nb. Your breach of these Terms of Use or your representations and warranties set forth in these Terms of Use.\n\nc. Your violation of the rights of any third party, including but not limited to intellectual property rights; or\n\nd. Any overt harmful act toward any other user of the Site.\n\n10.2. Defence of Our Indemnity. We reserve the right, at your expense, to assume the exclusive defence and control of any matter for which you indemnify us under these Terms of Use, and you agree to fully cooperate, at your expense, with our defence of any related claims. We will use reasonable efforts to notify you of any such claim, action or proceeding which is subject to this indemnification upon becoming aware of it. Our indemnity under this Section 10 is in addition to, and not in lieu of, any other indemnities set forth in any other written agreement between us and you.\n\n11. Term and Termination\n\n11.1. Your Right to Not Use the Site. These Terms and Conditions will remain in full force and effect when you use any part of or maintain any account through the Site. You may terminate your use or participation at any time, for any reason, by directing yourself away from the Site or following the instructions for terminating your account in your account settings on the Site, if available, or by contacting us here. You can choose to voluntarily terminate your account with us by providing us with written notice, and, in doing so, you accept the following conditions:\n\na. You are responsible for removing your digital assets from the account prior to close;\n\nb. Any digital assets or other items or information you leave in a closed account may not be able to be retrieved, and we disclaim any corresponding liability to you; and\n\nc. Your chosen user credentials will be locked, and you will not be able to use them again to create a new account.\n\n11.2. Our Right to Restrict Access. Without limiting any other provision of these Terms of Use, we reserve the right, in our sole and absolute discretion and without notice or liability, to deny access to and use of the Site (including blocking certain IP addresses), to any person and for any reason, including but not limited to your breach of any representation, warranty, or covenant contained in these Terms of Use or violation of any applicable law or regulation. If we determine, in our sole discretion, that your use of the Site in any way breaches these Terms of Use, violates any applicable law or regulation, poses a security risk to our Site or any third party, or potentially subjects us or our affiliates to any third-party liability, then we may terminate your use of or participation with the Site or delete any of your accounts, User Content, or other information, without warning and at our sole discretion. If we terminate or suspend your account for any reason, you are prohibited from registering and creating a new account under your name, a fake or a borrowed name, or the name of any third party, even if you may be acting on behalf of your principal or other third party.\n\n11.3. Our Right to Seek Redress for your Breach. If we determine that your use of the Site in any way breaches these Terms of Use, violates any applicable law or regulation, poses a security risk to our Site or any third party, or potentially subjects us or our affiliates to any third-party liability, then we also reserve the right to take appropriate legal action against you, including but not limited to pursuing civil, criminal, and injunctive redress, if and as applicable. We may investigate and prosecute violations of these Terms of Use to the fullest extent permitted by law. We may also notify and cooperate with law enforcement or other competent authorities in prosecuting violations of law or these Terms of Use.\n\n11.4. Survival. Upon any termination of these Terms of Use under this Section 11, all provisions of these Terms of Use and its incorporated documents that by their nature should survive termination (including but not limited to Section 4 and Section 8 through 13) will survive and remain in full force and effect.\n\n12. Miscellaneous\n\n12.1. Your consent to Electronic Communications. Visiting any component of the Site, sending us emails, and completing online forms are all considered forms of electronic communication. You consent to receiving electronically all notices, disclosures, agreements, and other communications from us concerning your use of the Site and your rights and obligations under these Terms of Use, and you agree that any means of electronic communication satisfies any legal requirement that our communication to you be in writing. To the extent permitted by law, you waive any rights or requirements under any statutes, regulations, rules, ordinances, or other laws in any jurisdiction that may require an original signature or delivery or retention of non-electronic records, or for delivery of payments or electronic credits.\n\n12.2. No Waiver. Our failure to exercise or enforce any right or provision of these Terms and Conditions shall not operate as a waiver of such right or provision.\n\n12.3. Our Right to Assignment. We may assign any or all our rights and obligations under these Terms and Conditions to any other person or persons at any time.\n\n12.4. Severability. If any provision of these Terms of Use is deemed unlawful, void, or unenforceable by a court or tribunal of competent jurisdiction, then that provision is deemed severable from these Terms of Use and does not affect the validity and enforceability of the remaining provisions.\n\n12.5. No Partnership. There is no joint venture, partnership, employment, or agency relationship created between us and you as a result of these Terms of Use or your use of any part of the Site.\n\n12.6. Choice of Law. All matters relating to the Site and these Terms of Use and any dispute or claim arising therefrom or related thereto (in each case, including non-contractual disputes or claims), shall be governed by and construed in accordance with the laws of the Cayman Islands without giving effect to any choice or conflict of law provision or rule (whether of the Cayman Islands or any other jurisdiction).\n\n12.7. Enforcing Your Rights or Providing Notice. A person who is not a party to these Terms of Use will have no right to enforce any of these Terms of Use against us. To resolve a complaint regarding your use of the Site, or to receive further information regarding its use, please contact us using the contact details provided in clause 1.3.\n\n12.8. Interpretation of Headings and Text. Section and clause headings used in these Terms of Use, and as they may be used in any other documents incorporated as part of these Terms of Use, are for ease of reference only. Headings are not binding and should not be interpreted together with the substantive provisions of these Terms of Use or any incorporated documents. Additionally, where the text of any provisions of or documents incorporated as part of these Terms of Use is bolded, you understand and agree that this text provides you with conspicuous notice and satisfies any legal requirement that notices, disclosures, or provisions be written in all capital letters.\n\n13. Dispute Resolution and Arbitration\n\n13.1. Agreement to Arbitration. You and aelf both understand and agree that any claim or dispute arising under these Terms of Use or your relationship with aelf (past, present, or future) will be finally settled exclusively by binding arbitration in accordance with the United Nation’s UNCITRAL Arbitration Rules (at https://uncitral.un.org/en/texts/arbitration/contractualtexts/arbitration), which are incorporated into these Terms of Use by reference.\n\n13.2. Pre-Arbitration Procedures. You and aelf mutually agree to attempt to resolve all disputes using good-faith and strive for a prompt, low-cost, and mutually beneficial outcome. Therefore, a party who intends to seek arbitration must first send to the other party a written Notice of Dispute (a “Dispute Notice”). Any Dispute Notice to aelf must be sent here, and any Dispute Notice we send to you will be sent to the email address registered with your account or otherwise associated with your use of the Site and agreement to these Terms and Conditions. Dispute Notices must include each of the following: (a) the contact details of the party providing the Dispute Notice; (b) a description of the nature and basis of the claim or dispute; (c) an explanation of the specific relief sought, including the total damages sought, if any, and the basis for the damage calculations; (d) a signed statement from the party providing the Dispute Notice verifying the accuracy of its contents; and (e) if the dispute is from you and you have retained an attorney, then a signed statement from you authorising aelf to disclose your account details to your attorney if necessary in resolving your claim or dispute. If an agreement is not reached to resolve a claim within 60 days after a notice of demand is received, then either party may commence an arbitration proceeding; except that, if either you or aelf send the other an incomplete Dispute Notice, the 60-day period begins tolling only after a complete Dispute Notice is received. Additionally, if either you or aelf request a telephone discussion, the 60-day period begins tolling only after the discussion has occurred. The statute of limitations and any filing fee deadlines will be tolled while the parties engage in required informal dispute resolution procedures.\n\n13.3. Arbitration Procedures. Should any dispute proceed to arbitration, you and aelf expressly agree that an arbitrator properly appointed under the UNCITRAL Arbitration Rules may issue all appropriate declaratory and injunctive relief necessary to ensure the arbitration and final settlement of disputes (but only in favour of the individual party seeking relief and only to the extent necessary to provide relief warranted by that party’s individual claim). You and aelf agree to keep any arbitration strictly confidential. The properly appointed arbitrator will have the authority to order any remedies, legal or equitable, that a party could obtain from a court of competent jurisdiction in an individual case based on the claims asserted, and nothing more.\n\nPlatform\nTechnology\nAudit Report\nPrivacy\nTerms of Use\nCookie Policy\nDeveloper Resources\nQuick Start\nLearn\nDocs\nTools\nResources\nEcosystem\nOverview\ndApps\naelf Ventures\nBlog\nConnect\nContact Us\nCopyright © 2024 aelf"
    },
    {
      "title": "AELF Docs",
      "url": "https://docs.aelf.com/legal/privacy-policy/",
      "html": "Skip to main content\nQuick Start\nLearn\nDocs\nTools\nResources\nBlog\nSearch\nPrivacy Policy\n\nLast updated: 25 June 2024\n\nThis privacy policy (\"Privacy Policy\") elucidates the procedures by which Aelf Pte Ltd(\"Aelf\", \"our\", \"Company\", \"we\", or \"us\") gathers, employs, and divulges information about you.\n\nWe reserve the right to modify this Privacy Policy periodically. Should alterations occur, we will notify you by amending the date at the top of this policy. Additionally, in certain instances, we may provide further notification, such as appending a statement to our Website or dispatching a notification to you. We encourage you to regularly review this Privacy Policy to remain informed about our information procedures and the choices at your disposal.\n\nWe are committed to protecting your personal information and your right to privacy. If you have any questions or concerns about this privacy policy or our practices with regard to your personal information, please contact us here.\n\n1. Our Role In Your Privacy\n\nThis Privacy Policy is applicable to you if you:\n\n- visit our website at https://www.aelf.com (the \"Website\"); or\n\n- engage with us in other related ways ― including any sales, marketing, or events.\n\nIn this privacy policy, if we refer to:\n\n- “Website,” we are referring to any website of ours that references or links to this privacy policy.\n\n- “Services,” we are referring to our Website, and other related services, including any sales, marketing, or events.\n\nThe purpose of this Privacy Policy is to explain to you in the clearest way possible what information we collect, how we use it, how we share the information on a need-be basis and what rights you have in relation to it. If there are any terms in this Privacy Policy that you do not agree with, please discontinue use of our Services immediately.\n\nPlease read this Privacy Policy carefully, as it will help you understand what we do with the information that we collect.\n\n2. Your Responsibilities\n\n- Read this privacy policy\n\n- If you provide us with personal information about other people, or if others give us your information, we will only use that information for the specific reason for which it was provided to us. By submitting the information you confirm that you have the right to authorise us to process it on our behalf in accordance with this privacy policy.\n\n3. Collection of Information\n\nInformation you provide to us: We gather information either directly or indirectly from you when you interact with us or other sources connected to us. This may include filling out forms, making purchases, communicating with us via third-party platforms, participating in contests or promotions, seeking customer support, or engaging in other forms of communication. The personal information we collect may encompass your name, email address, postal address, phone number, credit card details, and any additional information you choose to share.\n\nGeneral Information we collect from you:\n\n- a. Personal information you disclose to us\n\n- We collect personal information that you voluntarily provide to us when you express an interest in obtaining information about us or our products and Services, when you participate in activities on the Website or otherwise when you contact us.\n\n- The personal information that we collect depends on the context of your interactions with us and the Website, the choices you make and the products, Services, and features you use. The personal information we collect may include the following:\n\n- Contact details – We may collect names; phone numbers; email addresses; mailing addresses; contact preferences; and other similar information.\n\nAll personal information that you provide to us must be true, complete and accurate, and you must notify us of any changes to such personal information.\n\n- b. Information we collect automatically when you interact with us:\n\nUpon accessing our Website or engaging in transactions with us, certain information is automatically collected, including:\n\n- Transactional Information: Details pertaining to purchases or returns, such as product specifications, purchase prices, and transaction dates and locations, are collected.\n\n- Device and Usage Information: We gather data regarding how you access our Website, encompassing information about your IP address, browser and device characteristics, operating system, language preferences, referring URLs, device name, information about your activity in the Website (such as the date/time stamps associated with your usage, pages and files viewed, searches and other actions you take such as which features you use) and device event information (such as system activity, error reports (sometimes called ‘crash dumps’) and hardware settings).\n\n- Location Information: Subject to your device permissions, we may collect precise location data such as, but not limited to the country, location, information about how and when you use our Website and other technical information such as device and application identification numbers, location, browser type, hardware model Internet service provider and/or mobile carrier, operating system and system configuration information. For example, we may use GPS and other technologies to collect geolocation data that tells us your current location (based on your IP address). You can opt out of allowing us to collect this information either by refusing access to the information or by disabling your ‘location setting’ on your device. Note however, if you choose to opt out, you may not be able to use certain aspects of the Services. You have the option to cease the collection of precise location information at any time (refer to the \"Your Rights and Choices\" section below for further details).\n\n- This information is primarily needed to maintain the security and operation of our Website, and for our internal analytics and reporting purposes.\n\n- c. Information we collect from other sources: We may obtain information about you from third-party sources, such as identity verification services, data analytics providers, and mailing list providers (if applicable).\n\n4. Use of Information\n\nWe use personal information collected via our Website for a variety of business purposes described below. We process your personal information for these purposes in reliance on our legitimate business interests, in order to enter into or perform a contract with you, with your consent, and/or for compliance with our legal obligations. We indicate the specific processing grounds we rely on next to each purpose listed below.\n\nWe may use your information which we collect or receive for the purposes set out below:\n\n- To send administrative information to you – to send you product, service and new feature information and/or information about changes to our terms, conditions, and policies.\n\n- To protect our Services – as part of our efforts to keep our Website safe and secure (for example, for fraud monitoring and prevention).\n\n- To enforce our terms, conditions and policies – for business purposes, to comply with legal and regulatory requirements or in connection with our contract.\n\n- To respond to legal requests and prevent harm – If we receive a subpoena or other legal request, we may need to inspect the data we hold to determine how to respond.\n\n- Fulfill and manage your orders – to fulfill and manage your orders, payments, returns, and exchanges made through the Website.\n\n- Administer prize draws and competitions – to administer prize draws and competitions when you elect to participate in our competitions.\n\n- To deliver and facilitate delivery of services to the user – to provide you with the requested service.\n\n- To respond to user inquiries/offer support to users – to respond to your inquiries and solve any potential issues you might have with the use of our Services.\n\n- To send you marketing and promotional communications – We and/or our third-party marketing partners may use the personal information you send to us for our marketing purposes, provided this is in accordance with your marketing preferences. For example, when expressing an interest in obtaining information about us or our Website, subscribing to marketing or otherwise contacting us, we will collect personal information from you. You can opt-out of our marketing emails at any time.\n\n- Deliver targeted advertising to you – to develop and display personalized content and advertising (and work with third parties who do so) tailored to your interests and/or location and to measure its effectiveness\n\n- Responding to Job Applications – to respond to an employment or independent contractor application you may have submitted with aelf.\n\n5. Sharing of Information\n\nWe may process or share your information under the following circumstances or as otherwise outlined in this Privacy Policy:\n\n- Consent – if you have given us specific consent to use your personal information for a specific purpose.\n\n- Legitimate Interests – when it is reasonably necessary to achieve our legitimate business interests.\n\n- Performance of a Contract – Where we have entered into a contract with you, we may process your personal information to fulfill the terms of our contract.\n\n- Legal Obligations – where we are legally required to do so in order to comply with applicable law, governmental requests, a judicial proceeding, court order, or legal process, such as in response to a court order or a subpoena (including in response to public authorities to meet national security or law enforcement requirements).\n\n- Vital Interests – where we believe it is necessary to investigate, prevent, or take action regarding potential violations of our policies, suspected fraud, situations involving potential threats to the safety of any person and illegal activities, or as evidence in litigation in which we are involved.\n\nMore specifically, we may need to process your information or share your personal information in the following situations:\n\n- Business Transfers – We may share or transfer your information in connection with, or during negotiations of, any merger, sale of company assets, financing, or acquisition of all or a portion of our business to another company.\n\n- Vendors, Consultants, and Other Third-Party Service Providers – We may share your data with third-party vendors, service providers, contractors or agents who perform services for us or on our behalf and require access to such information to do that work. Examples include: payment processing, data analysis, email delivery, hosting services, customer service and marketing efforts. We may allow selected third parties to use tracking technology on the Website, which will enable them to collect data on our behalf about how you interact with our Website over time. This information may be used to, among other things, analyse and track data, determine the popularity of certain content, pages or features, and better understand online activity. Unless described in this privacy policy , we do not share, sell, rent or trade any of your information with third parties for their promotional purposes.\n\n- Affiliates – We may share your information with our affiliates, in which case we will require those affiliates to honour this privacy policy. Affiliates include our parent company and any subsidiaries, joint venture partners or other companies that we control or that are under common control with us.\n\n- Business Partners – We may share your information with our business partners to offer you certain products, services, or promotions.\n\n6. Who Will Your Information Be Shared With?\n\nWe only share and disclose your information with the following categories of third parties. If we have processed your data based on your consent and you wish to revoke your consent, please contact us using the contact details provided in section 14 below.\n\n- Data Analytics Service Providers\n\n- Data Storage Service Providers\n\n- Cloud Computing Service Providers\n\n- Communication & Collaboration Tools\n\n- Performance Monitoring Tools\n\n- Product Engineering & Design Tools\n\n- Social Networks\n\n- Sales & Marketing Tools\n\n- Testing Tools\n\n- Website Hosting Service Providers\n\n7. Use Cookies And Other Tracking Technologies?\n\nWe do not use cookies or tracking technologies. Rather, we utilise anonymous page view tracking information provided by third-party analytics providers which do not collect or store any personal data. As such, we make no use of cookies.\n\n8. Transfer of Information to Other Jurisdictions\n\nAelf operates and engages service providers in various jurisdictions. Therefore, we and our service providers may transfer your personal information to, or store or access it in, jurisdictions that may not provide levels of data protection that are equivalent to those of your home jurisdiction. By using our Website, you acknowledge and agree to such transfers and processing, including to and in the United States. We will take steps to ensure that your personal information receives an adequate level of protection in the jurisdictions in which we process it.\n\nIf you are a resident in the European Economic Area (EEA) or United Kingdom (UK), then these countries may not necessarily have data protection laws or other similar laws as comprehensive as those in your country. We will however take all necessary measures to protect your personal information in accordance with this privacy policy and applicable laws.\n\n- European Commission’s Standard Contractual ClauseWe have implemented measures to protect your personal information, including by using the European Commission’s Standard Contractual Clauses for transfers of personal information between our group companies and between us and our third-party providers. These clauses require all recipients to protect all personal information that they process originating from the EEA or UK in accordance with European data protection laws and regulations. Our Standard Contractual Clauses can be provided upon request. We have implemented similar appropriate safeguards with our third-party service providers and partners and further details can be provided upon request.\n\n9. Duration of Storage of Information\n\nWe will only keep your personal information for as long as it is necessary for the purposes set out in this Privacy Policy, unless a longer retention period is required or permitted by law (such as tax, accounting or other legal requirements). No purpose in this Privacy Policy will require us keeping your personal information for longer than 2 years.\n\nWhen we have no ongoing legitimate business need to process your personal information, we will either delete or anonymize such information, or, if this is not possible (for example, because your personal information has been stored in backup archives), then we will securely store your personal information and isolate it from any further processing until deletion is possible.\n\n10. Maintaining security of the Information\n\nWe have implemented appropriate technical and organizational security measures designed to protect the security of any personal information we collect and process.\n\nHowever, please remember:\n\n- Despite our safeguards and efforts to secure your information, unfortunately no electronic transmission over the Internet or information storage technology can be guaranteed to be 100% secure, so we cannot promise or guarantee that hackers, cybercriminals, or other unauthorized third parties will not be able to defeat our security, and improperly collect, access, steal, or modify your information.\n\n- Transmission of personal information to and from our Website is at your own risk. You should only access the Website within a secure environment.\n\n- You are responsible for your username and password and should keep them safe.\n\n- If you believe your privacy has been breached, please contact us immediately here.\n\n11. Your Rights and Choices\n\nIn some regions (like the EEA and UK), you have certain rights under applicable data protection laws. These may include the right to :\n\n- Request access and obtain a copy of your personal information.\n\n- Request rectification or erasure.\n\n- Restrict the processing of your personal information and, if applicable, to data portability.\n\n- In certain circumstances, you may also have the right to object to the processing of your personal information.\n\n- If we are relying on your consent to process your personal information, you have the right to withdraw your consent at any time. Please note however that this will not affect the lawfulness of the processing before its withdrawal, nor will it affect the processing of your personal information conducted in reliance on lawful processing grounds other than consent.\n\n12. Controls For Do-not-track Features\n\nMost web browsers and some mobile operating systems and mobile applications include a Do-Not-Track (“DNT”) feature or setting you can activate to signal your privacy preference not to have data about your online browsing activities monitored and collected. At this stage no uniform technology standard for recognizing and implementing DNT signals has been finalized. As such, we do not currently respond to DNT browser signals or any other mechanism that automatically communicates your choice not to be tracked online. If a standard for online tracking is adopted that we must follow in the future, we will inform you about that practice in a revised version of this privacy policy.\n\n13. Changes To This Privacy Policy\n\nWe may update this Privacy Policy from time to time. The updated version will be indicated by an updated “Revised” date and the updated version will be effective as soon as it is accessible. If we make material changes to this privacy policy, we may notify you either by prominently posting a notice of such changes or by directly sending you a notification. We encourage you to review this Privacy Policy frequently to be informed of how we are protecting your information.\n\n14. Contact Us\n\nIf you have questions or comments about this privacy policy, you may email us here.\n\n15. How Can You Review, Update, Or Delete The Data We Collect From You?\n\nBased on the applicable laws of your country, you may have the right to request access to the personal information we collect from you, change that information, have any inaccurate information corrected or delete it in some circumstances. To request to review, update, or delete your personal information, please contact us on the above provided details.\n\nPlatform\nTechnology\nAudit Report\nPrivacy\nTerms of Use\nCookie Policy\nDeveloper Resources\nQuick Start\nLearn\nDocs\nTools\nResources\nEcosystem\nOverview\ndApps\naelf Ventures\nBlog\nConnect\nContact Us\nCopyright © 2024 aelf"
    },
    {
      "title": "Whitepapers | AELF Docs",
      "url": "https://docs.aelf.com/resources/whitepaper/",
      "html": "Skip to main content\nQuick Start\nLearn\nDocs\nTools\nResources\nBlog\nSearch\nResources\nIntegration Guide\nWallet and Block Explorer\nAetherLink\nBrowser Extension\nDevOps\nProtobuf Extension\nWhitepapers\nResourcesWhitepapers\nWhitepapers\nInfrastructure​\n\nTo learn more about aelf infrastructure, please refer to aelf Whitepaper.\n\nGovernance​\n\nTo learn more about aelf governance, please refer to aelf Economic and Governance Whitepaper.\n\nPrevious\nProtobuf Extension\nInfrastructure\nGovernance\nPlatform\nTechnology\nAudit Report\nPrivacy\nTerms of Use\nCookie Policy\nDeveloper Resources\nQuick Start\nLearn\nDocs\nTools\nResources\nEcosystem\nOverview\ndApps\naelf Ventures\nBlog\nConnect\nContact Us\nCopyright © 2024 aelf"
    },
    {
      "title": "Protobuf Extension | AELF Docs",
      "url": "https://docs.aelf.com/resources/protobuf-extension/",
      "html": "Skip to main content\nQuick Start\nLearn\nDocs\nTools\nResources\nBlog\nSearch\nResources\nIntegration Guide\nWallet and Block Explorer\nAetherLink\nBrowser Extension\nDevOps\nProtobuf Extension\nWhitepapers\nResourcesProtobuf Extension\nProtobuf Extension\n1. Introduction​\n\nIn the aelf blockchain development environment, the initial step involves defining interfaces using protobuf. This structured approach ensures clarity in communication between different components of the system. To streamline and validate the protobuf syntax during development, users can take advantage of the protobuf extension available for Visual Studio Code (VSCode).\n\nThe protobuf extension for VSCode offers several benefits. Firstly, it provides syntax highlighting and autocompletion features, significantly reducing the chances of syntax errors. This real-time assistance promotes code accuracy and helps developers catch mistakes early in the development process.\n\nAdditionally, the extension facilitates the understanding of complex protobuf structures by offering a convenient way to navigate through different message types and their fields. This not only enhances code readability but also accelerates the development workflow.\n\nMoreover, the protobuf extension integrates with the overall development environment in VSCode, allowing users to leverage the platform's debugging capabilities for protobuf-related code. This integration contributes to a more seamless and efficient development experience.\n\nBy incorporating the protobuf extension into their workflow, aelf developers can ensure the correctness of their protobuf definitions, enhance code quality, and ultimately accelerate the development lifecycle.\n\n2. How to Install​\nOpen Visual Studio Code.\nNavigate to the Extensions view by clicking on the Extensions icon in the Activity Bar on the side of the window or using the keyboard shortcut Ctrl+Shift+X.\nIn the Extensions view, search for \"protobuf support\" in the search bar.\nLook for the extension with the title \"protobuf support\" and select it from the search results.\nClick the \"Install\" button to install the extension.\nOnce the installation is complete, you may need to restart VSCode to activate the extension.\n\nNow, you should have \"protobuf support\" installed and ready to use in your VSCode environment. This extension provides valuable features such as syntax highlighting, autocompletion, and other helpful tools to enhance your protobuf development experience.\n\nPrevious\nDevOps\nNext\nWhitepapers\n1. Introduction\n2. How to Install\nPlatform\nTechnology\nAudit Report\nPrivacy\nTerms of Use\nCookie Policy\nDeveloper Resources\nQuick Start\nLearn\nDocs\nTools\nResources\nEcosystem\nOverview\ndApps\naelf Ventures\nBlog\nConnect\nContact Us\nCopyright © 2024 aelf"
    },
    {
      "title": "DevOps | AELF Docs",
      "url": "https://docs.aelf.com/resources/devops/",
      "html": "Skip to main content\nQuick Start\nLearn\nDocs\nTools\nResources\nBlog\nSearch\nResources\nIntegration Guide\nWallet and Block Explorer\nAetherLink\nBrowser Extension\nDevOps\nProtobuf Extension\nWhitepapers\nResourcesDevOps\nDevOps\nOpen Source Development​\n\nAt aelf, we prioritize openness and transparency in our development process. Our project is fully open source, and we share our code and current issues online. This approach helps keep our project accessible to everyone.\n\nCollaborative Standard​\n\nWe value collaboration and welcome contributions and feedback. However, to maintain high standards, we ask all collaborators to follow these guidelines:\n\nUnderstand aelf: Before contributing, read our white paper and documentation to understand the core concepts and architecture. Reviewing our code and existing functionalities is also recommended.\nAsk Questions: If you have any questions, open an issue on GitHub. Clearly state what you need to clarify.\nSubmit Pull Requests: When you're ready to contribute, submit a pull request on GitHub. Our core team will review and discuss your submission. If approved, it will be merged into the project.\n\nFor more details, please refer to our Code of Conduct.\n\nDeployment​\n\nWe use the semantic versioning system (SemVer) for version control. For more information, visit SemVer.\n\nDaily Builds​\n\nWe have a cron job integrated with GitHub that publishes the latest version of our development packages to MyGet. You can find them here:\n\nMyGet: aelf-project-dev\nRelease Branch​\n\nFor stable releases, our packages are available on NuGet:\n\nNuGet: AElf\nTesting​\n\nTesting is crucial for maintaining and improving software quality. We focus on two main types of testing: unit testing and performance testing.\n\nUnit Testing​\n\nUnit tests ensure the functionality and protocol integrity of our blockchain system. We use the xUnit framework and follow best practices to cover as much functionality as possible. For any new feature, we ensure it is covered by unit tests to prevent regressions and allow safe modifications.\n\nPerformance Testing​\n\nPerformance testing is vital for aelf, as speed is one of our system's key strengths. These tests help ensure that changes do not negatively impact the transaction and block processing speed of our nodes.\n\nMonitoring​\nServer Monitoring​\n\nWe use Zabbix to monitor server metrics such as CPU usage and database performance.\n\nChain Monitoring​\n\nOur GitHub project includes a Grafana dashboard powered by InfluxDB for chain monitoring.\n\nAkka Monitoring​\n\nWe monitor actors in our system using Akka.\n\nPrevious\nBrowser Extension\nNext\nProtobuf Extension\nOpen Source Development\nCollaborative Standard\nDeployment\nDaily Builds\nRelease Branch\nTesting\nUnit Testing\nPerformance Testing\nMonitoring\nServer Monitoring\nChain Monitoring\nAkka Monitoring\nPlatform\nTechnology\nAudit Report\nPrivacy\nTerms of Use\nCookie Policy\nDeveloper Resources\nQuick Start\nLearn\nDocs\nTools\nResources\nEcosystem\nOverview\ndApps\naelf Ventures\nBlog\nConnect\nContact Us\nCopyright © 2024 aelf"
    },
    {
      "title": "AELF Docs",
      "url": "https://docs.aelf.com/resources/browser-extension/",
      "html": "Skip to main content\nQuick Start\nLearn\nDocs\nTools\nResources\nBlog\nSearch\nResources\nIntegration Guide\nWallet and Block Explorer\nAetherLink\nBrowser Extension\nDevOps\nProtobuf Extension\nWhitepapers\nResourcesBrowser Extension\naelf-web-extension\nIntroduction​\n\naelf Web Extension provides an interface for DApp developers to interact with the aelf blockchain. This guide outlines the usage and implementation details for both users and developers.\n\nFor Users​\nRelease Version​\n\nPlease wait for the official release.\n\nDevelopment Version​\n\ndev version For those using QQ Browser and similar, you can add the extension manually.\n\nNotice​\nNote: Using File:/// protocol may can not use the extenstion //. You must opt in to file access for each extension that requests it. For more details, visit the Chrome Developer Documentation.\nFor DApp Developers​\nInteraction Flow​\nEnsure the user has installed the extension.\nConnect to the blockchain.\nInitialize the contract.\nCall contract methods.\nHow to Use​\n\nTo access the complete data structure, click here. For an extension demo, refer to the provided examples.\n\nCheck Extension Demo\nGET_CHAIN_STATUS\nCALL_AELF_CHAIN\nLOGIN\nINIT_AELF_CONTRACT\nCALL_AELF_CONTRACT / CALL_AELF_CONTRACT_READONLY\nCHECK_PERMISSION\nSET_CONTRACT_PERMISSION\nREMOVE_METHODS_WHITELIST\nData Format​\n{\n  \"histories\": [],\n  \"keychain\": {\n    \"keypairs\": [\n      {\n        \"name\": \"your keypairs name\",\n        \"address\": \"your keypairs address\",\n        \"mnemonic\": \"your keypairs mnemonic\",\n        \"privateKey\": \"your keypairs privateKey\",\n        \"publicKey\": {\n          \"x\": \"your keypairs publicKey\",\n          \"y\": \"your keypairs publicKey\"\n        }\n      }\n    ],\n    \"permissions\": [\n      {\n        \"chainId\": \"AELF\",\n        \"contractAddress\": \"contract address\",\n        \"contractName\": \"contract name\",\n        \"description\": \"contract description\",\n        \"github\": \"contract github\",\n        \"whitelist\": {\n          \"Approve\": {\n            \"parameter1\": \"a\",\n            \"parameter2\": \"b\",\n            \"parameter3\": \"c\"\n          }\n        }\n      }\n    ]\n  }\n}\n\nDemo of Checking the Extension​\nlet nightElfInstance = null;\n\nclass NightElfCheck {\n  constructor() {\n    const readyMessage = 'NightElf is ready';\n    let resolveTemp = null;\n    this.check = new Promise((resolve, reject) => {\n      if (window.NightElf) {\n        resolve(readyMessage);\n      }\n      setTimeout(() => {\n        reject({\n          error: 200001,\n          message: 'timeout / cannot find NightElf / please install the extension'\n        });\n      }, 1000);\n      resolveTemp = resolve;\n    });\n    document.addEventListener('NightElf', result => {\n      console.log('Checking the status of extension named NightElf: ', result);\n      resolveTemp(readyMessage);\n    });\n  }\n\n  static getInstance() {\n    if (!nightElfInstance) {\n      nightElfInstance = new NightElfCheck();\n      return nightElfInstance;\n    }\n    return nightElfInstance;\n  }\n}\n\nconst nightElfCheck = NightElfCheck.getInstance();\nnightElfCheck.check.then(message => {\n  // connectChain -> Login -> initContract -> call contract methods\n});\n\nGET_CHAIN_STATUS​\n\nYou can see the demo ./devDemos/test.html. [demo.js just a draft]\n\nToken Transfer​\n\nIf you want to check Token Transfer Demo. You can Click Here\n\nThe methods calls act the same as the methods call of the aelf-sdk.js\n\nNote: ... stands for omitted data.\n\nconst aelf = new window.NightElf.AElf({\n  httpProvider: ['http://192.168.197.56:8101/chain'],\n  appName: 'Test'\n});\n\naelf.chain.getChainStatus((error, result) => {\n  console.log('Chain Status:', error, result);\n});\n\nExpected Result :​\nresult = {\n     ChainId: \"AELF\"\n     GenesisContractAddress: \"61W3AF3Voud7cLY2mejzRuZ4WEN8mrDMioA9kZv3H8taKxF\"\n}\n\nCALL_AELF_CHAIN​\n\nExample of retrieving a transaction result:\n\nconst txid = 'c45edfcca86f4f528cd8e30634fa4ac53801aae05365cfefc3bfe9b652fe5768';\naelf.chain.getTxResult(txid, (err, result) => {\n  console.log('Transaction Result:', err, result);\n});\n\nExpected Result :​\n result = {\n     Status: \"NotExisted\"\n     TransactionId: \"ff5bcd126f9b7f22bbfd0816324390776f10ccb3fe0690efc84c5fcf6bdd3fc6\"\n }\n\nLOGIN​\n\nExample login call:\n\naelf.login({\n  appName: 'hzzTest',\n  chainId: 'AELF',\n  payload: {\n    method: 'LOGIN',\n    contracts: [\n      {\n        chainId: 'AELF',\n        contractAddress: '4rkKQpsRFt1nU6weAHuJ6CfQDqo6dxruU3K3wNUFr6ZwZYc',\n        contractName: 'token',\n        description: 'token contract',\n        github: ''\n      },\n      {\n        chainId: 'AELF TEST',\n        contractAddress: '2Xg2HKh8vusnFMQsHCXW1q3vys5JxG5ZnjiGwNDLrrpb9Mb',\n        contractName: 'TEST contractName',\n        description: 'contract description',\n        github: ''\n      }\n    ]\n  }\n}, (error, result) => {\n  console.log('Login Result:', result);\n});\n\n// keychain = {\n//     keypairs: [{\n//         name: 'your keypairs name',\n//         address: 'your keypairs address',\n//         mnemonic: 'your keypairs mnemonic',\n//         privateKey: 'your keypairs privateKey'，\n//         publicKey: {\n//             x: 'f79c25eb......',\n//             y: '7fa959ed......'\n//         }\n//     }],\n//     permissions: [{\n//         appName: 'hzzTest',\n//         address: 'your keyparis address',\n//         contracts: [{\n//             chainId: 'AELF',\n//             contractAddress: '4rkKQpsRFt1nU6weAHuJ6CfQDqo6dxruU3K3wNUFr6ZwZYc',\n//             contractName: 'token',\n//             description: 'token contract',\n//             github: ''\n//         }],\n//         domain: 'Dapp domain'\n//     }]\n// }\n\nINIT_AELF_CONTRACT​\n\nExample of initializing a contract:\n\n// In aelf-sdk.js wallet is the realy wallet.\n// But in extension sdk, we just need the address of the wallet.\nconst tokenContract;\nconst wallet = {\n    address: '2JqnxvDiMNzbSgme2oxpqUFpUYfMjTpNBGCLP2CsWjpbHdu'\n};\n// It is different from the wallet created by Aelf.wallet.getWalletByPrivateKey();\n// There is only one value named address;\naelf.chain.contractAtAsync(\n    '4rkKQpsRFt1nU6weAHuJ6CfQDqo6dxruU3K3wNUFr6ZwZYc',\n    wallet,\n    (error, result) => {\n        console.log('>>>>>>>>>>>>> contractAtAsync >>>>>>>>>>>>>');\n        console.log(error, result);\n        tokenContract = result;\n    }\n);\n\nExpected Result :​\n result = {\n    Approve: ƒ (),\n     Burn: ƒ (),\n     ChargeTransactionFees: ƒ (),\n     ClaimTransactionFees: ƒ (),\n     ....\n }\n\nCALL_AELF_CONTRACT / CALL_AELF_CONTRACT_READONLY​\n\nExample contract method calls:\n\ntokenContract.GetBalance.call(\n  { symbol: 'AELF', owner: '65dDNxzcd35jESiidFXN5JV8Z7pCwaFnepuYQToNefSgqk9' },\n  (err, result) => {\n    console.log('Get Balance Result:', result);\n  }\n);\n\ntokenContract.Approve(\n  { symbol: 'AELF', spender: '4rkKQpsRFt1nU6weAHuJ6CfQDqo6dxruU3K3wNUFr6ZwZYc', amount: '100' },\n  (err, result) => {\n    console.log('Approve Result:', result);\n  }\n);\n\n// If you use tokenContract.GetBalance.call  this method is only applicable to queries that do not require extended authorization validation.(CALL_AELF_CONTRACT_READONLY)\n// If you use tokenContract.Approve this requires extended authorization validation (CALL_AELF_CONTRACT)\n\n// tokenContract.GetBalance.call(payload, (error, result) => {})\n// result = {\n//     symbol: \"AELF\",\n//     owner: \"65dDNxzcd35jESiidFXN5JV8Z7pCwaFnepuYQToNefSgqk9\",\n//     balance: 0\n// }\n\nCHECK_PERMISSION​\n\nExample permission check:\n\naelf.checkPermission({\n  appName: 'hzzTest',\n  type: 'address',\n  address: '4WBgSL2fSem9ABD4LLZBpwP8eEymVSS1AyTBCqXjt5cfxXK'\n}, (error, result) => {\n  console.log('Check Permission Result:', result);\n});\n\nExpected Result :​\n\n result = {\n     ...,\n     permissions:[\n         {\n             address: '...',\n             appName: 'hzzTest',\n             contracts: [{\n                 chainId: 'AELF',\n                 contractAddress: '4rkKQpsRFt1nU6weAHuJ6CfQDqo6dxruU3K3wNUFr6ZwZYc',\n                 contractName: 'token',\n                 description: 'token contract',\n                 github: ''\n             },\n             {\n                 chainId: 'AELF TEST',\n                 contractAddress: 'TEST contractAddress',\n                 contractName: 'TEST contractName',\n                 description: 'contract description',\n                 github: ''\n             }],\n             domian: 'Dapp domain'\n         }\n     ]\n }\n\nSET_CONTRACT_PERMISSION​\n\nExample of removing methods whitelist:\n\naelf.removeContractPermission({\n    appName: 'hzzTest',\n    chainId: 'AELF',\n    payload: {\n        contractAddress: '2Xg2HKh8vusnFMQsHCXW1q3vys5JxG5ZnjiGwNDLrrpb9Mb'\n    }\n}, (error, result) => {\n    console.log('removeContractPermission>>>>>>>>>>>>>>>>>>>', result);\n});\n\nExpected Result​\n keychain = {\n     keypairs: {...},\n     permissions: [{\n         appName: 'hzzTest',\n         address: 'your keyparis address',\n         contracts: [{\n             chainId: 'AELF',\n             contractAddress: '4rkKQpsRFt1nU6weAHuJ6CfQDqo6dxruU3K3wNUFr6ZwZYc',\n             contractName: 'token',\n     description: 'token contract',\n             github: ''\n         }],\n         domain: 'Dapp domain'\n     }]\n }\n\nREMOVE_METHODS_WHITELIST​\n\nExample of removing contract permission:\n\naelf.removeContractPermission({\n  appName: 'hzzTest',\n  chainId: 'AELF',\n  payload: {\n    contractAddress: '2Xg2HKh8vusnFMQsHCXW1q3vys5JxG5ZnjiGwNDLrrpb9Mb'\n  }\n}, (error, result) => {\n  console.log('Remove Contract Permission Result:', result);\n});\n\nExpected Result​\nkeychain = {\n    keypairs: {...},\n    permissions: [{\n        appName: 'hzzTest',\n        address: 'your keyparis address',\n        contracts: [{\n            chainId: 'AELF',\n            contractAddress: '4rkKQpsRFt1nU6weAHuJ6CfQDqo6dxruU3K3wNUFr6ZwZYc',\n            contractName: 'token',\n            description: 'token contract',\n            github: '',\n            whitelist: {}\n        }],\n        domain: 'Dapp domain'\n    }]\n}\n\nFor Extension Developers​\nDownload the code:\ngit clone https://github.com/hzz780/aelf-web-extension.git\n\nInstall dependencies:\nnpm install\n\nRun webpack:\nwebpack -w\n\nAdd to the browser:\nopen development mode, add the webpack output app/public.\n\nProject Information​\n\nWe use ECDH` to use public key to encryt data and private key to decrypt data.\n\nPrevious\nAetherLink\nNext\nDevOps\nIntroduction\nFor Users\nFor DApp Developers\nHow to Use\nData Format\nDemo of Checking the Extension\nGET_CHAIN_STATUS\nCALL_AELF_CHAIN\nLOGIN\nINIT_AELF_CONTRACT\nCALL_AELF_CONTRACT / CALL_AELF_CONTRACT_READONLY\nCHECK_PERMISSION\nSET_CONTRACT_PERMISSION\nREMOVE_METHODS_WHITELIST\nFor Extension Developers\nProject Information\nPlatform\nTechnology\nAudit Report\nPrivacy\nTerms of Use\nCookie Policy\nDeveloper Resources\nQuick Start\nLearn\nDocs\nTools\nResources\nEcosystem\nOverview\ndApps\naelf Ventures\nBlog\nConnect\nContact Us\nCopyright © 2024 aelf"
    },
    {
      "title": "AELF Docs",
      "url": "https://docs.aelf.com/resources/aetherLink/",
      "html": "Skip to main content\nQuick Start\nLearn\nDocs\nTools\nResources\nBlog\nSearch\nResources\nIntegration Guide\nWallet and Block Explorer\nAetherLink\nBrowser Extension\nDevOps\nProtobuf Extension\nWhitepapers\nResourcesAetherLink\nAetherLink\n1. Introduction​\n\nA web3 oracle is essential for decentralized networks, enabling smart contracts to access real-world data like weather updates or market prices. However, the security of oracles is a concern, as malicious actions can compromise contract execution. Choosing reliable oracle services is crucial in web3 development. Moreover, oracles not only link blockchains to real-world data but also enable the retrieval of information from other blockchain networks.\n\n2. aelf Oracle Services - AetherLink​\n\nAmong the various products in aelf, some products may require information from other chains. For example, the eBridge product needs to access lock-up information of NFTs on the Ethereum chain. This necessitates the use of oracle services for data interchange. To expand the aelf ecosystem and enhance user services, it is essential to establish the foundational services for oracle mechanisms.\n\nIn this context, AetherLink, aelf's proprietary oracle service, has been developed. AetherLink primarily focuses on providing Verified Random Function (VRF) capabilities and Data Feeds functionality.\n\n3. What can AetherLink do?​\nA. Random number generator​\n\nGenerating random numbers directly on the blockchain is a complex and challenging problem. Due to the deterministic nature of blockchain, the results of smart contract executions must be consistent across all nodes in the network. Therefore, random number generation in smart contracts needs to be verifiable and replicable, ensuring that each node obtains the same result when executing the same smart contract.\n\nHowever, traditional pseudo-random number generation methods, such as using block hashes, face challenges in this environment. If block hashes are used, each node in the smart contract would generate the same random number using identical inputs, making it impossible to achieve true randomness.\n\nAetherLink VRF introduces the concept of Verifiable Random Function (VRF), employing algorithms designed by cryptographic experts to ensure that the generated random numbers on-chain are verifiable and unpredictable. AetherLink VRF provides a secure, decentralized, and verifiable mechanism for generating random numbers in smart contracts, delivering high-quality randomness without compromising security and usability.\n\nThe key advantages of using AetherLink VRF include:\n\n1. Verifiability:​\n\nCryptographic proofs are used to demonstrate the authenticity of the random number generation process, allowing smart contracts and users to verify the legitimacy of the generated random numbers.\n\n2. Unpredictability:​\n\nUtilizing VRF algorithms ensures that random numbers generated by AetherLink VRF are unpredictable, even under identical input conditions.\n\n3. Decentralization:​\n\nAetherLink VRF operates across multiple nodes, enhancing the decentralization of random number generation and mitigating risks associated with a single point of control.\n\nRandom number generator code segment\n{\n    var random = State.ConsensusContract.GetRandomHash.Call(new Int64Value\n    {\n        Value = specificData.BlockNumber\n    });\n\n    var alpha = HashHelper.ConcatAndCompute(random, specificData.PreSeed);\n\n    Context.ECVrfVerify(publicKey, alpha.ToByteArray(), report.Result.ToByteArray(), out var beta);\n    Assert(beta != null && beta.Length > 0, \"Vrf verification fail.\");\n\n    var randomHash = Hash.LoadFromByteArray(beta);\n\n    for (var i = 0; i < specificData.NumWords; i++)\n    {\n        response.Data.Add(HashHelper.ConcatAndCompute(randomHash, HashHelper.ComputeFrom(i)));\n    }\n\n    return response;\n}\n\n\nThe process involves obtaining a random hash from the consensus contract, verifying it through ECVRF with a public key and an oracle-reported result, and then creating a set of random words based on the verified data.\n\nB. DataFeeds​\n\nThe AetherLink Data Feeds Coordinator provides a quick and reliable connection for smart contracts to real-world data, encompassing data types like asset prices, reserve balances, NFT floor prices, and L2 sequencer health.\n\nData feeds from the Coordinator include Price Feeds, Proof of Reserve Feeds, NFT Floor Price Feeds, Rate and Volatility Feeds, and L2 Sequencer Uptime Feeds. For example, Price Feeds are crucial for real-time actions in applications like decentralized finance (DeFi) platforms. These feeds aggregate data from multiple sources, ensuring reliability through the Decentralized Data Model and Offchain Reporting.\n\nComponents of a data feed involve the Consumer (onchain or offchain applications using Data Feeds), Coordinator contract (onchain coordinator pointing to the oracle), and Oracle contract (receiving periodic data updates from the oracle network and storing aggregated data onchain).\n\nDifferent data feeds cater to specific use cases, such as Proof of Reserve Feeds indicating the status of reserves, NFT Floor Price Feeds providing the lowest NFT prices, and Rate and Volatility Feeds offering interest rate curve data. L2 sequencer uptime feeds track the last known status of the sequencer on Layer 2 networks.\n\n4. AetherLink Contracts​\n\nTo achieve these functionalities, aelf has deployed 3 main contracts. Their names and their functionalities are:\n\nContract Type\tFunctions and Responsibilities\nConsumer Contract\t1. Task initiation and receipt of results\n2. Result inquiry\nCoordinate Contract\t1. Task management\n2. VRF Proof verification and random number generation\n3. Threshold signature verification\nOracle Contract\t1. Node management\n2. Task event publication\nA. Consumer Contract​\n\nA contract deployed by the user, for which the official interface proto file is provided by the platform for task initiation and result retrieval. Users are required to reference and implement this interface. The main functionalities include:\n\na. Task initiation:​\n\nInitiated by the user, subsequently invoking the Oracle contract to carry out subsequent operations.\n\nb. Result retrieval:​\n\nCallback function executed by the Oracle contract, writing the results back to the user contract. Users are responsible for implementing the logic for data storage.\n\nB. Coordinator Contract​\n\nA contract provided by the platform. Based on the current products, PriceFeeds and VRF, two corresponding Coordinator contracts need to be deployed. The main functionalities include:\n\na. Task management:​\n\nGenerates a unique 1D for tasks along with task details, storing them in the contract.\n\nb. Threshold signature verification (for non-algorithmic verification thresholds) / VRF Proof verification:​\n\nAfter nodes submit task results, if it's a PriceFeeds-type task, the Coordinator contract is responsible for verifying the submitted signatures through threshold signature verification. If it's a VRF-type task, the Coordinator contract needs to reconstruct the random hash from the submitted proof.\n\nC. Oracle Contract​\n\nThe official contract provided decouples Oracle nodes and Consumer contracts from business logic. It has three main functionalities:\n\na. Subscription Feature:​\n\nProvides subscription management functionality for user contracts, enabling task initiation through subscriptions.\n\nb. Node Management Feature:​\n\nImplements the registration and role assignment of Oracle nodes, with configurable parameters for threshold signature.\n\nc. Event-Driven Feature:​\n\nOracle nodes need to listen to events from this contract, triggering corresponding operations when events are emitted.\n\nThe whole project structure:\n\nPrevious\nWallet and Block Explorer\nNext\nBrowser Extension\n1. Introduction\n2. aelf Oracle Services - AetherLink\n3. What can AetherLink do?\nA. Random number generator\nB. DataFeeds\n4. AetherLink Contracts\nA. Consumer Contract\nB. Coordinator Contract\nC. Oracle Contract\nPlatform\nTechnology\nAudit Report\nPrivacy\nTerms of Use\nCookie Policy\nDeveloper Resources\nQuick Start\nLearn\nDocs\nTools\nResources\nEcosystem\nOverview\ndApps\naelf Ventures\nBlog\nConnect\nContact Us\nCopyright © 2024 aelf"
    },
    {
      "title": "AELF Docs",
      "url": "https://docs.aelf.com/resources/wallet-and-block-explorer/",
      "html": "Skip to main content\nQuick Start\nLearn\nDocs\nTools\nResources\nBlog\nSearch\nResources\nIntegration Guide\nWallet and Block Explorer\nAetherLink\nBrowser Extension\nDevOps\nProtobuf Extension\nWhitepapers\nResourcesWallet and Block Explorer\nWallet and Block Explorer\nExplorer​\n\nGithub\n\nOverview\n\nOur blockchain explorer lets you do a lot of things easily. You can view blocks and transactions, buy resources, vote, campaign for node roles, and check out contracts.\n\nFeatures​\nView Blocks and Transactions: Track the latest blocks and transactions on the network.\nPurchase Resources: Buy necessary resources for your operations.\nVoting and Node Campaigning: Participate in network governance by voting and running for node roles.\nView Contracts: Access and review smart contracts.\niOS/Android Wallet​\n\nOverview\n\nThe mobile wallet app for iOS and Android helps you manage your assets and trade across different blockchains. It also offers a platform for developers to integrate their applications using the wallet SDK.\n\nFeatures\n\nBasic Asset Management: Easily manage your digital assets.\nCross-Chain Trading: Trade assets across different blockchains seamlessly.\nDeveloper Platform: Access the wallet SDK to integrate your applications.\nWeb Wallet​\n\nGithub\n\nOverview​\n\nThe web wallet offers basic functionalities for handling transactions right from your browser.\n\nFeatures\n\nTransaction Management: Handle your transactions with ease.\nExplorer API​\n\nTo get more information by code\n\nOur Explorer API allows you to interact with blockchain data. You can get information about blocks, transactions, and TPS (transactions per second). Here’s how you can use it:\n\nBlocks​\nGet Block List​\nURL: api/all/blocks?limit={limit}&page={page}\nMethod: GET\nDescription: Retrieve a list of blocks.\n\nSuccess Response:\n\n{\n    \"total\": 5850,\n    \"blocks\": [\n        {\n            \"block_hash\": \"7e1c2fb6d3cc5e8c2cef7d75de9c1adf0e25e9d17d4f22e543fa20f5f23b20e9\",\n            \"pre_block_hash\": \"6890fa74156b1a88a3ccef1fef72f4f78ff2755ffcd4fb5434ed7b3c153061f5\",\n            \"chain_id\": \"AELF\",\n            \"block_height\": 5719,\n            \"tx_count\": 1,\n            \"merkle_root_tx\": \"47eabbc7a499764d0b25c7216ba75fe39717f9866a0716c8a0d1798e64852d84\",\n            \"merkle_root_state\": \"d14e78dc3c7811b7c17c8b04ebad9e547c35b3faa8bfcc9189b8c12e9f6a4aae\",\n            \"time\": \"2019-04-27T02:00:34.691118Z\"\n        },\n        {\n            \"block_hash\": \"6890fa74156b1a88a3ccef1fef72f4f78ff2755ffcd4fb5434ed7b3c153061f5\",\n            \"pre_block_hash\": \"f1098bd6df58acf74d8877529702dffc444cb401fc8236519606aa9165d945ae\",\n            \"chain_id\": \"AELF\",\n            \"block_height\": 5718,\n            \"tx_count\": 1,\n            \"merkle_root_tx\": \"b29b416148b4fb79060eb80b49bb6ac25a82da2d7a1c5d341e0bf279a7c57362\",\n            \"merkle_root_state\": \"4dbef401f6d9ed303cf1b5e609a64b1c06a7fb77620b9d13b0e4649719e2fe55\",\n            \"time\": \"2019-04-27T02:00:34.691118Z\"\n        },\n        {\n            \"block_hash\": \"f1098bd6df58acf74d8877529702dffc444cb401fc8236519606aa9165d945ae\",\n            \"pre_block_hash\": \"1fbdf3a4fb3c41e9ddf25958715815d9d643dfb39e1aaa94631d197e9b1a94bb\",\n            \"chain_id\": \"AELF\",\n            \"block_height\": 5717,\n            \"tx_count\": 1,\n            \"merkle_root_tx\": \"776abba03d66127927edc6437d406f708b64c1653a1cc22af9c490aa4f0c22dc\",\n            \"merkle_root_state\": \"ccc32ab23d619b2b8e0e9b82a53bb66b3a6d168993188b5d3f7f0ac2cb17206f\",\n            \"time\": \"2019-04-27T02:00:26.690003Z\"\n        }\n    ]\n}\n\nGet Block List By Block Hash​\nURL: api/block/transactions?limit={limit}&page={page}&order={order}&block_hash={block_hash}\nMethod: GET\nDescription: Retrieve a list of blocks using a specific block hash.\n\nSuccess Response:\n\n{\n    \"transactions\": [\n        {\n            \"tx_id\": \"209ceb8ee88eeb2c55db7783c48ec0b1adf6badba89fc7ddb86e968601027cbb\",\n            \"chain_id\": \"AELF\",\n            \"block_height\": 590,\n            \"address_from\": \"csoxW4vTJNT9gdvyWS6W7UqEdkSo9pWyJqBoGSnUHXVnj4ykJ\",\n            \"address_to\": \"2gaQh4uxg6tzyH1ADLoDxvHA14FMpzEiMqsQ6sDG5iHT8cmjp8\",\n            \"method\": \"DeploySmartContract\",\n            \"block_hash\": \"79584a99b7f5da5959a26ff02cbe174d632eb5ef3c6c8d5192de48b6f5584c8d\",\n            \"quantity\": 0,\n            \"tx_status\": \"Mined\",\n            \"time\": \"2019-04-26T06:47:00.265604Z\"\n        },\n        {\n            \"tx_id\": \"d9398736920a5c87ea7cae46c265efa84ac7be4cf8edd37bea54078abef1b44c\",\n            \"params_to\": \"\",\n            \"chain_id\": \"AELF\",\n            \"block_height\": 590,\n            \"address_from\": \"2EyPedNTscFK5EwR8FqTrCeW2LZzuPQ7vr18Y5QWuEUApdCkM6\",\n            \"address_to\": \"xw6U3FRE5H8rU3z8vAgF9ivnWSkxULK5cibdZzMC9UWf7rPJf\",\n            \"params\": \"\",\n            \"method\": \"NextRound\",\n            \"block_hash\": \"79584a99b7f5da5959a26ff02cbe174d632eb5ef3c6c8d5192de48b6f5584c8d\",\n            \"quantity\": 0,\n            \"tx_status\": \"Mined\",\n            \"time\": \"2019-04-26T06:47:00.265604Z\"\n        }\n    ]\n}\n\nTransactions​\nGet Transactions List​\nURL: api/all/transactions?limit={limit}&page={page}\nMethod: GET\nDescription: Retrieve a list of transactions.\n\nSuccess Response:\n\n{\n    \"total\": 1179,\n    \"transactions\": [\n        {\n            \"tx_id\": \"c65d1206e65aaf2e7e08cc818c372ff2c2947cb6cbec746efe6a5e20b7adefa9\",\n            \"chain_id\": \"AELF\",\n            \"block_height\": 1064,\n            \"address_from\": \"grSAEQ5vJ7UfCN2s1v4fJJnk98bu4SHa2hpQkQ9HT88rmaZLz\",\n            \"address_to\": \"xw6U3FRE5H8rU3z8vAgF9ivnWSkxULK5cibdZzMC9UWf7rPJf\",\n            \"method\": \"NextRound\",\n            \"block_hash\": \"8c922b20164ad3774b56d19673154f383ed89656cbd56433d1681c8c3a4dcab9\",\n            \"quantity\": 0,\n            \"tx_status\": \"Mined\",\n            \"time\": \"2019-04-26T07:18:36.636701Z\"\n        },\n        {\n            \"tx_id\": \"4780a7b2737b6f044894719b9bb4cb09862c0b4a7cae267131a0b5c3e7c12850\",\n            \"params_to\": \"\",\n            \"chain_id\": \"AELF\",\n            \"block_height\": 1063,\n            \"address_from\": \"QUYYqzTQmugruHYmuJVftwmVjnUM82pXnMTnT5jh55qwZKrMw\",\n            \"address_to\": \"xw6U3FRE5H8rU3z8vAgF9ivnWSkxULK5cibdZzMC9UWf7rPJf\",\n            \"params\": \"\",\n            \"method\": \"UpdateValue\",\n            \"block_hash\": \"381114b86b09886f59956851a1d47d8442b29f44f3785dade3c667ca320e23bb\",\n            \"quantity\": 0,\n            \"tx_status\": \"Mined\",\n            \"time\": \"2019-04-26T07:18:36.636701Z\"\n        },\n        {\n            \"tx_id\": \"0230385e3f060059d2a62addac09ad6d01f96d32ec076cfbf44c6a3b70c6e092\",\n            \"params_to\": \"\",\n            \"chain_id\": \"AELF\",\n            \"block_height\": 1062,\n            \"address_from\": \"zizPhdDpQCZxMChMxn1oZ4ttJGJUo61Aocg5BpTYvzLQGmBjT\",\n            \"address_to\": \"xw6U3FRE5H8rU3z8vAgF9ivnWSkxULK5cibdZzMC9UWf7rPJf\",\n            \"params\": \"\",\n            \"method\": \"NextRound\",\n            \"block_hash\": \"06a3ceb783480f4cf5b8402f6749617093d9ea5f9a053f65e86554aeed6d98f4\",\n            \"quantity\": 0,\n            \"tx_status\": \"Mined\",\n            \"time\": \"2019-04-26T07:18:28.635113Z\"\n        }\n    ]\n}\n\nGet Transactions List By Address​\nURL: api/address/transactions?contract_address={contract_address}&limit={limit}&page={page}&address={address}\nMethod: GET\nDescription: Retrieve a list of transactions associated with a specific address.\n\nSuccess Response:\n\n{\n    \"total\": 1179,\n    \"transactions\": [\n        {\n            \"tx_id\": \"c65d1206e65aaf2e7e08cc818c372ff2c2947cb6cbec746efe6a5e20b7adefa9\",\n            \"chain_id\": \"AELF\",\n            \"block_height\": 1064,\n            \"address_from\": \"grSAEQ5vJ7UfCN2s1v4fJJnk98bu4SHa2hpQkQ9HT88rmaZLz\",\n            \"address_to\": \"xw6U3FRE5H8rU3z8vAgF9ivnWSkxULK5cibdZzMC9UWf7rPJf\",\n            \"method\": \"NextRound\",\n            \"block_hash\": \"8c922b20164ad3774b56d19673154f383ed89656cbd56433d1681c8c3a4dcab9\",\n            \"quantity\": 0,\n            \"tx_status\": \"Mined\",\n            \"time\": \"2019-04-26T07:18:36.636701Z\"\n        },\n        {\n            \"tx_id\": \"4780a7b2737b6f044894719b9bb4cb09862c0b4a7cae267131a0b5c3e7c12850\",\n            \"params_to\": \"\",\n            \"chain_id\": \"AELF\",\n            \"block_height\": 1063,\n            \"address_from\": \"QUYYqzTQmugruHYmuJVftwmVjnUM82pXnMTnT5jh55qwZKrMw\",\n            \"address_to\": \"xw6U3FRE5H8rU3z8vAgF9ivnWSkxULK5cibdZzMC9UWf7rPJf\",\n            \"params\": \"\",\n            \"method\": \"UpdateValue\",\n            \"block_hash\": \"381114b86b09886f59956851a1d47d8442b29f44f3785dade3c667ca320e23bb\",\n            \"quantity\": 0,\n            \"tx_status\": \"Mined\",\n            \"time\": \"2019-04-26T07:18:36.636701Z\"\n        },\n        {\n            \"tx_id\": \"0230385e3f060059d2a62addac09ad6d01f96d32ec076cfbf44c6a3b70c6e092\",\n            \"params_to\": \"\",\n            \"chain_id\": \"AELF\",\n            \"block_height\": 1062,\n            \"address_from\": \"zizPhdDpQCZxMChMxn1oZ4ttJGJUo61Aocg5BpTYvzLQGmBjT\",\n            \"address_to\": \"xw6U3FRE5H8rU3z8vAgF9ivnWSkxULK5cibdZzMC9UWf7rPJf\",\n            \"params\": \"\",\n            \"method\": \"NextRound\",\n            \"block_hash\": \"06a3ceb783480f4cf5b8402f6749617093d9ea5f9a053f65e86554aeed6d98f4\",\n            \"quantity\": 0,\n            \"tx_status\": \"Mined\",\n            \"time\": \"2019-04-26T07:18:28.635113Z\"\n        }\n    ]\n}\n\nTPS (Transactions Per Second)​\nGet TPS Record​\nURL: api/tps/list?start_time={unix_timestamp}&end_time={unix_timestamp}&order={order}\nMethod: GET\nDescription: Obtain TPS records for performance monitoring.\n\nSuccess Response:\n\n{\n    \"total\": 178,\n    \"tps\": [\n        {\n            \"id\": 12498,\n            \"start\": \"2019-11-22T01:12:14Z\",\n            \"end\": \"2019-11-22T01:13:14Z\",\n            \"txs\": 1878,\n            \"blocks\": 120,\n            \"tps\": 31,\n            \"tpm\": 1878,\n            \"type\": 1\n        },\n        {\n            \"id\": 12499,\n            \"start\": \"2019-11-22T01:13:14Z\",\n            \"end\": \"2019-11-22T01:14:14Z\",\n            \"txs\": 1889,\n            \"blocks\": 117,\n            \"tps\": 31,\n            \"tpm\": 1889,\n            \"type\": 1\n        },\n        {\n            \"id\": 12500,\n            \"start\": \"2019-11-22T01:14:14Z\",\n            \"end\": \"2019-11-22T01:15:14Z\",\n            \"txs\": 1819,\n            \"blocks\": 114,\n            \"tps\": 30,\n            \"tpm\": 1819,\n            \"type\": 1\n        },\n        {\n            \"id\": 12501,\n            \"start\": \"2019-11-22T01:15:14Z\",\n            \"end\": \"2019-11-22T01:16:14Z\",\n            \"txs\": 1779,\n            \"blocks\": 105,\n            \"tps\": 30,\n            \"tpm\": 1779,\n            \"type\": 1\n        }\n    ]\n}\n\nPrevious\nIntegration Guide\nNext\nAetherLink\nExplorer\nFeatures\niOS/Android Wallet\nWeb Wallet\nOverview\nExplorer API\nBlocks\nTransactions\nTPS (Transactions Per Second)\nPlatform\nTechnology\nAudit Report\nPrivacy\nTerms of Use\nCookie Policy\nDeveloper Resources\nQuick Start\nLearn\nDocs\nTools\nResources\nEcosystem\nOverview\ndApps\naelf Ventures\nBlog\nConnect\nContact Us\nCopyright © 2024 aelf"
    },
    {
      "title": "Integration Guide | AELF Docs",
      "url": "https://docs.aelf.com/resources/integration-guide/",
      "html": "Skip to main content\nQuick Start\nLearn\nDocs\nTools\nResources\nBlog\nSearch\nResources\nIntegration Guide\nWallet and Block Explorer\nAetherLink\nBrowser Extension\nDevOps\nProtobuf Extension\nWhitepapers\nResourcesIntegration Guide\nIntroduction\n\naelf-web-login: Modular React wallet collection and components for aelf applications.\n\nwebsite: https://aelf-web-login.vercel.app/\n\nInstall\nyarn add @aelf-web-login/wallet-adapter-night-elf @aelf-web-login/wallet-adapter-portkey-aa @aelf-web-login/wallet-adapter-portkey-discover @aelf-web-login/wallet-adapter-react @aelf-web-login/wallet-adapter-base @aelf-web-login/wallet-adapter-bridge\n\n\nThen the package.json will be like this\n\n\"dependencies\": {\n    \"@aelf-web-login/wallet-adapter-night-elf\": \"^0.0.2-alpha.7\",\n    \"@aelf-web-login/wallet-adapter-portkey-aa\": \"^0.0.2-alpha.7\",\n    \"@aelf-web-login/wallet-adapter-portkey-discover\": \"^0.0.2-alpha.7\",\n    \"@aelf-web-login/wallet-adapter-react\": \"^0.0.2-alpha.7\",\n    \"@aelf-web-login/wallet-adapter-base\": \"^0.0.2-alpha.7\",\n    \"@aelf-web-login/wallet-adapter-bridge\": \"^0.0.2-alpha.7\",\n}\n\nConfig\nImport PortkeyDiscoverWallet, PortkeyAAWallet and NightElfWallet and generate instance\nCreate didConfig (internal invoke: ConfigProvider.setGlobalConfig(didConfig))\nCreate baseConfig for SignIn component\nCreate wallets by wallet instance\nCombine them into a whole as config\nimport { PortkeyDiscoverWallet } from '@aelf-web-login/wallet-adapter-portkey-discover';\nimport { PortkeyAAWallet } from '@aelf-web-login/wallet-adapter-portkey-aa';\nimport { NightElfWallet } from '@aelf-web-login/wallet-adapter-night-elf';\nimport { IConfigProps } from '@aelf-web-login/wallet-adapter-bridge';\nimport { TChainId, SignInDesignEnum, NetworkEnum } from '@aelf-web-login/wallet-adapter-base';\n\nconst APP_NAME = 'explorer.aelf.io';\nconst WEBSITE_ICON = 'https://explorer.aelf.io/favicon.main.ico';\nconst CHAIN_ID = 'AELF' as TChainId;\nconst NETWORK_TYPE = NetworkEnum.TESTNET;\nconst RPC_SERVER_AELF = 'https://aelf-test-node.aelf.io';\nconst RPC_SERVER_TDVV = 'https://tdvv-public-node.aelf.io';\nconst RPC_SERVER_TDVW = 'https://tdvw-test-node.aelf.io';\nconst GRAPHQL_SERVER = 'https://dapp-aa-portkey-test.portkey.finance/Portkey_DID/PortKeyIndexerCASchema/graphql';\nconst CONNECT_SERVER = 'https://auth-aa-portkey-test.portkey.finance';\n\nconst didConfig = {\n  graphQLUrl: GRAPHQL_SERVER,\n  connectUrl: CONNECT_SERVER,\n  requestDefaults: {\n    baseURL: 'https://aa-portkey-test.portkey.finance',\n    timeout: 30000,\n  },\n  socialLogin: {\n    Portkey: {\n      websiteName: APP_NAME,\n      websiteIcon: WEBSITE_ICON,\n    },\n  },\n};\n\nconst baseConfig = {\n  networkType: NETWORK_TYPE,\n  chainId: CHAIN_ID,\n  keyboard: true,\n  noCommonBaseModal: false,\n  design: SignInDesignEnum.CryptoDesign, // \"SocialDesign\" | \"CryptoDesign\" | \"Web2Design\"\n  titleForSocialDesign: 'Crypto wallet',\n  iconSrcForSocialDesign: 'url or base64',\n};\n\nconst wallets = [\n  new PortkeyAAWallet({\n    appName: APP_NAME,\n    chainId: CHAIN_ID,\n    autoShowUnlock: true,\n  }),\n  new PortkeyDiscoverWallet({\n    networkType: NETWORK_TYPE,\n    chainId: CHAIN_ID,\n    autoRequestAccount: true,\n    autoLogoutOnDisconnected: true,\n    autoLogoutOnNetworkMismatch: true,\n    autoLogoutOnAccountMismatch: true,\n    autoLogoutOnChainMismatch: true,\n  }),\n  new NightElfWallet({\n    chainId: CHAIN_ID,\n    appName: APP_NAME,\n    connectEagerly: true,\n    defaultRpcUrl: RPC_SERVER_AELF,\n    nodes: {\n      AELF: {\n        chainId: 'AELF',\n        rpcUrl: RPC_SERVER_AELF,\n      },\n      tDVW: {\n        chainId: 'tDVW',\n        rpcUrl: RPC_SERVER_TDVW,\n      },\n      tDVV: {\n        chainId: 'tDVV',\n        rpcUrl: RPC_SERVER_TDVV,\n      },\n    },\n  }),\n]\n\nconst config: IConfigProps = {\n  didConfig,\n  baseConfig,\n  wallets\n};\n\nUsage\nImport WebLoginProvider, init and useConnectWallet\ninvoke init with upper config as params\npass the return value bridgeAPI to WebLoginProvider\nuse useConnectWallet to consume bridgeAPI\nimport { WebLoginProvider, init, useConnectWallet } from '@aelf-web-login/wallet-adapter-react';\n\nconst App = () => {\n  const bridgeAPI = init(config); // upper config\n  return (\n    <WebLoginProvider bridgeAPI={bridgeAPI}>\n      <Demo />\n    </WebLoginProvider>\n  );\n};\nconst Demo = () => {\n  const {\n    connectWallet,\n    disConnectWallet,\n    walletInfo,\n    lock,\n    isLocking,\n    isConnected,\n    loginError,\n    walletType,\n    getAccountByChainId,\n    getWalletSyncIsCompleted,\n    getSignature,\n    callSendMethod,\n    callViewMethod\n  } = useConnectWallet();\n}\n\nAPI\nconnectWallet​\nconnectWallet: () => Promise<TWalletInfo>\n\n\nConnect wallet and return walletInfo\n\nimport { Button } from 'aelf-design';\n\nconst Demo = () => {\n    const { connectWallet } = useConnectWallet();\n    const onConnectBtnClickHandler = async() => {\n        try {\n          const rs = await connectWallet();\n        } catch (e: any) {\n          console.log(e.message)\n        }\n    }\n    return (\n        <Button onClick={onConnectBtnClickHandler}>connect</Button>\n    )\n}\n\ndisConnectWallet​\ndisConnectWallet: () => Promise<void>\n\n\nDisconnect wallet\n\nimport { Button } from 'aelf-design';\n\nconst Demo = () => {\n    const { disConnectWallet } = useConnectWallet();\n    const onDisConnectBtnClickHandler = () => {\n        disConnectWallet()\n    }\n    return (\n        <Button onClick={onDisConnectBtnClickHandler}>disConnect</Button>\n    )\n}\n\nlock​\nlock: () => void\n\n\nLock wallet, only portkeyAA wallet take effect\n\nimport { Button } from 'aelf-design';\n\nconst Demo = () => {\n    const { lock } = useConnectWallet();\n    return (\n        <Button onClick={lock}>lock</Button>\n    )\n}\n\ngetAccountByChainId​\ngetAccountByChainId: (chainId: TChainId) => Promise<string>\n\n\nGet account address of designative chainId\n\nimport { Button } from 'aelf-design';\n\nconst Demo = () => {\n    const { getAccountByChainId } = useConnectWallet();\n\n    const getAelfAccountHandler = async() => {\n        const address = await getAccountByChainId('AELF')\n        console.log(address)\n    }\n    const getTdvwAccountHandler = async() => {\n        const address = await getAccountByChainId('tDVW')\n        console.log(address)\n    }\n    return (\n        <Button onClick={getAelfAccountHandler}>account-AELF</Button>\n        <Button onClick={getTdvwAccountHandler}>account-tDVW</Button>\n    )\n}\n\ngetWalletSyncIsCompleted​\ngetWalletSyncIsCompleted: (chainId: TChainId) => Promise<string | boolean>\n\n\nReturn account address of designative chainId if sync is competed, otherwise return false\n\nimport { Button } from 'aelf-design';\n\nconst Demo = () => {\n    const { getWalletSyncIsCompleted } = useConnectWallet();\n\n    const getAelfSyncIsCompletedHandler = async() => {\n        const address = await getWalletSyncIsCompleted('AELF')\n        console.log(address)\n    }\n    const getTdvwSyncIsCompletedHandler = async() => {\n        const address = await getWalletSyncIsCompleted('tDVW')\n        console.log(address)\n    }\n    return (\n        <Button onClick={getAelfSyncIsCompletedHandler}>sync-AELF</Button>\n        <Button onClick={getTdvwSyncIsCompletedHandler}>sync-tDVW</Button>\n    )\n}\n\ngetSignature​\nconst getSignature: (params: TSignatureParams) => Promise<{ ``    error: number; ``    errorMessage: string; ``    signature: string; ``    from: string; ``} | null>\n\n\nGet signature message\n\nimport { Button, Input } from 'aelf-design';\n\ntype TSignatureParams = {\n  appName: string;\n  address: string;\n  signInfo: string;\n  hexToBeSign?: string;\n};\n\nconst Demo = () => {\n    const { getSignature } = useConnectWallet();\n    const [signInfo, setSignInfo] = useState('');\n    const [signedMessage, setSignedMessage] = useState('');\n\n    const signHandler = async () => {\n      const sign = await getSignature({\n        signInfo,\n        appName: '',\n        address: '',\n      });\n      setSignedMessage(sign.signature);\n    };\n\n    return (\n        div>\n          <div>\n            <Button onClick={signHandler}>\n              Sign\n            </Button>\n            <Input value={signInfo} onChange={(e) => setSignInfo(e.target.value)} />\n            <div>{signedMessage}</div>\n          </div>\n        </div>\n    )\n}\n\ncallSendMethod​\ncallSendMethod: <T, R>(props: ICallContractParams<T>) => Promise<R>\n\n\nCall contract's send method\n\nimport { Button } from 'aelf-design';\n\ninterface ICallContractParams<T> {\n  contractAddress: string;\n  methodName: string;\n  args: T;\n  chainId?: TChainId;\n  sendOptions?: SendOptions;\n}\n\nconst Demo = () => {\n    const { callSendMethod } = useConnectWallet();\n    const [result, setResult] = useState({});\n\n    const onApproveHandler = async() => {\n        const res = await callSendMethod({\n          chainId: 'tDVW',\n          contractAddress: 'JRmBduh4nXWi1aXgdUsj5gJrzeZb2LxmrAbf7W99faZSvoAaE',\n          methodName: 'Approve',\n          args: {\n            symbol: 'ELF',\n            spender: 'JRmBduh4nXWi1aXgdUsj5gJrzeZb2LxmrAbf7W99faZSvoAaE',\n            amount: '100000000',\n          },\n        });\n        setResult(res);\n    }\n\n    return (\n      <div>\n        <Button onClick={onApproveHandler}>Approve in tDVW</Button>\n        <div>\n          <h4>Result</h4>\n          <pre className=\"result\">{JSON.stringify(result, null, '  ')}</pre>\n        </div>\n      </div>\n    )\n}\n\ncallViewMethod​\ncallViewMethod: <T, R>(props: ICallContractParams<T>) => Promise<R>\n\n\nCall contract's view method\n\nimport { Button } from 'aelf-design';\n\ninterface ICallContractParams<T> {\n  contractAddress: string;\n  methodName: string;\n  args: T;\n  chainId?: TChainId;\n  sendOptions?: SendOptions; // only send method use, ignore in view method\n}\n\nconst Demo = () => {\n    const { callViewMethod, getAccountByChainId } = useConnectWallet();\n    const [result, setResult] = useState({});\n\n    const onGetBalanceHandler = async() => {\n        const res = await callViewMethod({\n          chainId: 'tDVW',\n          contractAddress: 'ASh2Wt7nSEmYqnGxPPzp4pnVDU4uhj1XW9Se5VeZcX2UDdyjx',\n          methodName: 'GetBalance',\n          args: {\n            symbol: 'ELF',\n            owner: await getAccountByChainId('tDVW'),\n          },\n        });\n        setResult(res);\n    }\n\n    return (\n      <div>\n        <Button onClick={onGetBalanceHandler}>GetBalance in tDVW</Button>\n        <div>\n          <h4>Result</h4>\n          <pre className=\"result\">{JSON.stringify(result, null, '  ')}</pre>\n        </div>\n      </div>\n    )\n}\n\nwalletInfo​\nconst walletInfo: TWalletInfo\n\n\nWallet information after connecting wallet, can import TWalletInfo from @aelf-web-login/wallet-adapter-base\n\ntype TWalletInfo =\n  | {\n      name?: string;\n      address: string;\n      extraInfo?: {\n        [key: string]: any;\n      };\n    }\n  | undefined;\n\n  // walletInfo returned by nightElf\n  {\n    name,\n    address,\n    extraInfo: {\n      publicKey,\n      nightElfInfo: {\n        name,\n        appPermission,\n        defaultAElfBridge: bridge,\n        aelfBridges: bridges,\n        nodes,\n      },\n    },\n  }\n\n  // walletInfo returned by portkeyAA\n  import { DIDWalletInfo } from '@portkey/did-ui-react';\n  {\n    name,\n    address,\n    extraInfo: {\n      publicKey,\n      portkeyInfo: {\n        ...DIDWalletInfo\n        accounts: {\n          [chainId]: didWalletInfo.caInfo?.caAddress,\n        },\n        nickName,\n      },\n    },\n  }\n\n  // walletInfo returned by portkeyDiscover\n  import type { Accounts, IPortkeyProvider } from '@portkey/provider-types';\n  {\n    address,\n    extraInfo: {\n      accounts: Accounts,\n      nickName,\n      provider: IPortkeyProvider,\n    },\n  }\n\nconst Demo = () => {\n    const { walletInfo } = useConnectWallet();\n    console.log(walletInfo)\n    return null\n}\n\nwalletType​\nconst walletType: WalletTypeEnum\n\n\nThe currently connected wallet type, can import WalletTypeEnum from @aelf-web-login/wallet-adapter-base\n\nenum WalletTypeEnum {\n  unknown = 'Unknown',\n  elf = 'NightElf',\n  aa = 'PortkeyAA',\n  discover = 'PortkeyDiscover',\n}\n\nconst Demo = () => {\n    const { walletType } = useConnectWallet();\n    console.log(walletType)\n    return null\n}\n\nisLocking​\nconst isLocking: boolean\n\n\nindicate whether the current state is locked, only portkeyAA wallet take effect, other wallets always return false\n\nimport { Button } from 'aelf-design';\n\nconst Demo = () => {\n    const { isLocking } = useConnectWallet();\n\n    return (\n      <Button>\n        {isLocking ? 'unlock' : 'connect'}\n      </Button>\n    )\n}\n\nisConnected​\nconst isConnected: boolean\n\n\nindicate whether the current state is connected\n\nimport { Button } from 'aelf-design';\n\nconst Demo = () => {\n    const { isConnected } = useConnectWallet();\n\n    return (\n      <div>\n        <Button disabled={isConnected}>connect</Button>\n        <Button disabled={!isConnected}>disConnect</Button>\n      </div>\n    )\n}\n\nloginError​\nconst loginError: TWalletError | null\n\n\nindicate are there any errors during the login/logout/unlock process\n\ntype TWalletError = {\n  name: string;\n  code: number;\n  message: string;\n  nativeError?: any;\n}\n\nconst Demo = () => {\n  const { loginError } = useConnectWallet();\n\n  useEffect(() => {\n    if (!loginError) {\n      return;\n    }\n    console.log(loginError.message);\n  }, [loginError]);\n\n  return null\n}\n\nDevelopment\nInstall dependencies in the project root directory\npnpm install\n\ncd to demo directory and execute dev command\ncd packages/starter\npnpm dev\n\nPublish\nUpgrade the version numbers of each sub package\nexecute release command in the project root directory\npnpm release\n\nPrevious\nResources\nNext\nWallet and Block Explorer\nconnectWallet\ndisConnectWallet\nlock\ngetAccountByChainId\ngetWalletSyncIsCompleted\ngetSignature\ncallSendMethod\ncallViewMethod\nwalletInfo\nwalletType\nisLocking\nisConnected\nloginError\nPlatform\nTechnology\nAudit Report\nPrivacy\nTerms of Use\nCookie Policy\nDeveloper Resources\nQuick Start\nLearn\nDocs\nTools\nResources\nEcosystem\nOverview\ndApps\naelf Ventures\nBlog\nConnect\nContact Us\nCopyright © 2024 aelf"
    },
    {
      "title": "Web API | AELF Docs",
      "url": "https://docs.aelf.com/docs/web-api/",
      "html": "Skip to main content\nQuick Start\nLearn\nDocs\nTools\nResources\nBlog\nSearch\nDocs Reference\nSmart Contract API\nWeb API\nChain API\nNet API\nDocs ReferenceWeb API\nWeb API\n📄️ Chain API\n\naelf blockchain API Reference\n\n📄️ Net API\n\naelf network API Reference\n\nPrevious\nConfiguration Contract\nNext\nChain API\nPlatform\nTechnology\nAudit Report\nPrivacy\nTerms of Use\nCookie Policy\nDeveloper Resources\nQuick Start\nLearn\nDocs\nTools\nResources\nEcosystem\nOverview\ndApps\naelf Ventures\nBlog\nConnect\nContact Us\nCopyright © 2024 aelf"
    },
    {
      "title": "aelf Playground | AELF Docs",
      "url": "https://docs.aelf.com/tools/aelf-playground/",
      "html": "Skip to main content\nQuick Start\nLearn\nDocs\nTools\nResources\nBlog\nSearch\nK\nTools\nChain SDK\naelf Deploy Tool\naelf CLI\nSmart Contract\naelf Testnet Faucet\naelf Design\naelf Playground\nContract SDK\nToolsaelf Playground\naelf Playground\n1. Introduction​\n\naelf Playground is a sandbox for new developers who want to get a taste of smart contract development with aelf, without having to install tools in their local computer.\n\n2. Setting up​\n\nThere is no set-up needed. Simply visit https://playground.test.aelf.dev in your browser.\n\n3. Using aelf-playground​\nCreate a new project​\n\nClick on the Create a new project button, as shown below:\n\nIn the following step, enter a project name, and choose Native(CSharp) framework, then click Create:\n\nAfter a short while, the following workspace is loaded:\n\nWrite your smart contract​\n\nFeel free to edit the files.\n\nBuild your smart contract​\n\nOnce you are ready, click on the Build button:\n\nAfter a while, the contract is built.\n\nConnect your playground wallet​\n\nClick on the button Connect to Playground Wallet.\n\nA pop-up appears.\n\nTIP\n\nYou may choose to click on Save keypair to save a copy of your keypair, so that you may use it in subsequent sessions.\n\nClick Continue.\n\nDeploy your smart contract​\n\nClick on the Deploy button to deploy your smart contract.\n\nAfter about 1 minute, the contract is deployed:\n\nYou may click on the link below to view your contract on aelf explorer.\n\nDone​\n\nCongratulations! You have just deployed your first smart contract on the aelf blockchain (testnet).\n\nPrevious\naelf Design\nNext\nContract SDK\n1. Introduction\n2. Setting up\n3. Using aelf-playground\nCreate a new project\nWrite your smart contract\nBuild your smart contract\nConnect your playground wallet\nDeploy your smart contract\nDone\nPlatform\nTechnology\nAudit Report\nPrivacy\nTerms of Use\nCookie Policy\nDeveloper Resources\nQuick Start\nLearn\nDocs\nTools\nResources\nEcosystem\nOverview\ndApps\naelf Ventures\nBlog\nConnect\nContact Us\nCopyright © 2024 aelf"
    },
    {
      "title": "AELF Docs",
      "url": "https://docs.aelf.com/docs/smart-contract-api/",
      "html": "Skip to main content\nQuick Start\nLearn\nDocs\nTools\nResources\nBlog\nSearch\nDocs Reference\nSmart Contract API\nAssociation Contract\nReferendum Contract\nParliament Contract\nConsensus Contract\nElection Contract\nGenesis Contract\nMulti Token Contract\nProfit Contract\nCross Chain Contract\nTreasury Contract\nVote Contract\nToken Holder Contract\nEconomic Contract\nToken Converter Contract\nConfiguration Contract\nWeb API\nDocs ReferenceSmart Contract API\nSmart Contract API\n📄️ Association Contract\n\nTransactions handling\n\n📄️ Referendum Contract\n\nGovernance decisions\n\n📄️ Parliament Contract\n\nTwo-thirds majority\n\n📄️ Consensus Contract\n\nBlock producers and data\n\n📄️ Election Contract\n\nVoting for Block Producers\n\n📄️ Genesis Contract\n\nDeployment of contracts\n\n📄️ Multi Token Contract\n\nAccount and transaction fees\n\n📄️ Profit Contract\n\nBonus schemes\n\n📄️ Cross Chain Contract\n\nACS1 and ACS7\n\n📄️ Treasury Contract\n\nBonus distribution\n\n📄️ Vote Contract\n\nVoting activities\n\n📄️ Token Holder Contract\n\nToken holder bonuses distribution\n\n📄️ Economic Contract\n\naelf's economic system\n\n📄️ Token Converter Contract\n\nConnects aelf token with other tokens\n\n📄️ Configuration Contract\n\nBlockchain configuration\n\nPrevious\nDocs Reference\nNext\nAssociation Contract\nPlatform\nTechnology\nAudit Report\nPrivacy\nTerms of Use\nCookie Policy\nDeveloper Resources\nQuick Start\nLearn\nDocs\nTools\nResources\nEcosystem\nOverview\ndApps\naelf Ventures\nBlog\nConnect\nContact Us\nCopyright © 2024 aelf"
    },
    {
      "title": "Contract SDK | AELF Docs",
      "url": "https://docs.aelf.com/tools/contract-sdk/",
      "html": "Skip to main content\nQuick Start\nLearn\nDocs\nTools\nResources\nBlog\nSearch\nTools\nChain SDK\naelf Deploy Tool\naelf CLI\nSmart Contract\naelf Testnet Faucet\naelf Design\naelf Playground\nContract SDK\naelf SDK C#\naelf C# Core\nToolsContract SDK\nContract SDK\n📄️ aelf SDK C#\n\nBoolState type\n\n📄️ aelf C# Core\n\nBuilder type\n\nPrevious\naelf Playground\nNext\naelf SDK C#\nPlatform\nTechnology\nAudit Report\nPrivacy\nTerms of Use\nCookie Policy\nDeveloper Resources\nQuick Start\nLearn\nDocs\nTools\nResources\nEcosystem\nOverview\ndApps\naelf Ventures\nBlog\nConnect\nContact Us\nCopyright © 2024 aelf"
    },
    {
      "title": "AELF Docs",
      "url": "https://docs.aelf.com/tools/design/",
      "html": "Skip to main content\nQuick Start\nLearn\nDocs\nTools\nResources\nBlog\nSearch\nTools\nChain SDK\naelf Deploy Tool\naelf CLI\nSmart Contract\naelf Testnet Faucet\naelf Design\naelf Playground\nContract SDK\nToolsaelf Design\naelf Design\nA UI component library based on Antd and compliant with aelf visual specifications\nwebsite: https://aelf-design.vercel.app/\nInstall\n$ yarn add aelf-design\n\nUsage\nimport { Button } from 'aelf-design';\n\nconst App = () => {\n  return (\n    <div>\n      <Button>default</Button>\n    </div>\n  );\n};\n\nexport default App;\n\nDevelopment\n$ git clone https://github.com/AElfProject/aelf-design.git\n$ pnpm i (if there is not pnpm，please npm install -g pnpm first)\n$ pnpm dev\n\nPublish\nUpgrade the version numbers of each sub package\nexecute release command in the project root directory\n$ pnpm release\n\nHow to contribute components to aelf-design\nPrerequisite knowledge​\nDesign token​\n\nIn antd 5.0, the smallest element that affects the theme is called the Design Token. By modifying the Design Token, various themes or components can be presented. By passing the theme property in the ConfigProvider , the theme can be configured\n\nimport { Button, ConfigProvider, Space } from 'antd';\nimport React from 'react';\n\nconst App: React.FC = () => (\n  <ConfigProvider\n    theme={{\n      token: {\n        colorPrimary: '#00b96b',\n        borderRadius: 2,\n      },\n    }}\n  >\n    <Space>\n      <Button type=\"primary\">Primary</Button>\n      <Button>Default</Button>\n    </Space>\n  </ConfigProvider>\n);\n\nexport default App;\n\n\nIn addition to the overall Design Token, each component will also open its own Component Token to achieve the ability to customize the style of the component, and different components will not affect each other\n\nimport { Button, ConfigProvider, Space } from 'antd';\nimport React from 'react';\n\nconst App: React.FC = () => (\n  <ConfigProvider\n    theme={{\n        components: {\n          Button: {\n            colorPrimary: '#00b96b',\n            borderColorDisabled: '#d9d9d9'\n          },\n          Input: {\n            colorPrimary: '#eb2f96',\n          }\n        },\n    }}\n  >\n    <Space>\n      <Button type=\"primary\">Primary</Button>\n      <Button>Default</Button>\n    </Space>\n  </ConfigProvider>\n);\n\nexport default App;\n\n\nDetails: https://ant-design.antgroup.com/docs/react/customize-theme#design-token\n\nantd-style​\n\nAntd-style is a business-level css-in-js solution built on Ant Design V5 Token System\n\ncreateStyles​\nimport { SmileOutlined } from '@ant-design/icons';\nimport { Button, Space } from 'antd';\nimport { createStyles } from 'antd-style';\n\nconst useStyles = createStyles(({ token, css, cx }) => {\n  const commonCard = css`\n    border-radius: ${token.borderRadiusLG}px;\n    padding: ${token.paddingLG}px;\n  `;\n\n  return {\n    container: css`\n      background-color: ${token.colorBgLayout};\n      padding: 24px;\n    `,\n\n    defaultCard: css`\n      ${commonCard};\n      background: ${token.colorBgContainer};\n      color: ${token.colorText};\n    `,\n\n    primaryCard: cx(\n      commonCard,\n      css`\n        background: ${token.colorPrimary};\n        color: ${token.colorTextLightSolid};\n      `,\n    ),\n  };\n});\n\nconst App = () => {\n  const { styles } = useStyles();\n\n  return (\n    <div className={styles.container}>\n      <Space direction={'vertical'} style={{ width: '100%' }} size={16}>\n        <Space>\n          <Button icon={<SmileOutlined />} />\n          oprerate button\n        </Space>\n        <div className={styles.defaultCard}>defalut card</div>\n        <div className={styles.primaryCard}>primary card</div>\n      </Space>\n    </div>\n  );\n};\n\nexport default App;\n\n\nThe createStyles method can pass in a function with the following signature:\n\ntype GetCssStyleFn = (utils: CreateStylesUtils, props?: Props) => StyleInput;\n\n\nBelow is a detailed introduction to the functions of each attribute\n\nCreateStylesUtils\n\nThe first parameter used when writing styles, utils, provides a series of auxiliary objects and methods that facilitate style writing, improving the efficiency of style writing. Its type is CreateStylesUtils, and the property table is as follows:\n\nAttribute name\tType\tDescription\ncss\tCssUtil\tCSS serialization function\ncx\tClassNamesUtil\tCSS class name tool function\nresponsive\tResponsiveUtil\tResponsive media query tool function\ntoken\tFullToken\tContains antd's token and all custom tokens\nappearance\tThemeAppearance\tCurrent theme mode under ThemeProvider. 'dark' | 'light' | string\nisDarkMode\tboolean\tSyntax sugar can be directly used with isDarkMode to reduce the cost of appearance judgment.Equivalent to appearance === 'dark'\nprefixCls\tstring\tThe prefix marked on the ThemeProvider can obtain the current component prefix, making it easier to respond to component prefixes more flexibly\nThemeProvider​\n\nThemeProvider has done secondary encapsulation on the basis of ConfigProvider, providing a more convenient way to customize themes\n\nCustom Tokens can be injected through the customToken method of ThemeProvider\n\nimport { ThemeProvider } from 'antd-style';\n\nexport default () => {\n  return (\n    <ThemeProvider customToken={{ customBrandColor: '#c956df' }}>\n      <App />\n    </ThemeProvider>\n  );\n};\n\n// consume customToken\ncss`\n  background-color: ${token.customBrandColor};\n  padding: 24px;\n`\n\nDevelop aelfd component​\n1. According to the component design draft, identify the differences with the antd component​\n\n5 size types need to be provided, antd has 3\nDifferent sizes of height, padding, rounded corners, font size, and minimum width are different\n2. List the new features based on the antd component​\nProvide optional throttle click function\n3. Configure token​\n\nComponent tokens required to configure this component, global tokens (pay attention to whether it will affect other components), and custom tokens.\n\n<ThemeProvider\n    customToken={{ customBrandColor: '#c956df' }}\n    theme={{\n        components: {\n          Button: {\n            colorPrimary: '#00b96b',\n            borderColorDisabled: '#d9d9d9'\n          },\n          Input: {\n            paddingBlock: 11,\n            paddingBlockSM: 7,\n          }\n          ...\n        },\n        token: {\n            colorPrimary: '#1370DD',\n            colorPrimaryHover: '#3689DD',\n        }\n    }}\n/>\n\n\ntheme?: ThemeConfig | GetAntdTheme;\n\n4. Define aelfd component type file​\nexport type AelfdButtonSizeType =\n  | 'mini'\n  | 'small'\n  | 'medium'\n  | 'large'\n  | 'ultra'\nexport interface IAelfdButtonProps\n  extends Omit<ButtonProps, 'size' | 'onClick'> {\n  size?: AelfdButtonSizeType\n  onClick?: React.MouseEventHandler<HTMLElement>\n  millisecondOfThrottle?: number\n}\n\n5. Writing component logic and style files​\nconst useStyles = createStyles(\n  ({ css, prefixCls }, { size }: { size: AelfdButtonSizeType }) => {\n    const dynamicWidth =\n      size === 'mini'\n        ? '24px'\n        : size === 'small'\n        ? '32px'\n        : size === 'medium'\n        ? '40px'\n        : size === 'large'\n        ? '48px'\n        : '56px'\n\n    return {\n      buttonWrap: css`\n        display: flex;\n        align-items: center;\n        justify-content: center;\n        flex-shrink: 0;\n        // ...\n\n        &.${prefixCls}-btn-circle {\n          min-height: ${dynamicWidth};\n          height: ${dynamicWidth};\n          font-size: 14px;\n        }\n        &.${prefixCls}-btn-icon-only {\n          min-width: auto;\n          width: ${dynamicWidth};\n        }\n      `\n    }\n  }\n)\n\n\nPreviously, if you needed to override the style of the antd component, you needed to use: global to override it. Now, you can simply remove: global\n\nVs code plugin​\n\nvscode-styled-components\n\nPrevious\naelf Testnet Faucet\nNext\naelf Playground\nPrerequisite knowledge\nDesign token\nantd-style\nDevelop aelfd component\n1. According to the component design draft, identify the differences with the antd component\n2. List the new features based on the antd component\n3. Configure token\n4. Define aelfd component type file\n5. Writing component logic and style files\nVs code plugin\nPlatform\nTechnology\nAudit Report\nPrivacy\nTerms of Use\nCookie Policy\nDeveloper Resources\nQuick Start\nLearn\nDocs\nTools\nResources\nEcosystem\nOverview\ndApps\naelf Ventures\nBlog\nConnect\nContact Us\nCopyright © 2024 aelf"
    },
    {
      "title": "aelf Testnet Faucet | AELF Docs",
      "url": "https://docs.aelf.com/tools/faucet/",
      "html": "Skip to main content\nQuick Start\nLearn\nDocs\nTools\nResources\nBlog\nSearch\nTools\nChain SDK\naelf Deploy Tool\naelf CLI\nSmart Contract\naelf Testnet Faucet\naelf Design\naelf Playground\nContract SDK\nToolsaelf Testnet Faucet\naelf Faucet\n1. Introduction​\n\nThe aelf Testnet Faucet is a vital resource for developers working on the aelf blockchain. It provides free test tokens, particularly, ELF (native aelf token), Token type SEED token (for creation of new token), NFT type SEED token (for creation of new NFT collection), which are essential for deploying and testing smart contracts, running transactions, and exploring the functionalities of aelf without the risk of losing real assets. By using the faucet, developers can ensure their applications function correctly and efficiently before deploying them to the mainnet.\n\n2. Using aelf Faucet​\n2.1 Getting Testnet ELF Tokens​\n\nTo deploy smart contracts or execute on-chain transactions on aelf, you'll require testnet ELF tokens.\n\nGet ELF Tokens\n\nCLI\nWeb\n\nRun the following command to get testnet ELF tokens from faucet. Remember to either export your wallet address or replace $WALLET_ADDRESS with your wallet address.\n\nTerminal\ncurl -X POST \"https://faucet.aelf.dev/api/claim?walletAddress=$WALLET_ADDRESS\" -H \"accept: application/json\" -d \"\"\n\n\nTo check your wallet's current ELF balance:\n\nTerminal\naelf-command call ASh2Wt7nSEmYqnGxPPzp4pnVDU4uhj1XW9Se5VeZcX2UDdyjx -a $WALLET_ADDRESS -p $WALLET_PASSWORD -e https://tdvw-test-node.aelf.io GetBalance\n\n\nYou will be prompted for the following:\nEnter the required param <symbol>: ELF\nEnter the required param <owner>: $WALLET_ADDRESS\n\nYou should see the Result displaying your wallet's ELF balance.\n\n2.2 Getting Testnet Token Type SEED Token​\n\nTo acquire testnet Token type SEED for creating fungible or non-fungible tokens on aelf testnet.\n\nGet Token Type Seed Token\n\nCLI\nWeb\n\nRun the following command to get testnet SEED token from faucet. Remember to either export your wallet address or replace $WALLET_ADDRESS with your wallet address.\n\nTerminal\ncurl -X POST \"https://faucet.aelf.dev/api/claim-seed?walletAddress=$WALLET_ADDRESS\" -H \"accept: application/json\" -d \"\"\n\n2.3 Getting Testnet NFT Type SEED Token​\n\nTo acquire testnet NFT type SEED for creating fungible or non-fungible tokens on aelf testnet.\n\nGet NFT Type Seed Token\n\nCLI\nWeb\n\nRun this command to get testnet NFT type SEED token from faucet. Remember to either export your wallet address or replace $WALLET_ADDRESS with your wallet address.\n\nTerminal\ncurl -X POST \"https://faucet.aelf.dev/api/claim-nft-seed?walletAddress=$WALLET_ADDRESS\" -H \"accept: application/json\" -d \"\"\n\nPrevious\nDeploying Contract without BP Approval\nNext\naelf Design\n1. Introduction\n2. Using aelf Faucet\n2.1 Getting Testnet ELF Tokens\n2.2 Getting Testnet Token Type SEED Token\n2.3 Getting Testnet NFT Type SEED Token\nPlatform\nTechnology\nAudit Report\nPrivacy\nTerms of Use\nCookie Policy\nDeveloper Resources\nQuick Start\nLearn\nDocs\nTools\nResources\nEcosystem\nOverview\ndApps\naelf Ventures\nBlog\nConnect\nContact Us\nCopyright © 2024 aelf"
    },
    {
      "title": "AELF Docs",
      "url": "https://docs.aelf.com/tools/smart-contract-templates/",
      "html": "Skip to main content\nQuick Start\nLearn\nDocs\nTools\nResources\nBlog\nSearch\nTools\nChain SDK\naelf Deploy Tool\naelf CLI\nSmart Contract\nSmart Contracts Overview\nDevelopment Environment\nDeveloping Smart Contracts\nDeploying Contract with BP Approval\nDeploying Contract without BP Approval\naelf Testnet Faucet\naelf Design\naelf Playground\nContract SDK\nToolsSmart Contract\naelf CLI\n📄️ Smart Contracts Overview\n\nSmart Contracts Overview\n\n📄️ Development Environment\n\nDevelopment Environment\n\n📄️ Developing Smart Contracts\n\nThis guide shows how to develop a smart contract using the GreeterContract as an example. You’ll learn to create your own basic contract.\n\n📄️ Deploying Contract with BP Approval\n\nContracts can be deployed or updated via two methods: aelf explorer or aelf-command. Ensure npm and aelf-command are installed before starting. Follow the Deployment Environment guide if needed.\n\n📄️ Deploying Contract without BP Approval\n\nContracts can be deployed/updated via aelf explorer or aelf-command. Ensure npm and aelf-command are installed before starting. Follow the Deployment Environment guide if needed.\n\nPrevious\nCommands\nNext\nSmart Contracts Overview\nPlatform\nTechnology\nAudit Report\nPrivacy\nTerms of Use\nCookie Policy\nDeveloper Resources\nQuick Start\nLearn\nDocs\nTools\nResources\nEcosystem\nOverview\ndApps\naelf Ventures\nBlog\nConnect\nContact Us\nCopyright © 2024 aelf"
    },
    {
      "title": "AELF Docs",
      "url": "https://docs.aelf.com/tools/aelf-cli/",
      "html": "Skip to main content\nQuick Start\nLearn\nDocs\nTools\nResources\nBlog\nSearch\nTools\nChain SDK\naelf Deploy Tool\naelf CLI\nIntroduction to CLI\nCommands\nSmart Contract\naelf Testnet Faucet\naelf Design\naelf Playground\nContract SDK\nToolsaelf CLI\naelf CLI\n📄️ Introduction to CLI\n\naelf's Command Line Interface\n\n📄️ Commands\n\naelf CLI Commands\n\nPrevious\naelf Deploy Tool\nNext\nIntroduction to CLI\nPlatform\nTechnology\nAudit Report\nPrivacy\nTerms of Use\nCookie Policy\nDeveloper Resources\nQuick Start\nLearn\nDocs\nTools\nResources\nEcosystem\nOverview\ndApps\naelf Ventures\nBlog\nConnect\nContact Us\nCopyright © 2024 aelf"
    },
    {
      "title": "AELF Docs",
      "url": "https://docs.aelf.com/tools/aelf-deploy/",
      "html": "Skip to main content\nQuick Start\nLearn\nDocs\nTools\nResources\nBlog\nSearch\nTools\nChain SDK\naelf Deploy Tool\naelf CLI\nSmart Contract\naelf Testnet Faucet\naelf Design\naelf Playground\nContract SDK\nToolsaelf Deploy Tool\naelf Deploy Tool\n1. Introduction​\n\nThe aelf-deploy tool simplifies the deployment and updating of aelf contracts using your command prompt.\n\n2. Setting up​\n\nTo install the aelf-deploy tool globally, use the following command:\n\nTerminal\ndotnet tool install --global aelf.deploy\n\n3. Using aelf-deploy​\nExample Usage​\n\nDeploy a contract with the following command:\n\nTerminal\naelf-deploy -a $WALLET_ADDRESS -p $WALLET_PASSWORD -c $CONTRACT_PATH/$CONTRACT_FILE.dll.patched -e https://tdvw-test-node.aelf.io/\n\nCommand Options​\n\n-a: Address of the wallet.\n-p: Password of keystore file.\n-c: Location of the contract DLL.\n-u: Update contract (true/false). Default is false.\n-e: Endpoint. Default is 127.0.0.1:8000.\n-i: Include audit (true/false). Default is false (deploy without audit).\n-s: Salt, used to calculate contract addresses. If not provided, it defaults to the hash of the contract code.\n-o: Set to false if the deployer is an EOA address. Default is false.\n-t: Specify the contract address to update.\n-k: Private Key.\n\nBy following these instructions, you can easily deploy and manage aelf contracts using the aelf-deploy tool.\n\nPrevious\nPython SDK\nNext\naelf CLI\n1. Introduction\n2. Setting up\n3. Using aelf-deploy\nExample Usage\nCommand Options\nPlatform\nTechnology\nAudit Report\nPrivacy\nTerms of Use\nCookie Policy\nDeveloper Resources\nQuick Start\nLearn\nDocs\nTools\nResources\nEcosystem\nOverview\ndApps\naelf Ventures\nBlog\nConnect\nContact Us\nCopyright © 2024 aelf"
    },
    {
      "title": "AELF Docs",
      "url": "https://docs.aelf.com/tools/chain-sdk/",
      "html": "Skip to main content\nQuick Start\nLearn\nDocs\nTools\nResources\nBlog\nSearch\nTools\nChain SDK\nJavascript SDK\nC# SDK\nGo SDK\nJAVA SDK\nPHP SDK\nPython SDK\naelf Deploy Tool\naelf CLI\nSmart Contract\naelf Testnet Faucet\naelf Design\naelf Playground\nContract SDK\nToolsChain SDK\nChain SDK\n📄️ Javascript SDK\n\nJavascript SDK\n\n📄️ C# SDK\n\nC# SDK\n\n📄️ Go SDK\n\nGo SDK\n\n📄️ JAVA SDK\n\nJAVA SDK\n\n📄️ PHP SDK\n\nPHP SDK\n\n📄️ Python SDK\n\nPython SDK\n\nPrevious\nTools\nNext\nJavascript SDK\nPlatform\nTechnology\nAudit Report\nPrivacy\nTerms of Use\nCookie Policy\nDeveloper Resources\nQuick Start\nLearn\nDocs\nTools\nResources\nEcosystem\nOverview\ndApps\naelf Ventures\nBlog\nConnect\nContact Us\nCopyright © 2024 aelf"
    },
    {
      "title": "Operate a side chain | AELF Docs",
      "url": "https://docs.aelf.com/tutorials/operate-a-node/run-a-side-chain/",
      "html": "Skip to main content\nQuick Start\nLearn\nDocs\nTools\nResources\nBlog\nSearch\nUnderstanding aelf\nCore\nCross Chain\nConsensus\nNetwork\nBoot Sequence\nAddresses\nTransactions\nSmart Contract\nACS\nTutorials\nNode Operator\nTestnet Node\nMainnet Node\nRun aelf on Cloud\nSide Chain\nRequest a Side Chain\nRun a Side Chain\nTutorialsNode OperatorSide Chain\nOperate a side chain\n📄️ Request a Side Chain\n\nBegin here.\n\n📄️ Run a Side Chain\n\nOperational details.\n\nPrevious\nRun aelf on Cloud\nNext\nRequest a Side Chain\nPlatform\nTechnology\nAudit Report\nPrivacy\nTerms of Use\nCookie Policy\nDeveloper Resources\nQuick Start\nLearn\nDocs\nTools\nResources\nEcosystem\nOverview\ndApps\naelf Ventures\nBlog\nConnect\nContact Us\nCopyright © 2024 aelf"
    },
    {
      "title": "Run aelf on Cloud | AELF Docs",
      "url": "https://docs.aelf.com/tutorials/operate-a-node/run-aelf-on-cloud/",
      "html": "Skip to main content\nQuick Start\nLearn\nDocs\nTools\nResources\nBlog\nSearch\nUnderstanding aelf\nCore\nCross Chain\nConsensus\nNetwork\nBoot Sequence\nAddresses\nTransactions\nSmart Contract\nACS\nTutorials\nNode Operator\nTestnet Node\nMainnet Node\nRun aelf on Cloud\nSide Chain\nTutorialsNode OperatorRun aelf on Cloud\nGetting Started with Google Cloud\n\nThis guide will walk you through the steps required to run an aelf node on Google Cloud Platform (GCP).\n\nStep 1: Launch aelf Image​\n\nGo to the Google Cloud Marketplace and search for \"aelf blockchain for enterprise\".\n\nFind the aelf image and click on \"LAUNCH ON COMPUTE ENGINE\".\n\nKeep the default settings and click \"DEPLOY\" at the bottom left of the page.\n\nStep 2: Access and Start the Chain​\n\nLogin to the launched VM instance via SSH. You can do this by clicking the SSH drop-down and selecting \"Open in browser window\".\n\nIn the SSH session, execute sudo bash to elevate your privileges.\n\nStart the chain with one of the following commands:\n\nRun it in the foreground:\n\ncd /opt/aelf-node && docker-compose up\n\n\nOr run it in the background:\n\ncd /opt/aelf-node && docker-compose up -d\n\n\nStep 3: Verify Chain Status​\n\nTo verify that the node is working, use the following command to send an HTTP request and get the current chain status:\n\ncurl -X GET \"http://127.0.0.1:8001/api/blockChain/chainStatus\" -H \"accept: text/plain; v=1.0\"\n\n\nIf everything is working normally, you should see the chain status increase with each request.\n\nPrevious\nMainnet Node\nNext\nSide Chain\nStep 1: Launch aelf Image\nStep 2: Access and Start the Chain\nStep 3: Verify Chain Status\nPlatform\nTechnology\nAudit Report\nPrivacy\nTerms of Use\nCookie Policy\nDeveloper Resources\nQuick Start\nLearn\nDocs\nTools\nResources\nEcosystem\nOverview\ndApps\naelf Ventures\nBlog\nConnect\nContact Us\nCopyright © 2024 aelf"
    },
    {
      "title": "AELF Docs",
      "url": "https://docs.aelf.com/tutorials/operate-a-node/run-a-mainnet-node/",
      "html": "Skip to main content\nQuick Start\nLearn\nDocs\nTools\nResources\nBlog\nSearch\nUnderstanding aelf\nCore\nCross Chain\nConsensus\nNetwork\nBoot Sequence\nAddresses\nTransactions\nSmart Contract\nACS\nTutorials\nNode Operator\nTestnet Node\nMainnet Node\nRun aelf on Cloud\nSide Chain\nTutorialsNode OperatorMainnet Node\nMainnet Node\nHow to Join the Mainnet​\n\nThere are two ways to run an aelf node: using Docker (recommended) or running binaries from GitHub. Before starting, you need to install some tools and frameworks. Command line instructions are provided for most dependencies. For complex needs, see the Environment setup section.\n\nSteps to Set Up a Node​\nExecute the snapshot download script and load the snapshot into the database.\nDownload our template setting files and Docker run script.\nModify the appsettings according to your needs.\nRun and check the node.\nConfiguration Requirements​\nMinimum Configuration:​\nc5.xlarge or N2 instance: 4 vCPU, 8GiB RAM, 1TB storage, 5 Mbps bandwidth\nRecommended Configuration:​\nc5.2xlarge or N2 instance: 8 vCPU, 16GiB RAM, 1TB storage, 100 Mbps bandwidth\n\nNote:\n\nFor non-block producing nodes, there is no requirement on the number of nodes.\nTo become a BP, run individual nodes for both MainChain aelf and all SideChains.\n\nTime Syncing: Ensure your server is time-synced via NTP to avoid syncing issues.\n\nSetup the Database​\n\nWe support Redis and SSDB for storing node data. For mainnet, we provide snapshots for SSDB only. Configure two SSDB instances: one for the chain database and one for the state database (run on different machines for better performance).\n\nImport the Snapshot Data​\n\nCreate a snapshot directory and navigate to it:\n\nmkdir snapshot\ncd snapshot\n\n\nFetch the snapshot download script:\n\ncurl -O -s https://aelf-backup.s3.ap-northeast-2.amazonaws.com/snapshot/mainnet/download-mainchain-db.sh\n\n\nExecute the script (specify a date if needed):\n\nsh download-mainchain-db.sh\n\n\nRestore the chain database from snapshot:\n\ntar xvzf aelf-mainnet-mainchain-chaindb-*.tar.gz\nstop your chain database instance (ssdb server)\ncp -r aelf-mainnet-mainchain-chaindb-*/* /path/to/install/chaindb/ssdb/var/\nstart your chain database instance\nenter ssdb console (ssdb-cli) use the \"info\" command to confirm that the data has been imported)\n\n\nRestore the state database from snapshot:\n\ntar xvzf aelf-mainnet-mainchain-statedb-*.tar.gz\nstop your state database instance (ssdb server)\ncp -r aelf-mainnet-mainchain-statedb-*/* /path/to/install/statedb/ssdb/var/\nstart your state database instance\nenter ssdb console (ssdb-cli) use the \"info\" command to confirm that the data has been imported)\n\nNode Configuration​\nGenerating the Node's Account​\n\nInstall the aelf-command npm package:\n\nnpm i -g aelf-command\n\n\nCreate an account/key-pair:\n\naelf-command create\n\n\nFollow the prompts to set a password and save the account info.\n\nPrepare Node Configuration​\n\nDownload the settings template and Docker script:\n\ncd /tmp/\nwget https://github.com/aelfProject/aelf/releases/download/v1.6.0/aelf-mainnet-mainchain.zip\nunzip aelf-mainnet-mainchain.zip\nmv aelf-mainnet-mainchain /opt/aelf-node\n\n\nUpdate the appsettings.json file with your account information:\n\n{\n    \"Account\": {\n        \"NodeAccount\": \"2Ue31YTuB5Szy7cnr3SCEGU2gtGi5uMQBYarYUR5oGin1sys6H\",\n        \"NodeAccountPassword\": \"********\"\n    },\n    \"ConnectionStrings\": {\n        \"BlockchainDb\": \"redis://your chain database server ip address:port\",\n        \"StateDb\": \"redis://your state database server ip address:port\"\n    },\n    \"Network\": {\n        \"BootNodes\": [\n            \"xxx.xxxx.xxx.xxx:6800\"\n        ],\n        \"ListeningPort\": 6800\n    },\n    \"CrossChain\": {\n        \"Grpc\": {\n            \"LocalServerPort\": 5000\n        }\n    }\n}\n\nRunning a Full Node with Docker​\n\nPull aelf’s Docker image and start the node:\n\ndocker pull aelf/node:mainnet-v1.6.0\ncd /opt/aelf-node\nsh aelf-node.sh start aelf/node:mainnet-v1.6.0\n\n\nTo stop the node:\n\nsh aelf-node.sh stop\n\nRunning a Full Node with the Binary Release​\n\nInstall the .NET Core SDK (version 6.0).\n\nGet the latest release and run the node:\n\ncd /tmp/\nwget https://github.com/aelfProject/aelf/releases/download/v1.6.0/aelf.zip\nunzip aelf.zip\nmv aelf /opt/aelf-node/\ncd /opt/aelf-node\ndotnet aelf/aelf.Launcher.dll\n\nRunning a Full Node with the Source​\nEnsure the code version is consistent (aelf v1.6.0).\nCompile on an Ubuntu Linux machine (recommended Ubuntu 18.04.2 LTS) with .NET Core SDK version 6.0.\nCheck the Node​\n\nRun the following command to check the node's block height:\n\naelf-command get-blk-height -e http://your node ip address:port\n\nRunning Side-Chains​\n\nDownload and Restore Snapshot Data (steps are the same as in Setup the Database).\n\nRun Side-Chain Node:\n\ncd /tmp/\nwget https://github.com/aelfProject/aelf/releases/download/v1.6.0/aelf-mainnet-sidechain1.zip\nunzip aelf-mainnet-sidechain1.zip\nmv aelf-mainnet-sidechain1 /opt/aelf-node\n\n\nUpdate appsettings.SideChain.MainNet.json with your node information:\n\n{\n    \"CrossChain\": {\n        \"Grpc\": {\n            \"ParentChainServerPort\": 5001,\n            \"ParentChainServerIp\": \"your mainchain ip address\",\n            \"ListeningPort\": 5011\n        },\n        \"ParentChainId\": \"aelf\",\n        \"Economic\": {\n            \"SymbolListToPayTxFee\": \"WRITE,READ,STORAGE,TRAFFIC\",\n            \"SymbolListToPayRental\": \"CPU,RAM,DISK,NET\"\n        }\n    },\n    \"Network\": {\n        \"BootNodes\": [\n            \"sidechain-bootnode-ip:6800\"\n        ],\n        \"ListeningPort\": 6800\n    }\n}\n\nNote​\n\nEnsure P2P ports are open and configured correctly for node communication.\n\n```sh\nbootnode → [\"xxx.xxxx.xxx.xxx:6800\", \"...\"]\n```\n\n```json\n{\n    \"Network\": {\n        \"BootNodes\": [\n            \"Add the right boot node according to sidechain\"\n        ],\n        \"ListeningPort\": 6800\n    }\n}\n```\n\nPrevious\nTestnet Node\nNext\nRun aelf on Cloud\nHow to Join the Mainnet\nSteps to Set Up a Node\nConfiguration Requirements\nMinimum Configuration:\nRecommended Configuration:\nSetup the Database\nImport the Snapshot Data\nNode Configuration\nGenerating the Node's Account\nPrepare Node Configuration\nRunning a Full Node with Docker\nRunning a Full Node with the Binary Release\nRunning a Full Node with the Source\nCheck the Node\nRunning Side-Chains\nNote\nPlatform\nTechnology\nAudit Report\nPrivacy\nTerms of Use\nCookie Policy\nDeveloper Resources\nQuick Start\nLearn\nDocs\nTools\nResources\nEcosystem\nOverview\ndApps\naelf Ventures\nBlog\nConnect\nContact Us\nCopyright © 2024 aelf"
    },
    {
      "title": "Testnet Node | AELF Docs",
      "url": "https://docs.aelf.com/tutorials/operate-a-node/run-a-testnet-node/",
      "html": "Skip to main content\nQuick Start\nLearn\nDocs\nTools\nResources\nBlog\nSearch\nUnderstanding aelf\nCore\nCross Chain\nConsensus\nNetwork\nBoot Sequence\nAddresses\nTransactions\nSmart Contract\nACS\nTutorials\nNode Operator\nTestnet Node\nMainnet Node\nRun aelf on Cloud\nSide Chain\nTutorialsNode OperatorTestnet Node\nHow to Join the Testnet\n\nYou can run an aelf node using Docker (recommended) or GitHub binaries. Before starting, install the necessary tools and frameworks. Detailed instructions are in the environment setup section.\n\nSteps to Set Up a Node:​\nDownload and load the database snapshot.\nDownload template settings and Docker run script.\nModify appsettings as needed.\nRun and check the node.\nMinimum Configuration:​\nc5.large or N2 instance: 2 vCPU, 4GiB RAM, 800GiB storage, 5 Mbps internet bandwidth\nRecommended Configuration:​\nc5.xlarge or N2 instance: 4 vCPU, 8GiB RAM, 800GiB storage, 100 Mbps internet bandwidth\n\nNote: For testing or dApp deployment, run a SideChain node only. Use the same configuration for multiple nodes on both MainChain and SideChain.\n\nTime Syncing: Ensure your server is time-synced via NTP to avoid syncing issues.\n\nSetup the Database​\n\nWe support Redis and SSDB. For testnet, we use SSDB snapshots. Configure two SSDB instances: one for chain database and one for state database.\n\nImport the Snapshot Data​\n\nDownload Snapshot:\n\nmkdir snapshot\ncd snapshot\ncurl -O -s https://aelf-node.s3-ap-southeast-1.amazonaws.com/snapshot/testnet/download-mainchain-db.sh\nsh download-mainchain-db.sh\n\n\nRestore Chain Database:\n\ntar xvzf aelf-testnet-mainchain-chaindb-*.tar.gz\nstop your chain database instance (ssdb server)\ncp -r aelf-testnet-mainchain-chaindb-*/* /path/to/install/chaindb/ssdb/var/\nstart your chain database instance\nssdb-cli info\n\n\nRestore State Database:\n\ntar xvzf aelf-testnet-mainchain-statedb-*.tar.gz\nstop your state database instance (ssdb server)\ncp -r aelf-testnet-mainchain-statedb-*/* /path/to/install/statedb/ssdb/var/\nstart your state database instance\nssdb-cli info\n\nNode Configuration​\nGenerate Node Account​\n\nInstall aelf-command:\n\nnpm i -g aelf-command\n\n\nCreate Account:\n\naelf-command create\n\n\nFollow the prompts and save the account info.\n\nPrepare Node Configuration​\n\nDownload Settings Template and Docker Script:\n\ncd /tmp/\nwget https://github.com/aelfProject/aelf/releases/download/v1.0.0-rc1/aelf-testnet-mainchain.zip\nunzip aelf-testnet-mainchain.zip\nmv aelf-testnet-mainchain /opt/aelf-node\n\n\nUpdate appsettings.json:\n\n{\n    \"Account\": {\n        \"NodeAccount\": \"your-node-account\",\n        \"NodeAccountPassword\": \"your-password\"\n    },\n    \"ConnectionStrings\": {\n        \"BlockchainDb\": \"redis://chain-db-server:port\",\n        \"StateDb\": \"redis://state-db-server:port\"\n    },\n    \"Network\": {\n        \"BootNodes\": [\n            \"node-ip:6800\"\n        ],\n        \"ListeningPort\": 6800\n    },\n    \"CrossChain\": {\n        \"Grpc\": {\n            \"LocalServerPort\": 5000\n        }\n    }\n}\n\nRunning a Full Node​\nWith Docker​\n\nRun Node:\n\ndocker pull aelf/node:testnet-v1.6.0\ncd /opt/aelf-node\nsh aelf-node.sh start aelf/node:testnet-v1.6.0\n\n\nStop Node:\n\nsh aelf-node.sh stop\n\nWith Binary Release​\n\nInstall .NET Core SDK 6.0.\n\nDownload and Run Node:\n\ncd /tmp/\nwget https://github.com/aelfProject/aelf/releases/download/v1.0.0-rc1/aelf.zip\nunzip aelf.zip\nmv aelf /opt/aelf-node/\ncd /opt/aelf-node\ndotnet aelf/aelf.Launcher.dll\n\nCheck the Node​\n\nTo check the node, query its current block height:\n\naelf-command get-blk-height -e http://your-node-ip:port\n\nRunning Side-Chains​\n\nDownload and Restore Snapshot Data.\n\nRun Side-Chain Node:\n\ncd /tmp/\nwget https://github.com/aelfProject/aelf/releases/download/v1.0.0-rc1/aelf-testnet-sidechain1.zip\nunzip aelf-testnet-sidechain1.zip\nmv aelf-testnet-sidechain1 /opt/aelf-node\n\n\nUpdate appsettings.SideChain.TestNet.json with your node information:\n\n{\n    \"CrossChain\": {\n        \"Grpc\": {\n            \"ParentChainServerPort\": 5000,\n            \"ParentChainServerIp\": \"mainchain-ip\",\n            \"ListeningPort\": 5001\n        },\n        \"ParentChainId\": \"aelf\"\n    },\n    \"Network\": {\n        \"BootNodes\": [\n            \"sidechain-bootnode-ip:6800\"\n        ],\n        \"ListeningPort\": 6800\n    }\n}\n\nNote​\n\nEach side chain has its own P2P network, add the mainnet sidechain nodes as peer:\n\n```sh\nbootnode → [\"xxx.xxxx.xxx.xxx:6800\", \"...\"]\n```\n\n```json\n{\n    \"Network\": {\n        \"BootNodes\": [\n            \"Add the right boot node according to sidechain\"\n        ],\n        \"ListeningPort\": 6800\n    }\n}\n```\n\nPrevious\nNode Operator\nNext\nMainnet Node\nSteps to Set Up a Node:\nMinimum Configuration:\nRecommended Configuration:\nSetup the Database\nImport the Snapshot Data\nNode Configuration\nGenerate Node Account\nPrepare Node Configuration\nRunning a Full Node\nWith Docker\nWith Binary Release\nCheck the Node\nRunning Side-Chains\nNote\nPlatform\nTechnology\nAudit Report\nPrivacy\nTerms of Use\nCookie Policy\nDeveloper Resources\nQuick Start\nLearn\nDocs\nTools\nResources\nEcosystem\nOverview\ndApps\naelf Ventures\nBlog\nConnect\nContact Us\nCopyright © 2024 aelf"
    },
    {
      "title": "Operate a node | AELF Docs",
      "url": "https://docs.aelf.com/tutorials/operate-a-node/",
      "html": "Skip to main content\nQuick Start\nLearn\nDocs\nTools\nResources\nBlog\nSearch\nUnderstanding aelf\nCore\nCross Chain\nConsensus\nNetwork\nBoot Sequence\nAddresses\nTransactions\nSmart Contract\nACS\nTutorials\nNode Operator\nTestnet Node\nMainnet Node\nRun aelf on Cloud\nSide Chain\nTutorialsNode Operator\nOperate a node\n📄️ Testnet Node\n\nHow to join Testnet\n\n📄️ Mainnet Node\n\nHow to join Mainnet\n\n📄️ Run aelf on Cloud\n\nGoogle Cloud Platform (GCP)\n\n🗃️ Side Chain\n\nOperate a side chain\n\nPrevious\nTutorials\nNext\nTestnet Node\nPlatform\nTechnology\nAudit Report\nPrivacy\nTerms of Use\nCookie Policy\nDeveloper Resources\nQuick Start\nLearn\nDocs\nTools\nResources\nEcosystem\nOverview\ndApps\naelf Ventures\nBlog\nConnect\nContact Us\nCopyright © 2024 aelf"
    },
    {
      "title": "AELF Docs",
      "url": "https://docs.aelf.com/learn/acs-introduction/",
      "html": "Skip to main content\nQuick Start\nLearn\nDocs\nTools\nResources\nBlog\nSearch\nUnderstanding aelf\nCore\nCross Chain\nConsensus\nNetwork\nBoot Sequence\nAddresses\nTransactions\nSmart Contract\nACS\nContract Deployment\nTransaction Fee\nParallel Execution\nContract Proposal\nConsensus\nContract Threshold\nRandom Number\nContract CrossChain\nToken Fee\nProfit Dividend\nDividend Pool\nCross Chain Consensus\nUser Contract\nTutorials\nNode Operator\nUnderstanding aelfACS\naelf Contract Standards\n📄️ Contract Deployment\n\nACS0\n\n📄️ Transaction Fee\n\nACS1\n\n📄️ Parallel Execution\n\nACS2\n\n📄️ Contract Proposal\n\nACS3\n\n📄️ Consensus\n\nACS4\n\n📄️ Contract Threshold\n\nACS5\n\n📄️ Random Number\n\nACS6\n\n📄️ Contract CrossChain\n\nACS7\n\n📄️ Token Fee\n\nACS8\n\n📄️ Profit Dividend\n\nACS9\n\n📄️ Dividend Pool\n\nACS10\n\n📄️ Cross Chain Consensus\n\nACS11\n\n📄️ User Contract\n\nACS12\n\nPrevious\nOther Restrictions\nNext\nContract Deployment\nPlatform\nTechnology\nAudit Report\nPrivacy\nTerms of Use\nCookie Policy\nDeveloper Resources\nQuick Start\nLearn\nDocs\nTools\nResources\nEcosystem\nOverview\ndApps\naelf Ventures\nBlog\nConnect\nContact Us\nCopyright © 2024 aelf"
    },
    {
      "title": "Smart Contract | AELF Docs",
      "url": "https://docs.aelf.com/learn/smart-contract/",
      "html": "Skip to main content\nQuick Start\nLearn\nDocs\nTools\nResources\nBlog\nSearch\nUnderstanding aelf\nCore\nCross Chain\nConsensus\nNetwork\nBoot Sequence\nAddresses\nTransactions\nSmart Contract\nArchitecture\nService\nEvents\nMessages\nRestrictions\nACS\nTutorials\nNode Operator\nUnderstanding aelfSmart Contract\nSmart Contract\n📄️ Architecture\n\nThe aelf smart contract\n\n📄️ Service\n\ngRPC and protobuf\n\n📄️ Events\n\nLogging transaction events\n\n📄️ Messages\n\nCalling smart contracts\n\n🗃️ Restrictions\n\nRequirements and Restrictions\n\nPrevious\nTransactions\nNext\nArchitecture\nPlatform\nTechnology\nAudit Report\nPrivacy\nTerms of Use\nCookie Policy\nDeveloper Resources\nQuick Start\nLearn\nDocs\nTools\nResources\nEcosystem\nOverview\ndApps\naelf Ventures\nBlog\nConnect\nContact Us\nCopyright © 2024 aelf"
    },
    {
      "title": "Transactions | AELF Docs",
      "url": "https://docs.aelf.com/learn/transactions/",
      "html": "Skip to main content\nQuick Start\nLearn\nDocs\nTools\nResources\nBlog\nSearch\nUnderstanding aelf\nCore\nCross Chain\nConsensus\nNetwork\nBoot Sequence\nAddresses\nTransactions\nSmart Contract\nACS\nTutorials\nNode Operator\nUnderstanding aelfTransactions\nOverview\n\nTransactions play a critical role in modifying the state of the aelf blockchain through interactions with smart contracts. Here’s how transactions function:\n\n1. Transaction Process:​\nTransactions are initiated by calling methods on smart contracts.\nThey are either sent to a node through RPC (Remote Procedure Call) or received from the network.\n2. Transaction Execution:​\nUpon broadcasting a transaction, if it meets validation criteria, it becomes eligible for inclusion in a block.\nOnce included in a block and executed by the node, the transaction potentially alters the state of the involved contracts.\n\nIn essence, transactions in aelf blockchain are fundamental actions that drive changes to the blockchain’s state, ensuring secure and efficient operation across the network.\n\nSmart Contract​\n\nIn the aelf blockchain, smart contracts consist of two main components:\n\n1. State Definitions:​\nSmart contracts define a set of variables that represent their state.\nThese variables can store data such as account balances, token ownership, or any other relevant information.\n2. Methods:​\nSmart contracts include a set of methods designed to interact with and modify these states.\nThese methods are executed when triggered by transactions or external calls.\nThey can update the state variables based on predefined rules and conditions.\n\nSmart contracts in aelf blockchain serve as self-executing contracts with predefined terms and conditions agreed upon by participating parties. They enable automated and trustless execution of agreements and transactions within the blockchain ecosystem.\n\nAction & View​\n\nIn the aelf blockchain, smart contract methods are categorized into two types based on their functionality: actions and views.\n\n1. Action Methods:​\nDefinition: Action methods are designed to modify the state of a contract.\nExecution: When a transaction containing an action method is included in a block and successfully executed, it can change the internal state of the contract.\nExample​\nrpc Vote (VoteInput) returns (google.protobuf.Empty) {\n}\n\nAction methods are typically used for operations that alter data within the blockchain, such as updating balances, transferring tokens, or recording votes.\n2. View Methods:​\nDefinition: View methods retrieve data from the contract but do not modify its state under any circumstances.\nExecution: They are purely read-only operations.\nExample​\nrpc GetVotingResult (GetVotingResultInput) returns (VotingResult) {\n    option (aelf.is_view) = true;\n}\n\nView methods are annotated with option (aelf.is_view) = true; in their protocol buffer (proto) definitions.\nThey are used for querying information stored in the contract, such as retrieving voting results, fetching account details, or checking contract status.\n\nThese distinctions ensure that smart contracts in aelf blockchain can effectively manage state changes while maintaining secure and efficient data access.\n\nTransaction Instance​\n\nIn the aelf blockchain, a Transaction is structured as follows:\n\noption csharp_namespace = \"AElf.Types\";\n\nmessage Transaction {\n    Address from = 1;\n    Address to = 2;\n    int64 ref_block_number = 3;\n    bytes ref_block_prefix = 4;\n    string method_name = 5;\n    bytes params = 6;\n    bytes signature = 10000;\n}\n\nWorking with Transactions in JS SDK​\n\nUse the getTransaction method to build a transaction object:\n\nimport Aelf from 'aelf-sdk';\n\nvar rawTxn = proto.getTransaction(\n  '65dDNxzcd35jESiidFXN5JV8Z7pCwaFnepuYQToNefSgqk9',\n  'SomeMethod',\n  encodedParams\n);\n\n\nThis will create a transaction to the contract at address 65dDNxzcd35jESiidFXN5JV8Z7pCwaFnepuYQToNefSgqk9 and call SomeMethod with encoded parameters.\n\nKey Fields in Transactions​\nFrom: The sender's address. Currently derived from the signature.\nTo: The contract address being called.\nMethodName: The name of the method in the smart contract.\nParams: The parameters to pass to the method.\nSignature: The signature of the transaction, which includes fields like from, to, method, parameters, reference block number, and prefix.\n\nSign a transaction using the JS SDK:\n\nimport Aelf from 'aelf-sdk';\n\nvar txn = Aelf.wallet.signTransaction(rawTxn, wallet.keyPair);\n\nRefBlockNumber & RefBlockPrefix: Ensure the transaction is not expired. These two fields measure whether this transaction has expired. The transaction will be discarded if it is too old.\nTransaction Id: A unique identifier for the transaction, consisting of a cryptographic hash of the essential fields, excluding the signature.\n\nNote that the Transaction Id of transactions will be the same if the sender broadcasted several transactions with the same origin data, and then these transactions will be regarded as one transaction even though broadcasting several times.\n\nVerification​\n\nBefore forwarding a transaction to other nodes, it is verified by the node. If the execution fails, the transaction is neither forwarded nor included in a new block.\n\nValidation providers include:\n\nBasicTransactionValidationProvider: Verifies transaction signature and size.\nTransactionExecutionValidationProvider: Pre-executes the transaction before forwarding or packaging it.\nTransactionMethodValidationProvider: Prevents view-only method transactions from being packaged into new blocks.\nExecution​\n\nIn aelf, transactions are executed via the .NET reflection mechanism.\n\nExecution Plugins​\nFeeChargePreExecutionPlugin: Charges method fees from the sender.\nMethodCallingThresholdPreExecutionPlugin: Checks the calling threshold of specific contracts or methods.\nResourceConsumptionPostExecutionPlugin: Charges resource tokens based on the resources consumed during execution.\nTransaction Result​\n\nThe data structure for TransactionResult:\n\nmessage TransactionResourceInfo {\n    repeated aelf.ScopedStatePath write_paths = 1;\n    repeated aelf.ScopedStatePath read_paths = 2;\n    ParallelType parallel_type = 3;\n    aelf.Hash transaction_id = 4;\n    aelf.Hash contract_hash = 5;\n    bool is_nonparallel_contract_code = 6;\n}\n\nPrevious\nAddresses\nNext\nSmart Contract\nSmart Contract\nAction & View\n1. Action Methods:\n2. View Methods:\nTransaction Instance\nVerification\nExecution\nTransaction Result\nPlatform\nTechnology\nAudit Report\nPrivacy\nTerms of Use\nCookie Policy\nDeveloper Resources\nQuick Start\nLearn\nDocs\nTools\nResources\nEcosystem\nOverview\ndApps\naelf Ventures\nBlog\nConnect\nContact Us\nCopyright © 2024 aelf"
    },
    {
      "title": "Addresses | AELF Docs",
      "url": "https://docs.aelf.com/learn/addresses/",
      "html": "Skip to main content\nQuick Start\nLearn\nDocs\nTools\nResources\nBlog\nSearch\nUnderstanding aelf\nCore\nCross Chain\nConsensus\nNetwork\nBoot Sequence\nAddresses\nTransactions\nSmart Contract\nACS\nTutorials\nNode Operator\nUnderstanding aelfAddresses\nAddress\nOverview​\n\nChanges within the aelf blockchain occur through the execution of transactions. An address within aelf identifies a participant in a transaction, either as the sender or the recipient. The sender is denoted as From, while the recipient is denoted as To.\n\nFrom can represent:\n\nUser Address: Identifies an individual participant.\nContract Address: Identifies a smart contract.\nVirtual Address: Represents a virtual entity within the blockchain.\n\nTo is exclusively a Contract Address, indicating that the transaction sender intends to execute a specific method within that smart contract.\n\nFor further details on each type of address in the aelf blockchain, please see below.\n\nUser Address​\n\nA User Address in aelf is generated from a unique key pair owned by a real user of the blockchain. Here’s how it works:\n\nKey Pair Generation:​\nA User Address is derived from a key pair using the IAElfAsymmetricCipherKeyPair interface.\nThis interface includes\npublic interface IAElfAsymmetricCipherKeyPair\n{\n    byte[] PrivateKey { get; }\n    byte[] PublicKey { get; }\n}\n\n\nCurrently, aelf blockchain utilizes ECKeyPair for this purpose, similar to many other blockchain systems.\n\nGenerating a Key Pair:​\nUsers can use the aelf-command tool to create a valid ECKeyPair:\naelf-command create\n\nYou will need to provide a valid password. The tool generates a .json file containing the public and private keys, encrypted with your password.\nUsing dApp SDK:​\n\nFor dApp developers, the aelf JavaScript SDK js-sdk` offers a method based on bip39 for deterministic key pair generation:\n\nimport Aelf from 'aelf-sdk';\nAelf.wallet.createNewWallet();\n\n\nThis method returns an object with the mnemonic, key pair, and address encoded in base58.\n\nGenerating an Address​\n\nWhen you create a new wallet using the aelf-sdk, it will return an object with three important parts:\n\nMnemonic: A phrase used to generate the key pair.\nKey Pair: Contains the public and private keys.\nAddress: The unique identifier for the wallet.\n\nIn aelf, we usually encode the address in a format called base58. The address is derived from the public key by taking the first 30 bytes of its double SHA-256 hash. Here's how you can get the address from the public key using the aelf-sdk:\n\nimport Aelf from 'aelf-sdk';\nconst address = Aelf.wallet.getAddressFromPubKey(pubKey);\n\nAddress Representation:​\nThe User Address in aelf is represented using Protobuf message Address\noption csharp_namespace = \"AElf.Types\";\nmessage Address\n{\n  bytes value = 1;\n}\n\n\nIn summary, a User Address in aleft blockchain is fundamental for identifying users and interacting with the blockchain securely and effectively.\n\nContract Address​\n\nA Contract Address in aelf blockchain uniquely identifies a Smart Contract. Here’s how it’s created:\n\n1. Calculation Method:​\nA Contract Address is determined during the deployment of a Smart Contract.\nIt’s calculated using a combination of the blockchain's chain id and a *serial number associated with the contract.\n2. Implementation:​\n\nHere’s how you can build a Contract Address in aelf:\n\nprivate static Address BuildContractAddress(Hash chainId, long serialNumber)\n{\n    var hash = HashHelper.ConcatAndCompute(chainId, HashHelper.ComputeFrom(serialNumber));\n    return Address.FromBytes(hash.ToByteArray());\n}\npublic static Address BuildContractAddress(int chainId, long serialNumber)\n{\n    return BuildContractAddress(HashHelper.ComputeFrom(chainId), serialNumber);\n}\n\nHashHelper.ConcatAndCompute: Combines the chain id and serial number hashes.\nAddress.FromBytes: Converts the resulting hash into a readable Address format.\n3. Usage:​\nDevelopers deploying Smart Contracts on aelf blockchain use these methods to generate unique Contract Addresses dynamically.\n\nIn essence, a Contract Address in aelf blockchain ensures each Smart Contract can be uniquely identified and interacted with securely across the network.\n\nContract Virtual Address​\n\nIn the aelf blockchain, every contract has the capability to create additional virtual addresses based on its main Address. These virtual addresses are known as Virtual Addresses.\n\n1. Creation Process:​\nVirtual Addresses are generated by applying a hash function to the main Address of the contract.\nThis process allows contracts to create multiple unique identifiers dynamically.\n2. Use Case:​\nFor instance, in aelf blockchain, when transferring tokens using the MultiToken contract, both sender and recipient are identified by their respective Addresses.\nVirtual Addresses extend this functionality by enabling the creation of unique identifiers for specific transactions or actions within a contract.\n3. Creation Process:​\nVirtual Addresses are controlled exclusively by the primary contract.\nThis capability allows contracts to manage transactions and funds independently for each user, ensuring secure custody.\n4. Utility:​\nVirtual Addresses serve as reliable identifiers generated through business actions on the contract.\nThey are particularly useful for token transfers and other interactions where unique identification is crucial.\n\nIn summary, Virtual Addresses in aelf blockchain enhance the flexibility and security of contract interactions by providing unique identifiers derived from the main contract Address.\n\nPrevious\nBoot Sequence\nNext\nTransactions\nOverview\nUser Address\nContract Address\nContract Virtual Address\nPlatform\nTechnology\nAudit Report\nPrivacy\nTerms of Use\nCookie Policy\nDeveloper Resources\nQuick Start\nLearn\nDocs\nTools\nResources\nEcosystem\nOverview\ndApps\naelf Ventures\nBlog\nConnect\nContact Us\nCopyright © 2024 aelf"
    },
    {
      "title": "AELF Docs",
      "url": "https://docs.aelf.com/learn/boot-sequence/",
      "html": "Skip to main content\nQuick Start\nLearn\nDocs\nTools\nResources\nBlog\nSearch\nUnderstanding aelf\nCore\nCross Chain\nConsensus\nNetwork\nBoot Sequence\nAddresses\nTransactions\nSmart Contract\nACS\nTutorials\nNode Operator\nUnderstanding aelfBoot Sequence\naelf Blockchain Boot Sequence\n\nThis guide explains how the aelf Blockchain starts from initial nodes and transitions to production nodes through elections, completing the full startup process.\n\nStart Initial Nodes​\n\nTo begin the aelf Blockchain, you need to start at least one initial node. It’s recommended to start with 1-5 initial nodes.\n\nFollow these steps to start multiple nodes:​\nSetup Initial Nodes:​\nRefer to the \"Getting Started\" section for detailed steps.\nThis example uses three initial nodes.\nElection Time Configuration:​\nThe default election period is 604800 seconds (7 days).\nTo see election results faster, modify the configuration file appsettings.json to set the PeriodSeconds to a smaller value:\n{\n  \"Consensus\": {\n    \"PeriodSeconds\": 604800\n  }\n}\n\n\nBy following these steps, you can successfully start the aelf Blockchain with initial nodes and prepare for the election of production nodes.\n\nRun a Full Node\nCreate an Account for the Full Node​\n\nTo create an account for the full node, use the following command:\n\naelf-command create\n\n\nYou will receive your wallet information, which includes the mnemonic, private key, public key, and address. Here is an example of the output:\n\n   AElf [Info]: Your wallet info is : \n   AElf [Info]: Mnemonic            : major clap hurdle hammer push slogan ranch quantum reunion hope enroll repeat \n   AElf [Info]: Private Key         : 2229945cf294431183fd1d8101e27b17a1a590d3a1f7f2b9299850b24262ed8a \n   AElf [Info]: Public Key          : 04eed00eb009ccd283798e3862781cebd25ed6a4641e0e1b7d0e3b6b59025040679fc4dc0edc9de166bd630c7255188a9aeadfc832fdae0828270f77c6ef267905 \n   AElf [Info]: Address             : Q3t34SAEsxAQrSQidTRzDonWNTPpSTgH8bqu8pQUGCSWRPdRC\n\nStart the Full Node​\n\nStarting the full node involves similar steps to starting the initial nodes. However, ensure that the InitialMinerList in your configuration file matches the list from the initial node setup. Here is an example configuration:\n\n{\n  \"InitialMinerList\": [\n    \"0499d3bb14337961c4d338b9729f46b20de8a49ed38e260a5c19a18da569462b44b820e206df8e848185dac6c139f05392c268effe915c147cde422e69514cc927\",\n    \"048397dfd9e1035fdd7260329d9492d88824f42917c156aef93fd7c2e3ab73b636f482b8ceb5cb435c556bfa067445a86e6f5c3b44ae6853c7f3dd7052609ed40b\",\n    \"041cc962a51e7bbdd829a8855eca8a03fda708fdf31969251321cb31edadd564bf3c6e7ab31b4c1f49f0f206be81dbe68a75c70b293bf9d04d867ee5e415d3bf8a\"\n  ]\n}\n\n\nBy following these steps, you can successfully create an account and start your full node, ensuring it is properly configured to participate in the aelf blockchain network.\n\nFull node started successfully:​\n\nAfter starting the full node, verify its status to ensure it's properly synchronizing with the blockchain.\n\nCheck Node State​\n\nTo check the current state of the node, use the following command:\n\naelf-command get-chain-status\n\n\nThis command will output the current status of the blockchain. Here's an example of what you might see:\n\n{\n  \"ChainId\": \"AELF\",\n  \"Branches\": {\n    \"fb749177c2f43db8c7d73ea050240b9f870c40584f044b13e7ec146c460b0eff\": 2449\n  },\n  \"NotLinkedBlocks\": {},\n  \"LongestChainHeight\": 2449,\n  \"LongestChainHash\": \"fb749177c2f43db8c7d73ea050240b9f870c40584f044b13e7ec146c460b0eff\",\n  \"GenesisBlockHash\": \"ea9c0b026bd638ceb38323eb71174814c95333e39c62936a38c4e01a8f18062e\",\n  \"GenesisContractAddress\": \"pykr77ft9UUKJZLVq15wCH8PinBSjVRQ12sD1Ayq92mKFsJ1i\",\n  \"LastIrreversibleBlockHash\": \"66638f538038bd56357f3cf205424e7393c5966830ef0d16a75d4a117847e0bc\",\n  \"LastIrreversibleBlockHeight\": 2446,\n  \"BestChainHash\": \"fb749177c2f43db8c7d73ea050240b9f870c40584f044b13e7ec146c460b0eff\",\n  \"BestChainHeight\": 2449\n}\n\nUnderstanding the Output​\n\nWhen running a full node on the aelf blockchain network, the following key information is crucial for monitoring and understanding the node's status:\n\nChainId: The identifier of the blockchain.\nBranches: Current branches in the chain, showing the hash and height.\nNotLinkedBlocks: Blocks that are not yet linked to the main chain.\nLongestChainHeight: The height of the longest chain.\nLongestChainHash: The hash of the longest chain.\nGenesisBlockHash: The hash of the genesis block.\nGenesisContractAddress: The address of the genesis contract.\nLastIrreversibleBlockHash: The hash of the last irreversible block.\nLastIrreversibleBlockHeight: The height of the last irreversible block.\nBestChainHash: The hash of the best chain.\nBestChainHeight: The height of the best chain.\n\nThe BestChainHeight and LastIrreversibleBlockHeight should be increasing as the full node catches up with the initial nodes. Once the heights match, the node is fully synchronized, and you can proceed with further steps.\n\nBy following these details, you ensure that your full node is correctly set up and actively participating in the aelf blockchain network.\n\nBecome a Candidate Node​\n\nTo participate in the election process and become a candidate node, full nodes need to interact with the Election contract. Here's a step-by-step guide:\n\nStep 1: Ensure Sufficient Tokens​\n\nFull nodes must stake mortgage 10W ELF tokens to become candidates. Ensure your node's account has enough tokens. For demonstration purposes, you can transfer tokens from the initial node account to the full node account.\n\nTransfer Tokens:​\naelf-command send AElf.ContractNames.Token Transfer '{\"symbol\": \"ELF\", \"to\": \"Q3t34SAEsxAQrSQidTRzDonWNTPpSTgH8bqu8pQUGCSWRPdRC\", \"amount\": \"20000000000000\"}'\n\nCheck Balance:​\naelf-command call AElf.ContractNames.Token GetBalance '{\"symbol\": \"ELF\", \"owner\": \"Q3t34SAEsxAQrSQidTRzDonWNTPpSTgH8bqu8pQUGCSWRPdRC\"}'\n\nExpected Result:​\n{\n  \"symbol\": \"ELF\",\n  \"owner\": \"Q3t34SAEsxAQrSQidTRzDonWNTPpSTgH8bqu8pQUGCSWRPdRC\",\n  \"balance\": \"20000000000000\"\n}\n\n\nThis result confirms that the full node account has 20W ELF tokens.\n\nStep 2: Announce Candidacy​\n\nAnnounce your candidacy using the Election contract. The AnnounceElection transaction requires the admin address to be specified.\n\nAnnounce Election:​\naelf-command send AElf.ContractNames.Election AnnounceElection '{\"value\": \"Q3t34SAEsxAQrSQidTRzDonWNTPpSTgH8bqu8pQUGCSWRPdRC\"}' -a Q3t34SAEsxAQrSQidTRzDonWNTPpSTgH8bqu8pQUGCSWRPdRC\n\nStep 3: Verify Candidacy​\n\nCheck the candidate information to confirm that your full node is now a candidate.\n\nCheck Candidate Information::​\naelf-command call AElf.ContractNames.Election GetCandidateInformation '{\"value\":\"04eed00eb009ccd283798e3862781cebd25ed6a4641e0e1b7d0e3b6b59025040679fc4dc0edc9de166bd630c7255188a9aeadfc832fdae0828270f77c6ef267905\"}'\n\nExpected Result:​\n{\n  \"terms\": [],\n  \"pubkey\": \"04eed00eb009ccd283798e3862781cebd25ed6a4641e0e1b7d0e3b6b59025040679fc4dc0edc9de166bd630c7255188a9aeadfc832fdae0828270f77c6ef267905\",\n  \"producedBlocks\": \"0\",\n  \"missedTimeSlots\": \"0\",\n  \"continualAppointmentCount\": \"0\",\n  \"announcementTransactionId\": \"8cc8eb5de35e390e4f7964bbdc7edc433498b041647761361903c6165b9f8659\",\n  \"isCurrentCandidate\": true\n}\n\n\nThis result indicates that the full node is now a candidate for the election, with the isCurrentCandidate field set to true.\n\nBy following these steps, your full node can successfully enter the election process and participate as a candidate node in the aelf blockchain network.\n\nUser vote election\n\nTo demonstrate user voting in the election, follow these steps to create a user account, transfer tokens to the account, and then vote for a candidate node.\n\nStep 1: Create a User Account​\n\nCreate a new user account using the command below:\n\naelf-command create\n\n\nYou will receive the following wallet information:\n\nAElf [Info]: Your wallet info is :\nAElf [Info]: Mnemonic            : walnut market museum play grunt chuckle hybrid accuse relief misery share meadow\nAElf [Info]: Private Key         : 919a220fac2d80e674a256f2367ac840845f344269f4dcdd56d37460de17f947\nAElf [Info]: Public Key          : 04794948de40ffda2a6c884d7e6a99bb8e42b8b96b9ee5cc4545da3a1d5f7725eec93de62ddbfb598ef6f04fe52aa310acc7d17abeeea3946622573c4b0b2433ac\nAElf [Info]: Address             : ZBBPU7DMVQ72YBQNmaKTDPKaAkHNzzA3naH5B6kE7cBm8g1ei\n\nStep 2: Transfer Tokens to the User Account​\n\nAfter the user account is created successfully, we will first transfer some tokens to the account for voting.\n\nTransfer Tokens:​\naelf-command send AElf.ContractNames.Token Transfer '{\"symbol\": \"ELF\", \"to\": \"ZBBPU7DMVQ72YBQNmaKTDPKaAkHNzzA3naH5B6kE7cBm8g1ei\", \"amount\": \"200000000000\"}'\n\nConfirm the Balance:​\naelf-command call AElf.ContractNames.Token GetBalance '{\"symbol\": \"ELF\", \"owner\": \"ZBBPU7DMVQ72YBQNmaKTDPKaAkHNzzA3naH5B6kE7cBm8g1ei\"}'\n\nExpected Result:​\n{\n  \"symbol\": \"ELF\",\n  \"owner\": \"ZBBPU7DMVQ72YBQNmaKTDPKaAkHNzzA3naH5B6kE7cBm8g1ei\",\n  \"balance\": \"200000000000\"\n}\n\n\nThis confirms the user account has received the tokens.\n\nStep 3: Vote for a Candidate Node​\n\nUse the Election contract to vote for a candidate node. Here, we vote for the node with the public key 04eed00eb009ccd283798e3862781cebd25ed6a4641e0e1b7d0e3b6b59025040679fc4dc0edc9de166bd630c7255188a9aeadfc832fdae0828270f77c6ef267905.\n\nCast Vote:​\naelf-command send AElf.ContractNames.Election Vote '{\"candidatePubkey\":\"04eed00eb009ccd283798e3862781cebd25ed6a4641e0e1b7d0e3b6b59025040679fc4dc0edc9de166bd630c7255188a9aeadfc832fdae0828270f77c6ef267905\",\"amount\":2000000000,\"endTimestamp\":{\"seconds\":1600271999,\"nanos\":999000}}' -a ZBBPU7DMVQ72YBQNmaKTDPKaAkHNzzA3naH5B6kE7cBm8g1ei\n\nStep 4: Verify the Vote​\n\nCheck the votes received by the candidate node to ensure your vote has been counted.\n\nCheck Candidate Votes:​\naelf-command call AElf.ContractNames.Election GetCandidateVote '{\"value\":\"04eed00eb009ccd283798e3862781cebd25ed6a4641e0e1b7d0e3b6b59025040679fc4dc0edc9de166bd630c7255188a9aeadfc832fdae0828270f77c6ef267905\"}'\n\nExpected Result:​\n{\n  \"obtainedActiveVotingRecordIds\": [\n    \"172375e9cee303ce60361aa73d7326920706553e80f4485f97ffefdb904486f1\"\n  ],\n  \"obtainedWithdrawnVotingRecordIds\": [],\n  \"obtainedActiveVotingRecords\": [],\n  \"obtainedWithdrawnVotesRecords\": [],\n  \"obtainedActiveVotedVotesAmount\": \"2000000000\",\n  \"allObtainedVotedVotesAmount\": \"2000000000\",\n  \"pubkey\": \"04eed00eb009ccd283798e3862781cebd25ed6a4641e0e1b7d0e3b6b59025040679fc4dc0edc9de166bd630c7255188a9aeadfc832fdae0828270f77c6ef267905\"\n}\n\n\nThis result confirms that the full node has successfully obtained 20 votes from the user account.\n\nBecome production node\n\nIn the next election, the candidate nodes with the highest number of votes (up to 17) will automatically be elected as production nodes. You can view the current list of production nodes through the consensus contracts.\n\nViewing the Current Production Nodes​\n\nTo see the current list of production nodes, use the following command:\n\naelf-command call AElf.ContractNames.Consensus GetCurrentMinerPubkeyList '{}'\n\nExpected Result:​\n{\n  \"pubkeys\": [\n    \"0499d3bb14337961c4d338b9729f46b20de8a49ed38e260a5c19a18da569462b44b820e206df8e848185dac6c139f05392c268effe915c147cde422e69514cc927\",\n    \"048397dfd9e1035fdd7260329d9492d88824f42917c156aef93fd7c2e3ab73b636f482b8ceb5cb435c556bfa067445a86e6f5c3b44ae6853c7f3dd7052609ed40b\",\n    \"041cc962a51e7bbdd829a8855eca8a03fda708fdf31969251321cb31edadd564bf3c6e7ab31b4c1f49f0f206be81dbe68a75c70b293bf9d04d867ee5e415d3bf8a\",\n    \"04eed00eb009ccd283798e3862781cebd25ed6a4641e0e1b7d0e3b6b59025040679fc4dc0edc9de166bd630c7255188a9aeadfc832fdae0828270f77c6ef267905\"\n  ]\n}\n\n\nIn this example, the node with the public key 04eed00eb009ccd283798e3862781cebd25ed6a4641e0e1b7d0e3b6b59025040679fc4dc0edc9de166bd630c7255188a9aeadfc832fdae0828270f77c6ef267905 has been elected as a production node.\n\nAdd more production nodes\n\nTo add more production nodes, follow these steps:\n\nRepeat Steps for Creating Full Nodes: Create additional full nodes by repeating the process described earlier for creating and starting full nodes.\nNominate Additional Nodes: Follow the process of nominating these full nodes as candidate nodes and ensure they receive sufficient votes.\n\nWhen the number of initial nodes and candidate nodes exceeds the maximum number of production nodes, the initial nodes will gradually be replaced by the newly elected production nodes. Note that once an initial node is replaced, it cannot run for election again. At this point, the initial node has completed its role in starting the AElf Blockchain.\n\nExample Workflow:​\n1. Create Additional Full Nodes:​\naelf-command create\n\n2. Transfer Tokens to New Nodes:​\naelf-command send AElf.ContractNames.Token Transfer '{\"symbol\": \"ELF\", \"to\": \"<new_node_address>\", \"amount\": \"200000000000\"}'\n\n3. Nominate New Nodes as Candidates:​\naelf-command send AElf.ContractNames.Election AnnounceElection '{\"value\": \"<new_node_address>\"}' -a <new_node_address>\n\n4. Vote for New Candidates:​\naelf-command send AElf.ContractNames.Election Vote '{\"candidatePubkey\":\"<new_node_pubkey>\",\"amount\":2000000000,\"endTimestamp\":{\"seconds\":<timestamp>,\"nanos\":999000}}' -a <user_address>\n\n\nBy following these steps, you can ensure a smooth transition from initial nodes to production nodes, maintaining the stability and performance of the AElf Blockchain.\n\nPrevious\nNetwork\nNext\nAddresses\nStart Initial Nodes\nFollow these steps to start multiple nodes:\nCreate an Account for the Full Node\nStart the Full Node\nFull node started successfully:\nUnderstanding the Output\nBecome a Candidate Node\nStep 1: Ensure Sufficient Tokens\nStep 2: Announce Candidacy\nStep 3: Verify Candidacy\nExample Workflow:\nPlatform\nTechnology\nAudit Report\nPrivacy\nTerms of Use\nCookie Policy\nDeveloper Resources\nQuick Start\nLearn\nDocs\nTools\nResources\nEcosystem\nOverview\ndApps\naelf Ventures\nBlog\nConnect\nContact Us\nCopyright © 2024 aelf"
    },
    {
      "title": "Network | AELF Docs",
      "url": "https://docs.aelf.com/learn/network/",
      "html": "Skip to main content\nQuick Start\nLearn\nDocs\nTools\nResources\nBlog\nSearch\nUnderstanding aelf\nCore\nCross Chain\nConsensus\nNetwork\nBoot Sequence\nAddresses\nTransactions\nSmart Contract\nACS\nTutorials\nNode Operator\nUnderstanding aelfNetwork\nNetwork\nIntroduction​\n\nThe network layer in aelf is vital for maintaining connections and communication between nodes. It supports higher-level logic like synchronization and allows node operators to monitor and manage network operations. aelf uses gRPC for connections to keep the design simple and flexible.\n\nArchitecture​\n\nThe network consists of three layers:\n\naelf.OS\n\nHandles network events.\nRuns background tasks for network operations.\n\naelf.OS.Core.Network\n\nProvides services to higher levels.\nDefines infrastructure components and types.\n\naelf.OS.Network.Grpc\n\nImplements the infrastructure layer using gRPC.\nManages low-level functions like serialization and retrying.\naelf.OS​\n\nThis layer monitors and handles network-related events:\n\nTransaction Accepted Event: When a transaction is verified.\nBlock Mined Event: When a block is packaged.\nBlock Accepted Event: When a block is executed successfully.\nNew Irreversible Block Found Event: When a new irreversible block is found.\n\nIt also performs regular tasks:\n\nPeer Health Check: Ensures connected peers are healthy.\nPeer Retry Connection: Attempts to reconnect with unhealthy peers.\nNetwork Node Discovery: Finds new nodes.\naelf.OS.Core.Network​\n\nThis core module includes:\n\nNetworkService: Manages sending/receiving requests, broadcasting items to peers, and handling network exceptions.\nIPeerPool/PeerPool: Manages active peer connections.\nIPeer: Defines peer interactions and metrics.\nIaelfNetworkServer: Manages network lifecycle and connections.\naelf.OS.Network.Grpc​\n\nImplements the infrastructure layer using gRPC:\n\nGrpcPeer: Implements IPeer.\nGrpcStreamPeer: Client-side IPeer implementation (node version >=1.4.0).\nGrpcStreamBackPeer: Server-side IPeer implementation (node version >=1.4.0).\nGrpcNetworkServer: Implements IaelfNetworkServer.\nGrpcServerService: Manages network service interfaces and data exchange.\n\nExtra functionalities include:\n\nSerializing and deserializing requests.\nImplementing request/response mechanisms.\nAuthentication.\nProtocol​\n\nNodes use a defined network interface protocol for normal operation and data synchronization.\n\nConnection​\nDoHandshake​\n\nWhen a node connects, it exchanges handshake information. This includes chain status, current height, and more.\n\nRequest:\nrpc DoHandshake (HandshakeRequest) returns (HandshakeReply) {}\n\nHandshake Message:\nmessage Handshake {\n    HandshakeData handshake_data = 1;\n    bytes signature = 2;\n    bytes session_id = 3;\n}\n\nHandshakeData Message:\nmessage HandshakeData {\n    int32 chain_id = 1;\n    int32 version = 2;\n    int32 listening_port = 3;\n    bytes pubkey = 4;\n    aelf.Hash best_chain_hash = 5;\n    int64 best_chain_height = 6;\n    aelf.Hash last_irreversible_block_hash = 7;\n    int64 last_irreversible_block_height = 8;\n    google.protobuf.Timestamp time = 9;\n}\n\nConfirmHandshake​\n\nConfirms the handshake with the target node.\n\nRequest:\nrpc ConfirmHandshake (ConfirmHandshakeRequest) returns (VoidReply) {}\n\nBroadcasting​\nBlockBroadcastStream​\n\nReceives block information after packaging.\n\nRequest:\nrpc BlockBroadcastStream (stream BlockWithTransactions) returns (VoidReply) {}\n\nTransactionBroadcastStream​\n\nReceives forwarded transaction information.\n\nRequest:\nrpc TransactionBroadcastStream (stream aelf.Transaction) returns (VoidReply) {}\n\nAnnouncementBroadcastStream​\n\nReceives block announcements.\n\nRequest:\nrpc AnnouncementBroadcastStream (stream BlockAnnouncement) returns (VoidReply) {}\n\nLibAnnouncementBroadcastStream​\n\nReceives last irreversible block (LIB) announcements.\n\nRequest:\nrpc LibAnnouncementBroadcastStream (stream LibAnnouncement) returns (VoidReply) {}\n\nBlock Request​\nRequestBlock​\n\nRequests a single block.\n\nRequest:\nrpc RequestBlock (BlockRequest) returns (BlockReply) {}\n\nRequestBlocks​\n\nRequests multiple blocks.\n\nRequest:\nrpc RequestBlocks (BlocksRequest) returns (BlockList) {}\n\nPeer Management​\nPing​\n\nVerifies network availability.\n\nRequest:\nrpc Ping (PingRequest) returns (PongReply) {}\n\nCheckHealth​\n\nPerforms health checks on peers.\n\nRequest:\nrpc CheckHealth (HealthCheckRequest) returns (HealthCheckReply) {}\n\nPrevious\nConsensus\nNext\nBoot Sequence\nIntroduction\nArchitecture\naelf.OS\naelf.OS.Core.Network\naelf.OS.Network.Grpc\nProtocol\nConnection\nBroadcasting\nBlock Request\nPeer Management\nPlatform\nTechnology\nAudit Report\nPrivacy\nTerms of Use\nCookie Policy\nDeveloper Resources\nQuick Start\nLearn\nDocs\nTools\nResources\nEcosystem\nOverview\ndApps\naelf Ventures\nBlog\nConnect\nContact Us\nCopyright © 2024 aelf"
    },
    {
      "title": "Consensus | AELF Docs",
      "url": "https://docs.aelf.com/learn/consensus/",
      "html": "Skip to main content\nQuick Start\nLearn\nDocs\nTools\nResources\nBlog\nSearch\nUnderstanding aelf\nCore\nCross Chain\nConsensus\nNetwork\nBoot Sequence\nAddresses\nTransactions\nSmart Contract\nACS\nTutorials\nNode Operator\nUnderstanding aelfConsensus\nConsensus\nOverview​\n\nConsensus is crucial for blockchains as it decides which transactions are included in the block and their order. aelf's block formation mechanism is more complex than Bitcoin and Ethereum due to its need to record Side Chain data and its cloud-based service design. Miners must update info from multiple parallel Chains. aelf uses AEDPoS consensus for high-frequency and predictable block formation.\n\nIn aelf, the consensus protocol has two parts: election and scheduling. Election decides who produces blocks, and scheduling decides when.\n\nCore Data Center​\n\nCore Data Centers, also known as Miners or Block Producers, act like parliament members in the aelf blockchain. aelf has 2N+1 Core Data Centers, starting with 8 and increasing by 1 each year. These nodes enforce aelf’s consensus rules, relay transactions, confirm transactions, package blocks, and transfer data. They also act as miners for some Side Chains and are elected by ELF token holders.\n\nValidate Data Center​\n\nAnyone can join the election by locking ELF tokens. The top (2N+1)*5 nodes become Validate Data Centers, with N starting at 8 and increasing by 1 each year.\n\nAEDPoS Process​\nRound​\n\naelf operates in units called \"rounds.\" In each round, one Core Data Center produces one block and has one extra transaction at the end.\n\nMain Processes​\nPre-Verification​\n\nBefore generating blocks in round (t+1), a node’s status in round t is verified by checking hash(in_node(t)) = out_node(t).\n\nOrder Calculation​\n\nIn each round, Core Data Centers have (N+1) block generation time slots.\n\nThe order and signature for each node in the first round are arbitrary. From the second round, the signature is calculated using sig_node(t+1) = hash(in_node(t) + all_t) where\n\nHere node[i][t], means the node is processing the i-th transaction in round t.\n\nFrom round 3, the order is based on the previous round’s order and signature. In round (t+1), we traverse the signature of nodes at round t in order. The ordering of a node in (t+1) is calculated by\n\nIf conflicts occur, the node is assigned to the next available place. The extra transaction node is calculated from the first place node's signature of the previous round.\n\nTiming​\n\nNodes have 4 seconds to process transactions. Failure to submit within this time results in a penalty. If a node fails twice consecutively, it enters a penalty period, increasing exponentially with each failure.\n\nFork Handling​\n\nOnly one node generates blocks at a time to avoid forks. If multiple orphan nodes occur, the longest chain is adopted. Vicious nodes mining in two chains are voted out.\n\nIrreversible Block​\n\nSome block links (block height to hash value) are irreversible, confirmed by the AEDPoS mechanism during round changes.\n\nPrevious\nCross Chain Transfer\nNext\nNetwork\nOverview\nCore Data Center\nValidate Data Center\nAEDPoS Process\nRound\nMain Processes\nIrreversible Block\nPlatform\nTechnology\nAudit Report\nPrivacy\nTerms of Use\nCookie Policy\nDeveloper Resources\nQuick Start\nLearn\nDocs\nTools\nResources\nEcosystem\nOverview\ndApps\naelf Ventures\nBlog\nConnect\nContact Us\nCopyright © 2024 aelf"
    },
    {
      "title": "AELF Docs",
      "url": "https://docs.aelf.com/learn/cross-chain/",
      "html": "Skip to main content\nQuick Start\nLearn\nDocs\nTools\nResources\nBlog\nSearch\nUnderstanding aelf\nCore\nCross Chain\nIntroduction\nArchitecture\nCross Chain Verification\nVerify\nCross Chain Transfer\nConsensus\nNetwork\nBoot Sequence\nAddresses\nTransactions\nSmart Contract\nACS\nTutorials\nNode Operator\nUnderstanding aelfCross Chain\nCross Chain\n📄️ Introduction\n\nOne of the major issues with current blockchain systems is scalability. This is mainly due to congestion problems in existing blockchains. The core problem is that when a single chain needs to sequentially order and process transactions, a popular dApp consuming a lot of resources can negatively impact other dApps.\n\n📄️ Architecture\n\nOverview\n\n📄️ Cross Chain Verification\n\nVerification is the key feature that enables side chains. Because side chains do not have direct knowledge about other side chains, they need a way to verify information from other chains. Side chains need the ability to verify that a transaction was included in another side chain's block.\n\n📄️ Verify\n\nThis section provides guidance on verifying transactions across different blockchain chains, assuming that a side chain has already been deployed and indexed by the main chain.\n\n📄️ Cross Chain Transfer\n\nCross chain transfer is one of the most commonly used cases when it comes to cross chain verification. aelf already supports cross chain transfer functionality in its contract. This section will explain how to transfer tokens across chains. It assumes a side chain is already deployed and has been indexed by the main chain.\n\nPrevious\nCore Implementation\nNext\nIntroduction\nPlatform\nTechnology\nAudit Report\nPrivacy\nTerms of Use\nCookie Policy\nDeveloper Resources\nQuick Start\nLearn\nDocs\nTools\nResources\nEcosystem\nOverview\ndApps\naelf Ventures\nBlog\nConnect\nContact Us\nCopyright © 2024 aelf"
    },
    {
      "title": "AELF Docs",
      "url": "https://docs.aelf.com/learn/core/",
      "html": "Skip to main content\nQuick Start\nLearn\nDocs\nTools\nResources\nBlog\nSearch\nUnderstanding aelf\nCore\nCore Introduction\nCore Implementation\nCross Chain\nConsensus\nNetwork\nBoot Sequence\nAddresses\nTransactions\nSmart Contract\nACS\nTutorials\nNode Operator\nUnderstanding aelfCore\nCore\n📄️ Core Introduction\n\nOverview of aelf, its architecture, and key features.\n\n📄️ Core Implementation\n\nDesign Principles\n\nPrevious\nUnderstanding aelf\nNext\nCore Introduction\nPlatform\nTechnology\nAudit Report\nPrivacy\nTerms of Use\nCookie Policy\nDeveloper Resources\nQuick Start\nLearn\nDocs\nTools\nResources\nEcosystem\nOverview\ndApps\naelf Ventures\nBlog\nConnect\nContact Us\nCopyright © 2024 aelf"
    },
    {
      "title": "Creation of a Side Chain | AELF Docs",
      "url": "https://docs.aelf.com/quick-start/node-operators/explore-running-aelf-side-chain/",
      "html": "Skip to main content\nQuick Start\nLearn\nDocs\nTools\nResources\nBlog\nSearch\nQuick Start\nFor Developers\nFor Node Operators\nOperations\nRun a Mainnet Node\nSimulation in the Local Environment\nCreation of a Side Chain\nQuick StartFor Node OperatorsCreation of a Side Chain\nCreation of a Side Chain\n\nSide chains can be created in the aelf ecosystem to enable scalability. This section introduces the process in detail.\n\nSide Chain Creation API​\n\nAnyone can request the creation of a side chain in the aelf ecosystem. The proposer/creator of a new side chain needs to request the creation through the cross-chain contract on the main chain. The request contains fields that determine the type of side chain to be created.\n\nAPI for Proposing Side Chain Creation​\n\nThe fields in the SideChainCreationRequest determine the type of side chain that is created. For more details, follow RequestSideChainCreation in the Crosschain contract documentation.\n\nUpon creating a new proposal for the side chain, the ProposalCreated event containing the proposal ID will be fired. A parliament organization, specified since the chain's launch, will approve this proposal within 24 hours (refer to the Parliament contract documentation for details). The proposer can release the side chain creation request with the proposal ID once it can be released. Refer to ReleaseSideChainCreation in the Crosschain contract documentation.\n\nOnce the side chain is created, the SideChainCreatedEvent containing the chain ID will be fired.\n\nThe side chain node can be launched once it is created on the main chain. Ensure the side chain ID from the creation result is configured correctly before launching the side chain node. Make sure the cross-chain communication context is correctly set, as the side chain node will request main chain node for chain initialization data. For more details, check the side chain node running tutorial.\n\nSide Chain Types​\n\nTwo types of side chains currently exist: exclusive and shared. An exclusive side chain allows developers to choose the transaction fee model and set the transaction fee price. Only the creator of an exclusive side chain can propose deploying a new contract.\n\nPaying for Side Chain​\nIndexing Fee​\n\nThe indexing fee is paid for side chain indexing. You can specify the indexing fee price and prepayments amount when requesting side chain creation. The cross-chain contract charges prepayments once the side chain is created and pays the miner who indexes the side chain block every time.\n\nResource Fee​\n\nDevelopers of an exclusive side chain pay producers for running it by paying CPU, RAM, DISK, and NET resource tokens. This model is called charge-by-time. The amount the side chain creator must share with the producers is set after the chain's creation. The exclusive side chain is priced according to the time used. The unit price of the fee is determined through negotiation between the production node and the developer.\n\nSimple Demo for Side Chain Creation Request​\n\nWhen a user (usually a developer) feels the need to create a new side chain on aelf, they must call the cross-chain contract and request a side chain creation. After the request, parliament organization members will either approve or reject the creation. If the request is approved, the developer must then release the proposal.\n\nStep-by-Step Code Snippets​\n\nWe'll use the aelf-js-sdk to create a new side chain. The full script will be provided at the end.\n\nThis creation of a side chain (logical, on-chain creation) is done in four steps:\n\nThe developer must allow/approve some tokens to the cross-chain contract of the main chain.\nThe developer calls the cross-chain contract of the main chain to request the creation.\nThe parliament organization members must approve this request.\nFinally, the developer must release the request to finalize the creation.\nSet-Up​\n\nTo test the creation process, you will need a producer node running and the following:\n\nA key-pair (account) created; this will be your Producer (also used to create the creation request in this tutorial).\nThe node needs to be configured with an API endpoint, account, and miner list that correspond to what is in the script.\n\nHere is the initialization code:\n\nconst AElf = require('aelf-sdk');\nconst Wallet = AElf.wallet;\n\nconst { sha256 } = AElf.utils;\n\n// set the private key of the block producer.\n// REPLACE\nconst defaultPrivateKey = 'e119487fea0658badc42f089fbaa56de23d8c0e8d999c5f76ac12ad8ae897d76';\nconst defaultPrivateKeyAddress = 'HEtBQStfqu53cHVC3PxJU6iGP3RGxiNUfQGvAPTjfrF3ZWH3U';\n\n// load the wallet associated with your block producer's account.\nconst wallet = Wallet.getWalletByPrivateKey(defaultPrivateKey);\n\n// API link to the node\n// REPLACE\nconst aelf = new AElf(new AElf.providers.HttpProvider('http://127.0.0.1:1234'));\n\n// names of the contracts that will be used.\nconst tokenContractName = 'AElf.ContractNames.Token';\nconst parliamentContractName = 'AElf.ContractNames.Parliament';\nconst crossChainContractName = 'AElf.ContractNames.CrossChain';\n\n...\n\nconst createSideChain = async () => {\n    // check the chain status to make sure the node is running\n    const chainStatus = await aelf.chain.getChainStatus({sync: true});\n    const genesisContract = await aelf.chain.contractAt(chainStatus.GenesisContractAddress, wallet)\n        .catch((err) => {\n        console.log(err);\n        });\n\n    // get the addresses of the contracts that we'll need to call\n    const tokenContractAddress = await genesisContract.GetContractAddressByName.call(sha256(tokenContractName));\n    const parliamentContractAddress = await genesisContract.GetContractAddressByName.call(sha256(parliamentContractName));\n    const crossChainContractAddress = await genesisContract.GetContractAddressByName.call(sha256(crossChainContractName));\n\n    // build the aelf-sdk contract instance objects\n    const parliamentContract = await aelf.chain.contractAt(parliamentContractAddress, wallet);\n    const tokenContract = await aelf.chain.contractAt(tokenContractAddress, wallet);\n    const crossChainContract = await aelf.chain.contractAt(crossChainContractAddress, wallet);\n\n    ...\n}\n\n\nWhen running the script, the createSideChain function will be executed and will run through the full process of creating the side chain.\n\nCreation of the Side Chain​\nSet the Allowance​\n\nFirst, the developer must approve some ELF tokens for use by the cross-chain contract.\n\nvar setAllowance = async function (tokenContract, crossChainContractAddress) {\n  // set some allowance to the cross-chain contract\n  const approvalResult = await tokenContract.Approve({\n    symbol: \"ELF\",\n    spender: crossChainContractAddress,\n    amount: 20000,\n  });\n\n  let approveTransactionResult = await pollMining(approvalResult.TransactionId);\n};\n\nCreation Request​\n\nTo request a side chain creation, the developer must call RequestSideChainCreation on the cross-chain contract. This creates a proposal with the Parliament contract. After calling this method, a ProposalCreated log will be created containing the ProposalId.\n\nrpc RequestSideChainCreation(SideChainCreationRequest) returns (google.protobuf.Empty){}\n\nmessage SideChainCreationRequest {\n    int64 indexing_price = 1; // The cross chain indexing price.\n    int64 locked_token_amount = 2; // Initial locked balance for a new side chain.\n    bool is_privilege_preserved = 3; // Creator privilege boolean flag.\n    SideChainTokenCreationRequest side_chain_token_creation_request = 4; // Side chain token information.\n    repeated SideChainTokenInitialIssue side_chain_token_initial_issue_list = 5; // A list of accounts and amounts that will be issued when the chain starts.\n    map<string, int32> initial_resource_amount = 6; // The initial rent resources.\n}\n\nmessage SideChainTokenCreationRequest{\n    string side_chain_token_symbol = 1; // Token symbol of the side chain to be created.\n    string side_chain_token_name = 2; // Token name of the side chain to be created.\n    int64 side_chain_token_total_supply = 3; // Token total supply of the side chain to be created.\n    int32 side_chain_token_decimals = 4; // Token decimals of the side chain to be created.\n}\n\nmessage SideChainTokenInitialIssue{\n    aelf.Address address = 1; // The account that will be issued.\n    int64 amount = 2; // The amount that will be issued.\n}\n\n\nIn order for the creation request to succeed, some assertions must pass:\n\nThe Sender can only have one pending request at any time.\nThe locked_token_amount cannot be lower than the indexing price.\nIf is_privilege_preserved is true (exclusive side chain), the token initial issue list cannot be empty and all with an amount greater than 0.\nIf is_privilege_preserved is true (exclusive side chain), the initial_resource_amount must contain all resource tokens of the chain, and the value must be greater than 0.\nThe allowance approved to cross-chain contract from the proposer (Sender of the transaction) cannot be lower than the locked_token_amount.\nNo need to provide data about side chain token if is_privilege_preserved is false.\nvar sideChainCreationRequest = async function (crossChainContract) {\n  // call the cross-chain contract to request the creation\n  const creationRequestResult =\n    await crossChainContract.RequestSideChainCreation({\n      indexing_price: 1,\n      locked_token_amount: 20000,\n      is_privilege_preserved: true,\n      side_chain_token_creation_request: {\n        side_chain_token_symbol: \"MEGA\",\n        side_chain_token_name: \"MEGA\",\n        side_chain_token_total_supply: 100000000,\n        side_chain_token_decimals: 8,\n      },\n      side_chain_token_initial_issue_list: [\n        {\n          address: defaultPrivateKeyAddress,\n          amount: 10000000,\n        },\n      ],\n      initial_resource_amount: {\n        CPU: 100,\n        RAM: 100,\n        DISK: 100,\n        NET: 100,\n      },\n    });\n\n  let sideChainProposalResult = await pollMining(\n    creationRequestResult.TransactionId\n  );\n  let logs = parseLogs(sideChainProposalResult.Logs);\n  let proposalId = logs.ProposalId;\n};\n\n\nThe cross-chain contract emits an event containing the ProposalId. This is needed for the last step.\n\nApprove the Proposal​\n\nThis is where the parliament organization members approve the proposal:\n\nvar proposalApproveTx = await parliamentContract.Approve(deserializedLogs[0].proposalId);\n\nawait pollMining(proposalApproveTx.TransactionId);\n\n\nNote: when calling Approve it will be the Sender of the transaction that approves. Here the script is set to use the key of one parliament organization member, see full script at the end.\n\nRelease the Proposal​\n\nThis part of the script releases the proposal:\n\nvar releaseResult = await crossChainContract.ReleaseSideChainCreation({\n    proposalId: deserializedLogs[0].proposalId\n});\n\nlet releaseTxResult = await pollMining(releaseResult.TransactionId);\n\n// Parse the logs to get the chain id.\nlet sideChainCreationEvent = crossChainContract.deserializeLog(releaseTxResult.Logs, 'SideChainCreatedEvent');\n\n\nThis is the last step involved in creating a side chain, after this the chain id of the new side chain is accessible in the SideChainCreatedEvent event log.\n\nComplete Script​\n\nThis script demonstrates the essential steps to create a side chain in the aelf ecosystem. The developer must approve some ELF tokens, request the side chain creation, get approval from the parliament organization, and finally release the proposal to create the side chain. Ensure to set the proper configurations and values as per your blockchain environment.\n\nconst AElf = require(\"aelf-sdk\");\nconst Wallet = AElf.wallet;\n\nconst { sha256 } = AElf.utils;\n\n// set the private key of the block producer\nconst defaultPrivateKey =\n  \"e119487fea0658badc42f089fbaa56de23d8c0e8d999c5f76ac12ad8ae897d76\";\nconst defaultPrivateKeyAddress =\n  \"HEtBQStfqu53cHVC3PxJU6iGP3RGxiNUfQGvAPTjfrF3ZWH3U\";\n\nconst wallet = Wallet.getWalletByPrivateKey(defaultPrivateKey);\n\n// link to the node\nconst aelf = new AElf(new AElf.providers.HttpProvider(\"http://127.0.0.1:8000\"));\n\nif (!aelf.isConnected()) {\n  console.log(\"Could not connect to the node.\");\n}\n\nconst tokenContractName = \"AElf.ContractNames.Token\";\nconst parliamentContractName = \"AElf.ContractNames.Parliament\";\nconst crossChainContractName = \"AElf.ContractNames.CrossChain\";\n\nvar pollMining = async function (transactionId) {\n  console.log(`>> Waiting for ${transactionId} the transaction to be mined.`);\n\n  for (i = 0; i < 10; i++) {\n    const currentResult = await aelf.chain.getTxResult(transactionId);\n    // console.log('transaction status: ' + currentResult.Status);\n\n    if (currentResult.Status === \"MINED\") return currentResult;\n\n    await new Promise((resolve) => setTimeout(resolve, 2000)).catch(\n      function () {\n        console.log(\"Promise Rejected\");\n      }\n    );\n  }\n};\n\nvar setAllowance = async function (tokenContract, crossChainContractAddress) {\n  console.log(\"\\n>>>> Setting allowance for the cross-chain contract.\");\n\n  // set some allowance to the cross-chain contract\n  const approvalResult = await tokenContract.Approve({\n    symbol: \"ELF\",\n    spender: crossChainContractAddress,\n    amount: 20000,\n  });\n\n  await pollMining(approvalResult.TransactionId);\n};\n\nvar checkAllowance = async function (tokenContract, owner, spender) {\n  console.log(\"\\n>>>> Checking the cross-chain contract's allowance\");\n\n  const checkAllowanceTx = await tokenContract.GetAllowance.call({\n    symbol: \"ELF\",\n    owner: owner,\n    spender: spender,\n  });\n\n  console.log(\n    `>> allowance to the cross-chain contract: ${checkAllowanceTx.allowance} ${checkAllowanceTx.symbol}`\n  );\n};\n\nconst createSideChain = async () => {\n  // get the status of the chain in order to get the genesis contract address\n  console.log(\"Starting side chain creation script\\n\");\n\n  const chainStatus = await aelf.chain.getChainStatus({ sync: true });\n  const genesisContract = await aelf.chain\n    .contractAt(chainStatus.GenesisContractAddress, wallet)\n    .catch((err) => {\n      console.log(err);\n    });\n\n  // get the addresses of the contracts that we'll need to call\n  const tokenContractAddress =\n    await genesisContract.GetContractAddressByName.call(\n      sha256(tokenContractName)\n    );\n  const parliamentContractAddress =\n    await genesisContract.GetContractAddressByName.call(\n      sha256(parliamentContractName)\n    );\n  const crossChainContractAddress =\n    await genesisContract.GetContractAddressByName.call(\n      sha256(crossChainContractName)\n    );\n\n  // build the aelf-sdk contract object\n  const parliamentContract = await aelf.chain.contractAt(\n    parliamentContractAddress,\n    wallet\n  );\n  const tokenContract = await aelf.chain.contractAt(\n    tokenContractAddress,\n    wallet\n  );\n  const crossChainContract = await aelf.chain.contractAt(\n    crossChainContractAddress,\n    wallet\n  );\n\n  // 1. set and check the allowance, spender is the cross-chain contract\n  await setAllowance(tokenContract, crossChainContractAddress);\n  await checkAllowance(\n    tokenContract,\n    defaultPrivateKeyAddress,\n    crossChainContractAddress\n  );\n\n  // 2. request the creation of the side chain with the cross=chain contract\n  console.log(\"\\n>>>> Requesting the side chain creation.\");\n  const sideChainCreationRequestTx =\n    await crossChainContract.RequestSideChainCreation({\n      indexingPrice: 1,\n      lockedTokenAmount: \"20000\",\n      isPrivilegePreserved: true,\n      sideChainTokenCreationRequest: {\n        sideChainTokenDecimals: 8,\n        sideChainTokenName: \"SCATokenName\",\n        sideChainTokenSymbol: \"SCA\",\n        sideChainTokenTotalSupply: \"100000000000000000\",\n      },\n      sideChainTokenInitialIssueList: [\n        {\n          address: \"28Y8JA1i2cN6oHvdv7EraXJr9a1gY6D1PpJXw9QtRMRwKcBQMK\",\n          amount: \"1000000000000000\",\n        },\n      ],\n      initialResourceAmount: { CPU: 2, RAM: 4, DISK: 512, NET: 1024 },\n    });\n\n  let sideChainCreationRequestTxResult = await pollMining(\n    sideChainCreationRequestTx.TransactionId\n  );\n\n  // deserialize the log to get the proposal's ID.\n  let deserializedLogs = parliamentContract.deserializeLog(\n    sideChainCreationRequestTxResult.Logs,\n    \"ProposalCreated\"\n  );\n  console.log(\n    `>> side chain creation request proposal id ${JSON.stringify(\n      deserializedLogs[0].proposalId\n    )}`\n  );\n\n  // 3. Approve the proposal\n  console.log(\"\\n>>>> Approving the proposal.\");\n\n  var proposalApproveTx = await parliamentContract.Approve(\n    deserializedLogs[0].proposalId\n  );\n  await pollMining(proposalApproveTx.TransactionId);\n\n  // 3. Release the side chain\n  console.log(\"\\n>>>> Release the side chain.\");\n\n  var releaseResult = await crossChainContract.ReleaseSideChainCreation({\n    proposalId: deserializedLogs[0].proposalId,\n  });\n\n  let releaseTxResult = await pollMining(releaseResult.TransactionId);\n\n  // Parse the logs to get the chain id.\n  let sideChainCreationEvent = crossChainContract.deserializeLog(\n    releaseTxResult.Logs,\n    \"SideChainCreatedEvent\"\n  );\n  console.log(\"Chain chain created : \");\n  console.log(sideChainCreationEvent);\n};\n\ncreateSideChain().then(() => {\n  console.log(\"Done.\");\n});\n\n\nNote: Replace the placeholders in the script with actual values and logic for your use case.\n\nNext, we can move on to Running a Side Chain.\n\nPrevious\nSimulation in the Local Environment\nSide Chain Creation API\nAPI for Proposing Side Chain Creation\nSide Chain Types\nPaying for Side Chain\nIndexing Fee\nResource Fee\nSimple Demo for Side Chain Creation Request\nStep-by-Step Code Snippets\nSet-Up\nCreation of the Side Chain\nComplete Script\nPlatform\nTechnology\nAudit Report\nPrivacy\nTerms of Use\nCookie Policy\nDeveloper Resources\nQuick Start\nLearn\nDocs\nTools\nResources\nEcosystem\nOverview\ndApps\naelf Ventures\nBlog\nConnect\nContact Us\nCopyright © 2024 aelf"
    },
    {
      "title": "Simulation in the Local Environment | AELF Docs",
      "url": "https://docs.aelf.com/quick-start/node-operators/simulation-in-local-environment/",
      "html": "Skip to main content\nQuick Start\nLearn\nDocs\nTools\nResources\nBlog\nSearch\nQuick Start\nFor Developers\nFor Node Operators\nOperations\nRun a Mainnet Node\nSimulation in the Local Environment\nCreation of a Side Chain\nQuick StartFor Node OperatorsSimulation in the Local Environment\nSimulation in the Local Environment\nSet up a Full Node​\n\nTo simulate BP nodes in a local environment, you need to set up at least three nodes, as a single node cannot become a BP. BP elections occur every 7 days, but for this tutorial, we'll change the term to 120 seconds. Follow the steps below:\n\nFind the appsettings.json file in /.../src/AElf.Launcher and configure the public keys of the three nodes:\n\n\"Consensus\": {\n    \"InitialMinerList\": [\n        \"04884d9563b3b67a5*****526dd489e3805211cba710d956718*****\",\n        \"045670526219d7315*****8629891b0617ab605e646ae78961c*****\",\n        \"046a5913eae5fee3d*****3826beb2b7109b5141679a1927338*****\"\n    ],\n    \"MiningInterval\": 4000,\n    \"StartTimestamp\": 0,\n    \"PeriodSeconds\": 120,\n    \"MinerIncreaseInterval\": 31536000\n}\n\n\nChange PeriodSeconds from 604800 to 120 for a 2-minute election term.\n\nShut down nodes and delete all Redis data. Restart your multi-nodes.\n\nBecome a Candidate Node\n\nStake 100,000 ELF to join the node election. Ensure you have enough balance by checking with:\n\naelf-command call AElf.ContractNames.Token GetBalance '{\"symbol\": \"ELF\", \"owner\": \"YOUR_ADDRESS\"}'\n\n\nIf balance < 100,005 ELF, transfer ELF tokens using:\n\naelf-command send AElf.ContractNames.Token Transfer '{\"symbol\": \"ELF\", \"to\": \"YOUR_ADDRESS\", \"amount\": \"10000000000000\"}'\n\n\nAnnounce your candidacy:\n\naelf-command send AElf.ContractNames.Election AnnounceElection '{\"value\": \"YOUR_ADDRESS\"}' -a YOUR_ADDRESS\n\n\nCheck candidate information:\n\naelf-command call AElf.ContractNames.Election GetCandidateInformation '{\"value\":\"YOUR_PUBLIC_KEY\"}'\n\nUsers Vote for Nodes\n\nCreate a user account:\n\naelf-command create\n\n\nTransfer ELF to the new account for voting (e.g., 2000 ELF):\n\naelf-command send AElf.ContractNames.Token Transfer '{\"symbol\": \"ELF\", \"to\": \"USER_ADDRESS\", \"amount\": \"200000000000\"}'\n\n\nCheck balance of the new account:\n\naelf-command call AElf.ContractNames.Token GetBalance '{\"symbol\": \"ELF\", \"owner\": \"USER_ADDRESS\"}'\n\n\nVote for the candidate node (e.g., 20 ELF):\n\naelf-command send AElf.ContractNames.Election Vote '{\"candidatePubkey\":\"CANDIDATE_PUBLIC_KEY\",\"amount\":2000000000,\"endTimestamp\":{\"seconds\":1600271999,\"nanos\":999000}}' -a USER_ADDRESS\n\n\nCheck candidate votes:\n\naelf-command call AElf.ContractNames.Election GetCandidateVote '{\"value\":\"CANDIDATE_PUBLIC_KEY\"}'\n\nBecome a BP\n\nThe top 2N+1 candidate nodes are elected as BPs in the next term. Get the list of current BPs:\n\naelf-command call AElf.ContractNames.Consensus GetCurrentMinerPubkeyList '{}'\n\nAdd More BPs​\n\nRepeat the steps to add more BPs. No need to edit appsettings.json again. When candidate nodes exceed the max BPs, they replace genesis nodes, which cannot participate in elections again.\n\nProceed to contract deployment and DApp development guides for more details.\n\nPrevious\nRun a Mainnet Node\nNext\nCreation of a Side Chain\nSet up a Full Node\nAdd More BPs\nPlatform\nTechnology\nAudit Report\nPrivacy\nTerms of Use\nCookie Policy\nDeveloper Resources\nQuick Start\nLearn\nDocs\nTools\nResources\nEcosystem\nOverview\ndApps\naelf Ventures\nBlog\nConnect\nContact Us\nCopyright © 2024 aelf"
    },
    {
      "title": "Run a Mainnet Node | AELF Docs",
      "url": "https://docs.aelf.com/quick-start/node-operators/run-a-mainnet-node/",
      "html": "Skip to main content\nQuick Start\nLearn\nDocs\nTools\nResources\nBlog\nSearch\nQuick Start\nFor Developers\nFor Node Operators\nOperations\nRun a Mainnet Node\nSimulation in the Local Environment\nCreation of a Side Chain\nQuick StartFor Node OperatorsRun a Mainnet Node\nRun a Mainnet Node\nHow to Join the Mainnet​\n\nThere are two ways to run an aelf node: using Docker (recommended) or running binaries from GitHub. Before starting, you need to install some tools and frameworks. Command line instructions are provided for most dependencies. For complex needs, see the Environment setup section.\n\nSteps to Set Up a Node​\nExecute the snapshot download script and load the snapshot into the database.\nDownload our template setting files and Docker run script.\nModify the appsettings according to your needs.\nRun and check the node.\nConfiguration Requirements​\nMinimum Configuration:​\nc5.xlarge or N2 instance: 4 vCPU, 8GiB RAM, 1TB storage, 5 Mbps bandwidth\nRecommended Configuration:​\nc5.2xlarge or N2 instance: 8 vCPU, 16GiB RAM, 1TB storage, 100 Mbps bandwidth\n\nNote:\n\nFor non-block producing nodes, there is no requirement on the number of nodes.\nTo become a BP, run individual nodes for both MainChain aelf and all SideChains.\n\nTime Syncing: Ensure your server is time-synced via NTP to avoid syncing issues.\n\nSetup the Database​\n\nWe support Redis and SSDB for storing node data. For mainnet, we provide snapshots for SSDB only. Configure two SSDB instances: one for the chain database and one for the state database (run on different machines for better performance).\n\nImport the Snapshot Data​\n\nCreate a snapshot directory and navigate to it:\n\nmkdir snapshot\ncd snapshot\n\n\nFetch the snapshot download script:\n\ncurl -O -s https://aelf-backup.s3.ap-northeast-2.amazonaws.com/snapshot/mainnet/download-mainchain-db.sh\n\n\nExecute the script (specify a date if needed):\n\nsh download-mainchain-db.sh\n\n\nRestore the chain database from snapshot:\n\ntar xvzf aelf-mainnet-mainchain-chaindb-*.tar.gz\nstop your chain database instance (ssdb server)\ncp -r aelf-mainnet-mainchain-chaindb-*/* /path/to/install/chaindb/ssdb/var/\nstart your chain database instance\nenter ssdb console (ssdb-cli) use the \"info\" command to confirm that the data has been imported)\n\n\nRestore the state database from snapshot:\n\ntar xvzf aelf-mainnet-mainchain-statedb-*.tar.gz\nstop your state database instance (ssdb server)\ncp -r aelf-mainnet-mainchain-statedb-*/* /path/to/install/statedb/ssdb/var/\nstart your state database instance\nenter ssdb console (ssdb-cli) use the \"info\" command to confirm that the data has been imported)\n\nNode Configuration​\nGenerating the Node's Account​\n\nInstall the aelf-command npm package:\n\nnpm i -g aelf-command\n\n\nCreate an account/key-pair:\n\naelf-command create\n\n\nFollow the prompts to set a password and save the account info.\n\nPrepare Node Configuration​\n\nDownload the settings template and Docker script:\n\ncd /tmp/\nwget https://github.com/aelfProject/aelf/releases/download/v1.6.0/aelf-mainnet-mainchain.zip\nunzip aelf-mainnet-mainchain.zip\nmv aelf-mainnet-mainchain /opt/aelf-node\n\n\nUpdate the appsettings.json file with your account information:\n\n{\n    \"Account\": {\n        \"NodeAccount\": \"2Ue31YTuB5Szy7cnr3SCEGU2gtGi5uMQBYarYUR5oGin1sys6H\",\n        \"NodeAccountPassword\": \"********\"\n    },\n    \"ConnectionStrings\": {\n        \"BlockchainDb\": \"redis://your chain database server ip address:port\",\n        \"StateDb\": \"redis://your state database server ip address:port\"\n    },\n    \"Network\": {\n        \"BootNodes\": [\n            \"xxx.xxxx.xxx.xxx:6800\"\n        ],\n        \"ListeningPort\": 6800\n    },\n    \"CrossChain\": {\n        \"Grpc\": {\n            \"LocalServerPort\": 5000\n        }\n    }\n}\n\nRunning a Full Node with Docker​\n\nPull aelf’s Docker image and start the node:\n\ndocker pull aelf/node:mainnet-v1.6.0\ncd /opt/aelf-node\nsh aelf-node.sh start aelf/node:mainnet-v1.6.0\n\n\nTo stop the node:\n\nsh aelf-node.sh stop\n\nRunning a Full Node with the Binary Release​\n\nInstall the .NET Core SDK (version 6.0).\n\nGet the latest release and run the node:\n\ncd /tmp/\nwget https://github.com/aelfProject/aelf/releases/download/v1.6.0/aelf.zip\nunzip aelf.zip\nmv aelf /opt/aelf-node/\ncd /opt/aelf-node\ndotnet aelf/aelf.Launcher.dll\n\nRunning a Full Node with the Source​\nEnsure the code version is consistent (aelf v1.6.0).\nCompile on an Ubuntu Linux machine (recommended Ubuntu 18.04.2 LTS) with .NET Core SDK version 6.0.\nCheck the Node​\n\nRun the following command to check the node's block height:\n\naelf-command get-blk-height -e http://your node ip address:port\n\nRunning Side-Chains​\n\nDownload and Restore Snapshot Data (steps are the same as in Setup the Database).\n\nRun Side-Chain Node:\n\ncd /tmp/\nwget https://github.com/aelfProject/aelf/releases/download/v1.6.0/aelf-mainnet-sidechain1.zip\nunzip aelf-mainnet-sidechain1.zip\nmv aelf-mainnet-sidechain1 /opt/aelf-node\n\n\nUpdate appsettings.SideChain.MainNet.json with your node information:\n\n{\n    \"CrossChain\": {\n        \"Grpc\": {\n            \"ParentChainServerPort\": 5001,\n            \"ParentChainServerIp\": \"your mainchain ip address\",\n            \"ListeningPort\": 5011\n        },\n        \"ParentChainId\": \"aelf\",\n        \"Economic\": {\n            \"SymbolListToPayTxFee\": \"WRITE,READ,STORAGE,TRAFFIC\",\n            \"SymbolListToPayRental\": \"CPU,RAM,DISK,NET\"\n        }\n    },\n    \"Network\": {\n        \"BootNodes\": [\n            \"sidechain-bootnode-ip:6800\"\n        ],\n        \"ListeningPort\": 6800\n    }\n}\n\nNote​\n\nEnsure P2P ports are open and configured correctly for node communication.\n\n```sh\nbootnode → [\"xxx.xxxx.xxx.xxx:6800\", \"...\"]\n```\n\n```json\n{\n    \"Network\": {\n        \"BootNodes\": [\n            \"Add the right boot node according to sidechain\"\n        ],\n        \"ListeningPort\": 6800\n    }\n}\n```\n\nPrevious\nOperations\nNext\nSimulation in the Local Environment\nHow to Join the Mainnet\nSteps to Set Up a Node\nConfiguration Requirements\nMinimum Configuration:\nRecommended Configuration:\nSetup the Database\nImport the Snapshot Data\nNode Configuration\nGenerating the Node's Account\nPrepare Node Configuration\nRunning a Full Node with Docker\nRunning a Full Node with the Binary Release\nRunning a Full Node with the Source\nCheck the Node\nRunning Side-Chains\nNote\nPlatform\nTechnology\nAudit Report\nPrivacy\nTerms of Use\nCookie Policy\nDeveloper Resources\nQuick Start\nLearn\nDocs\nTools\nResources\nEcosystem\nOverview\ndApps\naelf Ventures\nBlog\nConnect\nContact Us\nCopyright © 2024 aelf"
    },
    {
      "title": "AELF Docs",
      "url": "https://docs.aelf.com/quick-start/node-operators/operations/",
      "html": "Skip to main content\nQuick Start\nLearn\nDocs\nTools\nResources\nBlog\nSearch\nQuick Start\nFor Developers\nFor Node Operators\nOperations\nRun a Mainnet Node\nSimulation in the Local Environment\nCreation of a Side Chain\nQuick StartFor Node OperatorsOperations\nOperations\nSteps to Become a BP​\nSet up nodes.\nParticipate in BP election using nodes.\n\nNote:\n\nVoters stake ELF tokens to vote for their preferred nodes.\n\nOutcome of Election:\n\nBlock Producer: Elected based on top \n2\n𝑁\n+\n1\n2N+1.\nCandidate Nodes: Elected based on top \n5\n∗\n(\n2\n𝑁\n+\n1\n)\n5∗(2N+1).\nNodes​\nSet up Nodes​\n\naelf doesn't have light nodes, so all nodes are full nodes. Click here to learn how to set up a full node.\n\nNote: To become a BP, you need to run individual nodes for both MainChain aelf and all the SideChains.\n\nParticipate in BP Election​\n\nStake 100,000 ELF to join the node election. Ensure you have enough balance.\n\nGo to the Governance page.\nClick \"Become a candidate node.\"\nStake 100,000 ELF.\nUsers Vote for Nodes​\n\nUsers can vote for candidate nodes at Governance -> Vote -> Node Table.\n\nThe top \n2\n𝑁\n+\n1\n2N+1 nodes become BPs.\nThe top \n5\n∗\n(\n2\n𝑁\n+\n1\n)\n5∗(2N+1) nodes become candidate nodes.\nN starts from \n8\n8 in 2022 and increases by \n1\n1 each year.\nBPs are Elected​\n\nBPs are elected every seven days, starting at 7:23 (UTC) every Thursday. If your node ranks in the top \n2\n𝑁\n+\n1\n2N+1, it becomes a BP in the next term. If it ranks between top \n2\n𝑁\n+\n1\n2N+1 and top \n5\n∗\n(\n2\n𝑁\n+\n1\n)\n5∗(2N+1), it becomes a candidate node. Check the current elected BPs in real-time on the election page.\n\nSimulate in Local Environment​\n\nTo try setting up a node and running as a BP locally, follow the instructions here to simulate it in the local environment.\n\nPrevious\nFor Node Operators\nNext\nRun a Mainnet Node\nSteps to Become a BP\nNodes\nSet up Nodes\nParticipate in BP Election\nUsers Vote for Nodes\nBPs are Elected\nSimulate in Local Environment\nPlatform\nTechnology\nAudit Report\nPrivacy\nTerms of Use\nCookie Policy\nDeveloper Resources\nQuick Start\nLearn\nDocs\nTools\nResources\nEcosystem\nOverview\ndApps\naelf Ventures\nBlog\nConnect\nContact Us\nCopyright © 2024 aelf"
    },
    {
      "title": "AELF Docs",
      "url": "https://docs.aelf.com/quick-start/developers/vote-contract/",
      "html": "Skip to main content\nQuick Start\nLearn\nDocs\nTools\nResources\nBlog\nSearch\nQuick Start\nFor Developers\nHello World Contract\nLottery Game Contract\nVote Contract\nFor Node Operators\nQuick StartFor DevelopersVote Contract\nVote Contract\n\nDescription: This is the most complex contract in this guide. It covers voting mechanisms, security considerations, and advanced data structures to ensure a fair and transparent voting process.\n\nPurpose: To teach you about complex logic implementation, security best practices, and efficient data management in smart contracts.\n\nDifficulty Level: Difficult\n\nStep 1 - Setting up your development environment​\nLocal\nCodespaces\nBasic knowledge of terminal commands\nIDE - Install VS Code\n\nInstall Required Packages\n\nInstall dotnet 6.0 SDK\nInstall aelf contract templates\ndotnet new --install AElf.ContractTemplates\n\n\nAELF.ContractTemplates contains various predefined templates for the ease of developing smart contracts on the aelf blockchain.\n\nInstall aelf deploy tool\ndotnet tool install --global aelf.deploy\n\n\naelf.deploy is a utility tool for deploying smart contracts on the aelf blockchain. Please remember to export PATH after installing aelf.deploy.\n\nInstall Node.js and Yarn\n\nInstall Node.js\nInstall aelf-command\nsudo npm i -g aelf-command\n\n\naelf-command is a CLI tool for interacting with the aelf blockchain, enabling tasks like creating wallets and managing transactions. Provide required permissions while installing aelf-command globally.\n\nInstall Git\n\nInstall Git\n\nAs we will be using a ready made project, we will require git to clone from the project.\n\nStep 2 - Develop Smart Contract​\nProject Setup​\nOpen your Terminal.\nEnter the following command to create a new project folder:\nmkdir capstone_aelf\ncd capstone_aelf\n\nEnter this command to create the capstone project.\ndotnet new aelf -n BuildersDAO\n\nAdding Your Smart Contract Code​\n\nOpen your project in your favorite IDE (like VSCode).\n\nRename the src/Protobuf/contract/hello_world_contract.proto file to BuildersDAO.proto.\n\nAfter renaming the file, your working directory should look like this.\n\nThat's it! Your project is now set up and ready to go 🚀\n\nDefining Methods and Messages​\n\nLet's add the RPC methods and message definitions to our Voting dApp.\n\nOpen src/Protobuf/contract/BuildersDAO.proto\nReplace its contents with this code snippet.\nsyntax = \"proto3\";\n\nimport \"aelf/core.proto\";\nimport \"aelf/options.proto\";\nimport \"google/protobuf/empty.proto\";\nimport \"Protobuf/reference/acs12.proto\";\n\n// The namespace of this class\noption csharp_namespace = \"AElf.Contracts.BuildersDAO\";\n\nservice BuildersDAO {\n  // The name of the state class the smart contract is going to use to access\n  // blockchain state\n  option (aelf.csharp_state) = \"AElf.Contracts.BuildersDAO.BuildersDAOState\";\n  option (aelf.base) = \"Protobuf/reference/acs12.proto\";\n\n  // Actions -> Methods that change state of smart contract\n  // This method sets up the initial state of our StackUpDAO smart contract\n  rpc Initialize(google.protobuf.Empty) returns (google.protobuf.Empty);\n  \n  // This method allows a user to become a member of the DAO by taking in their\n  // address as an input parameter\n  rpc JoinDAO(aelf.Address) returns (google.protobuf.Empty);\n  \n  // This method allows a user to create a proposal for other users to vote on.\n  // The method takes in a \"CreateProposalInput\" message which comprises of an\n  // address, a title, description and a vote threshold (i.e how many votes\n  // required for the proposal to pass)\n  rpc CreateProposal(CreateProposalInput) returns (Proposal);\n  \n  // This method allows a user to vote on proposals towards a specific proposal.\n  // This method takes in a \"VoteInput\" message which takes in the address of\n  // the voter, specific proposal and a boolean which represents their vote\n  rpc VoteOnProposal(VoteInput) returns (Proposal);\n\n  // Views -> Methods that does not change state of smart contract\n  // This method allows a user to fetch a list of proposals that had been\n  // created by members of the DAO\n  rpc GetAllProposals(google.protobuf.Empty) returns (ProposalList) {\n    option (aelf.is_view) = true;\n  }\n  \n  // aelf requires explicit getter methods to access the state value, \n  // so we provide these three getter methods for accessing the state\n  // This method allows a user to fetch a proposal by proposalId\n  rpc GetProposal (google.protobuf.StringValue) returns (Proposal) {\n    option (aelf.is_view) = true;\n  }\n\n  // This method allows a user to fetch the member count that joined DAO\n  rpc GetMemberCount (google.protobuf.Empty) returns (google.protobuf.Int32Value) {\n    option (aelf.is_view) = true;\n  }\n\n  // This method allows a user to check whether this member is exist by address\n  rpc GetMemberExist (aelf.Address) returns (google.protobuf.BoolValue) {\n    option (aelf.is_view) = true;\n  }\n}\n\n// Message definitions\nmessage Member {\n  aelf.Address address = 1;\n}\n\nmessage Proposal {\n  string id = 1;\n  string title = 2;\n  string description = 3;\n  repeated aelf.Address yesVotes = 4;\n  repeated aelf.Address noVotes = 5;\n  string status = 6;  // e.g., \"IN PROGRESS\", \"PASSED\", \"DENIED\"\n  int32 voteThreshold = 7;\n}\n\nmessage CreateProposalInput {\n  aelf.Address creator = 1;\n  string title = 2;\n  string description = 3;\n  int32 voteThreshold = 4;\n}\n\nmessage VoteInput {\n  aelf.Address voter = 1;\n  string proposalId = 2;\n  bool vote = 3;  // true for yes, false for no\n}\n\nmessage MemberList {\n  repeated Member members = 1;\n}\n\nmessage ProposalList {\n  repeated Proposal proposals = 1;\n}\n\nUnderstanding the Code​\n1. Define Syntax & Imports​\nproto3 version.\nImport necessary Protobuf definitions and libraries.\n2. RPC Methods​\nInitialize : Set up initial state\nJoinDAO : User joins DAO. User's address is the function parameter.\nCreateProposal : User creates a proposal. User's address , title , description , vote threshold are the function parameter.\nVoteOnProposal : User votes on a proposal. User's address , proposal vote is the function parameter.\nGetAllProposals : Fetch list of proposals\n3. Getter Methods​\nGetProposal : Fetch proposal by ID\nGetMemberCount : Fetch member count\nGetMemberExist : Check if a member exists by address\n4. Message Definitions​\nMember : DAO member (address)\nProposal : Proposal (title, description, votes, status, vote threshold)\nCreateProposalInput : Fields for creating a proposal (title, description, vote threshold)\nVoteInput : Fields for voting on a proposal (proposal ID, vote)\nMemberList : List of DAO members\nProposalList : List of proposals\nDefining Contract State​\nOpen the src/BuildersDAOState.cs file.\nReplace its contents with this code snippet.\nusing System.Collections.Generic;\nusing System.Diagnostics.CodeAnalysis;\nusing AElf.Sdk.CSharp.State;\nusing AElf.Types;\n\nnamespace AElf.Contracts.BuildersDAO\n{\n    // The state class is access the blockchain state\n    public class BuildersDAOState : ContractState\n    {\n        public BoolState Initialized { get; set; }\n        public MappedState<Address, bool> Members { get; set; }\n        public MappedState<string, Proposal> Proposals { get; set; }\n        public Int32State MemberCount { get; set; }\n        public Int32State NextProposalId { get; set; }\n    }\n}\n\nUnderstanding the Code​\n3. State Variables​\nMembers : Mapping each member to a boolean indicates if they joined the DAO\nProposals : Mapping each proposal to an ID for identification and retrieval\nMemberCountId and NextProposalId : Track total number of members and proposals\nNext Step​\nImplement the logic of our voting smart contract.\nImplement Voting Smart Contract Logic​\nChecking Smart Contract Logics​\nOpen src/BuildersDAO.cs\nReplace the existing content with this code snippet.\nusing System.Collections.Generic;\nusing System.Security.Principal;\nusing AElf.Sdk.CSharp;\nusing AElf.Sdk.CSharp.State;\nusing AElf.Types;\nusing Google.Protobuf.WellKnownTypes;\n\nnamespace AElf.Contracts.BuildersDAO\n{\n    public class BuildersDAO : BuildersDAOContainer.BuildersDAOBase\n    {\n        const string author = \"REPLACE PLACEHOLDER HERE\";\n\n        // Implement Initialize Smart Contract Logic\n        public override Empty Initialize(Empty input) { }\n\n        // Implement Join DAO Logic\n        public override Empty JoinDAO(Address input) { }\n\n        // Implement Create Proposal Logic\n        public override Proposal CreateProposal(CreateProposalInput input) { }\n\n        // Implement Vote on Proposal Logic\n        public override Proposal VoteOnProposal(VoteInput input) { }\n\n        // Implement Get All Proposals Logic\n        public override ProposalList GetAllProposals(Empty input) { }\n        \n        // Implement Get Proposal Logic\n        public override Proposal GetProposal(StringValue input) { }\n        \n        // Implement Get Member Count Logic\n        public override Int32Value GetMemberCount(Empty input) { }\n        \n        // Implement Get Member Exist Logic\n        public override BoolValue GetMemberExist(Address input) { }\n    }\n}\n\nImplementing Initialize Function​\nGo to the comment Implement Initialize Smart Contract Logic.\nCheck if the smart contract is already initialized; return if true.\nDefine a hardcoded proposal with necessary parameters.\nUpdate the Proposals state variable with the hardcoded proposal and increment the proposalId.\n// Implement Initialize Smart Contract Logic\npublic override Empty Initialize(Empty input)\n{\n    Assert(!State.Initialized.Value, \"already initialized\");\n    var initialProposal = new Proposal\n    {\n        Id = \"0\",\n        Title = \"Proposal #1\",\n        Description = \"This is the first proposal of the DAO\",\n        Status = \"IN PROGRESS\",\n        VoteThreshold = 1,\n    };\n    State.Proposals[initialProposal.Id] = initialProposal;\n    State.NextProposalId.Value = 1;\n    State.MemberCount.Value = 0;\n    \n    State.Initialized.Value = true;\n    \n    return new Empty();\n}\n\nImplementing Join DAO Function​\nGo to the comment Implement Join DAO Logic\nCheck if the member already exists in the DAO using the Members state variable.\nIf not found, update Members to include the user's address.\nIncrement membersCount to reflect the new member added.\n\nYou'll implement this function. Once done, you can proceed to the next page to compare your code with the reference implementation.\n\n// Implement Join DAO Logic\npublic override Empty JoinDAO(Address input)\n{\n    // Based on the address, determine whether the address has joined the DAO. If it has, throw an exception\n    // If the address has not joined the DAO, then join and update the state's value to true\n    // Read the value of MemberCount in the state, increment it by 1, and update it in the state\n    // Using 'return null' to ensure the contract compiles successfully. Please update it to the correct return value when implementing\n    return null;\n}\n\nImplementing Create Proposal Function​\nGo to the comment Implement Create Proposal Logic\nCheck if the user is a DAO member (required to create proposals).\nCreate a new proposal object using fields from CreateProposalInput.\nUpdate Proposals with the new proposal, increment NextProposalId, and return the created proposal object.\n\nNow, use the provided code snippet to fill in the CreateProposal function.\n\n// Implement Create Proposal Logic\npublic override Proposal CreateProposal(CreateProposalInput input)\n{\n    Assert(State.Members[input.Creator], \"Only DAO members can create proposals\");\n    var proposalId = State.NextProposalId.Value.ToString();\n    var newProposal = new Proposal\n    {\n        Id = proposalId,\n        Title = input.Title,\n        Description = input.Description,\n        Status = \"IN PROGRESS\",\n        VoteThreshold = input.VoteThreshold,\n        YesVotes = { }, // Initialize as empty\n        NoVotes = { }, // Initialize as empty\n    };\n    State.Proposals[proposalId] = newProposal;\n    State.NextProposalId.Value += 1;\n    return newProposal; // Ensure return\n}\n\nImplementing Vote On Proposal Function​\n\nGo to the comment Implement Vote on Logic\n\nPerform these checks:\n\nVerify if the member is a DAO member (required to vote).\nConfirm if the proposal exists; otherwise, display an error message.\nCheck if the member has already voted on the proposal; members can vote only once.\n\nIf all checks pass, store the member’s vote and update the proposal state.\n\nUpdate the proposal status based on vote thresholds:\n\nIf yesVotes reach the threshold, update status to \"PASSED\".\nIf noVotes reach the threshold, update status to \"DENIED\".\n\nNow, use the provided code snippet to complete the VoteOnProposal function.\n\n// Implement Vote on Proposal Logic\npublic override Proposal VoteOnProposal(VoteInput input)\n{\n    Assert(State.Members[input.Voter], \"Only DAO members can vote\");\n    var proposal = State.Proposals[input.ProposalId]; // ?? new proposal\n    Assert(proposal != null, \"Proposal not found\");\n    Assert(\n        !proposal.YesVotes.Contains(input.Voter) && !proposal.NoVotes.Contains(input.Voter),\n        \"Member already voted\"\n    );\n\n    // Add the vote to the appropriate list\n    if (input.Vote)\n    {\n        proposal.YesVotes.Add(input.Voter);\n    }\n    else\n    {\n        proposal.NoVotes.Add(input.Voter);\n    }\n\n    // Update the proposal in state\n    State.Proposals[input.ProposalId] = proposal;\n\n    // Check if the proposal has reached its vote threshold\n    if (proposal.YesVotes.Count >= proposal.VoteThreshold)\n    {\n        proposal.Status = \"PASSED\";\n    }\n    else if (proposal.NoVotes.Count >= proposal.VoteThreshold)\n    {\n        proposal.Status = \"DENIED\";\n    }\n\n    return proposal;\n}\n\nImplementing Get All Proposals Function​\n\nGo to the comment Implement Get All Proposals Logic\n\nCreate a new ProposalList object from the message definition in BuildersDAO.proto.\n\nFetch and iterate through Proposals.\n\nUpdate ProposalList with proposal objects and return the list of proposals.\n\nIf yesVotes reach the threshold, update status to \"PASSED\".\nIf noVotes reach the threshold, update status to \"DENIED\".\n\nYou'll implement this function. Once done, you can proceed to the next page to compare your code with the reference implementation.\n\n// Implement Get All Proposals Logic\npublic override ProposalList GetAllProposals(Empty input)\n{\n    // Create a new list called ProposalList\n    // Start iterating through Proposals from index 0 until the value of NextProposalId, read the corresponding proposal, add it to ProposalList, and finally return ProposalList\n    // Using 'return null' to ensure the contract compiles successfully. Please update it to the correct return value when implementing\n    return null;\n}\n\nImplementing Get Proposal / Get Member Count / Get Member Exist Functions​\n1. Get Proposal​\nNavigate to Implement Get Proposal Logic.\nRetrieve a proposal by proposalId.\nUse proposalId as the key to query State.Proposals.\nReturn the corresponding proposal value.\n2. Get Member Count​\nNavigate to Implement Get Member Count Logic.\nRetrieve the total member count.\nReturn the value of MemberCount from State.\n3. Get Member Exist​\nNavigate to Implement Get Member Exist Logic.\nCheck if a member exists by address.\nUse address as the key to query State.Members.\nReturn the corresponding existence value.\n\nImplement these methods to access different states effectively in your smart contract.\n\n// Implement Get Proposal Logic\npublic override Proposal GetProposal(StringValue input)\n{\n    var proposal = State.Proposals[input.Value];\n    return proposal;\n}\n\n// Implement Get Member Count Logic\npublic override Int32Value GetMemberCount(Empty input)\n{\n    var memberCount = new Int32Value {Value = State.MemberCount.Value};\n    return memberCount;\n}\n\n// Implement Get Member Exist Logic\npublic override BoolValue GetMemberExist(Address input)\n{\n    var exist = new BoolValue {Value = State.Members[input]};\n    return exist;\n}\n\n\nWith that, we have implemented all the functionalities of our Voting dApp smart contract.\n\nIn the next step, we will compile our smart contract and deploy our written smart contract to the aelf sidechain.\n\nComplete Implementation​\nImplementing Join DAO Function​\nCheck Membership : See if the address has already joined the DAO by checking State.Members. Use the Assert method for this verification.\nAdd New Member : If the address isn't a member yet, add it to State.Members and set its value to true.\nUpdate Member Count : Increase State.MemberCount by 1 and save the new value.\npublic override Empty JoinDAO(Address input)\n{\n    // Based on the address, determine whether the address has joined the DAO. If it has, throw an exception\n    Assert(!State.Members[input], \"Member is already in the DAO\");\n    // If the address has not joined the DAO, then join and update the state's value to true\n    State.Members[input] = true;\n    // Read the value of MemberCount in the state, increment it by 1, and update it in the state\n    var currentCount = State.MemberCount.Value;\n    State.MemberCount.Value = currentCount + 1;\n    return new Empty();\n}\n\nImplementing Get All Proposals Function​\nCreate a list object called ProposalList.\nLoop from 0 to the value of State.NextProposalId.\nIn each loop iteration, get the values from State.Proposals and add them to ProposalList.\nReturn ProposalList.\npublic override ProposalList GetAllProposals(Empty input)\n{\n    // Create a new list called ProposalList\n    var proposals = new ProposalList();\n    // Start iterating through Proposals from index 0 until the value of NextProposalId, read the corresponding proposal, add it to ProposalList, and finally return ProposalList\n    for (var i = 0; i < State.NextProposalId.Value; i++)\n    {\n        var proposalCount = i.ToString();\n        var proposal = State.Proposals[proposalCount];\n        proposals.Proposals.Add(proposal);\n    }\n    return proposals;\n}\n\n\nOnce you've implemented these two methods and run the unit tests again, you should see that all test cases pass.\n\nStep 3 - Deploy Smart Contract​\nCreate A Wallet​\n\nTo send transactions on the aelf blockchain, you must have a wallet.\n\nRun this command to create aelf wallet.\n\naelf-command create\n\n\nYou will be prompted to save your account, please do save your account as shown below:\n\n? Save account info into a file? (Y/n) Y\n\n\nNext, enter and confirm your password. Then export your wallet password as shown below:\n\nexport WALLET_PASSWORD=\"YOUR_WALLET_PASSWORD\"\n\nAcquire Testnet Tokens (Faucet) for Development​\n\nTo deploy smart contracts or execute on-chain transactions on aelf, you'll require testnet ELF tokens.\n\nGet ELF Tokens\n\nCLI\nWeb\n\nRun the following command to get testnet ELF tokens from faucet. Remember to either export your wallet address and wallet password or replace \n𝑊\n𝐴\n𝐿\n𝐿\n𝐸\n𝑇\n𝐴\n𝐷\n𝐷\n𝑅\n𝐸\n𝑆\n𝑆\n𝑎\n𝑛\n𝑑\nWALLET\nA\n\t​\n\nDDRESSandWALLET_ADDRESS with your wallet address and wallet password respectively.\n\nexport WALLET_ADDRESS=\"YOUR_WALLET_ADDRESS\"\ncurl -X POST \"https://faucet.aelf.dev/api/claim?walletAddress=$WALLET_ADDRESS\" -H \"accept: application/json\" -d \"\"\n\n\nTo check your wallet's current ELF balance:\n\naelf-command call ASh2Wt7nSEmYqnGxPPzp4pnVDU4uhj1XW9Se5VeZcX2UDdyjx -a $WALLET_ADDRESS -p $WALLET_PASSWORD -e https://tdvw-test-node.aelf.io GetBalance\n\n\nYou will be prompted for the following:\n\nEnter the required param <symbol>: ELF\nEnter the required param <owner>: **$WALLET_ADDRESS**\n\n\nYou should see the result displaying your wallet's ELF balance.\n\nThe smart contract needs to be deployed on the chain before users can interact with it.\n\nRun the following command to deploy a contract. Remember to export the path of LotteryGame.dll.patched to CONTRACT_PATH.\n\nexport CONTRACT_PATH=$(find ~+ . -path \"*patched*\" | head -n 1)\n\naelf-deploy -a $WALLET_ADDRESS -p $WALLET_PASSWORD -c $CONTRACT_PATH -e https://tdvw-test-node.aelf.io/\n\n\nPlease wait for approximately 1 to 2 minutes. If the deployment is successful, it will provide you with the contract address.\n\nExport your smart contract address:\n\nexport CONTRACT_ADDRESS=\"YOUR_SMART_CONTRACT_ADDRESS e.g. 2LUmicHyH4RXrMjG4beDwuDsiWJESyLkgkwPdGTR8kahRzq5XS\"\n\nStep 4 - Interact with Your Deployed Smart Contract​\nProject Setup​\n\nLet's start by cloning the frontend project repository from GitHub.\n\nRun the following command in the capstone_aelf directory:\nTerminal\ngit clone https://github.com/AElfProject/vote-contract-frontend.git\n\nNext, navigate to the frontend project directory with this command:\nTerminal\ncd vote-contract-frontend\n\n\nOnce you're in the vote-contract-frontend directory, open the project with your preferred IDE (e.g., VSCode). You should see the project structure as shown below.\n\nInstall necessary libraries​\nRun this command in the terminal:\nTerminal\nnpm install\n\n\nWe are now ready to build the frontend components of our Voting dApp.\n\nConfigure Portkey Provider & Write Connect Wallet Function​\n\nWe'll set up our Portkey provider to let users connect their Portkey wallets to our app and interact with our voting smart contract.\n\nGo to the src/useDAOSmartContract.ts file.\n\nIn this file, we'll create a component that initializes the Portkey wallet provider and fetches our deployed voting smart contract. This will enable our frontend components to interact with the smart contract for actions like joining the DAO, creating proposals, and more.\n\nLocate the comment Step A - Setup Portkey Wallet Provider and replace the existing useEffect hook with the following code snippet:\n\nsrc/useDAOSmartContract.ts\n//Step A - Setup Portkey Wallet Provider\nuseEffect(() => {\n  (async () => {\n    if (!provider) return null;\n\n    try {\n      // 1. get the sidechain tDVW using provider.getChain\n      const chain = await provider?.getChain(\"tDVW\");\n      if (!chain) throw new Error(\"No chain\");\n\n      //Address of DAO Smart Contract\n      //Replace with Address of Deployed Smart Contract\n      const address = \"2GkJoDicXLqo7cR9YhjCEnCXQt8KUFUTPfCkeJEaAxGFYQo2tb\";\n\n      // 2. get the DAO contract\n      const daoContract = chain?.getContract(address);\n      setSmartContract(daoContract);\n    } catch (error) {\n      console.log(error, \"====error\");\n    }\n  })();\n}, [provider]);\n\nNext, go to the src/HomeDAO.tsx file.\n\nThe HomeDAO.tsx file is the landing page of our Voting dApp. It allows users to interact with the deployed smart contract, join the DAO, view proposals, and vote on them.\n\nBefore users can interact with the smart contract, we need to write the Connect Wallet function.\n\nFind the comment Step B - Connect Portkey Wallet. Replace the existing connect function with this code snippet:\n\nsrc/HomeDAO.ts\nconst connect = async () => {\n  //Step B - Connect Portkey Wallet\n  const accounts = await provider?.request({\n    method: MethodsBase.REQUEST_ACCOUNTS,\n  });\n  const account = accounts?.tDVW?.[0];\n  setCurrentWalletAddress(account);\n  setIsConnected(true);\n  alert(\"Successfully connected\");\n};\n\n\nIn this code, we fetch the Portkey wallet account using the provider and update the wallet address state variable. An alert notifies the user that their wallet is successfully connected.\n\nWith the Connect Wallet function defined, we're ready to write the remaining functions in the next steps.\n\nWrite Initialize Smart Contract & Join DAO Functions​\n\nLet's write the Initialize and Join DAO functions.\n\nFind the comment Step C - Write Initialize Smart Contract and Join DAO Logic.\n\nReplace the existing initializeAndJoinDAO function with this code snippet:\n\nsrc/HomeDAO.ts\nconst initializeAndJoinDAO = async () => {\n  //Step C - Write Initialize Smart Contract and Join DAO Logic\n  try {\n    const accounts = await provider?.request({\n      method: MethodsBase.ACCOUNTS,\n    });\n    if (!accounts) throw new Error(\"No accounts\");\n\n    const account = accounts?.tDVW?.[0];\n    if (!account) throw new Error(\"No account\");\n\n    if (!initialized) {\n      await DAOContract?.callSendMethod(\"Initialize\", account, {});\n      setInitialized(true);\n      alert(\"DAO Contract Successfully Initialized\");\n    }\n\n    await DAOContract?.callSendMethod(\"JoinDAO\", account, account);\n    setJoinedDAO(true);\n    alert(\"Successfully Joined DAO\");\n  } catch (error) {\n    console.error(error, \"====error\");\n  }\n};\n\nHere's what the function does:​\n\nFetches your wallet account using the Portkey wallet provider.\n\nInitializes the DAO smart contract if it hasn't been done already, updating the state and showing a success alert.\n\nCalls the JoinDAO method with your wallet address, updating the state and showing a success alert.\n\nNow, wrap the initializeAndJoinDAO function in the \"Join DAO\" button to trigger both Initialize and JoinDAO when clicked.\n\nNext, we'll write the Create Proposal function.\n\nWrite Create Proposal Function​\n\nLet's write the Create Proposal function.\n\nGo to the src/CreateProposal.tsx file. This file is the \"Create Proposal\" page where users can enter details like the proposal title, description, and vote threshold.\n\nFind the comment Step D - Configure Proposal Form.\n\nReplace the form variable with this code snippet:\n\nsrc/CreateProposal.tsx\n//Step D - Configure Proposal Form\nconst form = useForm<z.infer<typeof formSchema>>({\n  resolver: zodResolver(formSchema),\n  defaultValues: {\n    address: currentWalletAddress,\n    title: \"\",\n    description: \"\",\n    voteThreshold: 0,\n  },\n});\n\nHere's what the function does:​\n\nInitializes a new form variable with default values needed to create a proposal.\n\nFields include: address , title , description , and vote threshold.\n\nNow your form is ready for users to fill in the necessary details for their proposal.\n\nNow, let's write the Create Proposal function for the form submission.\n\nScroll down to find the comment Step E - Write Create Proposal Logic.\n\nReplace the onSubmit function with this code snippet:\n\nsrc/CreateProposal.tsx\n// Step E - Write Create Proposal Logic\nfunction onSubmit(values: z.infer<typeof formSchema>) {\n  const proposalInput: IProposalInput = {\n    creator: currentWalletAddress,\n    title: values.title,\n    description: values.description,\n    voteThreshold: values.voteThreshold,\n  };\n\n  setCreateProposalInput(proposalInput);\n\n  const createNewProposal = async () => {\n    try {\n      await DAOContract?.callSendMethod(\n        \"CreateProposal\",\n        currentWalletAddress,\n        createProposalInput\n      );\n\n      navigate(\"/\");\n      alert(\"Successfully created proposal\");\n    } catch (error) {\n      console.error(error);\n    }\n  };\n\n  createNewProposal();\n}\n\nHere's what the function does:​\n\nCreates a new proposalInput variable with form fields: title , description , and vote threshold.\n\nInvokes the CreateProposal function of the deployed smart contract, using the current wallet address and proposalInput.\n\nIf successful, navigates the user to the landing page and shows an alert that the proposal was created.\n\nNext, we'll write the Vote and Fetch Proposal functions to complete the frontend components of our Voting dApp.\n\nWrite Vote & Fetch Proposals Function​\n\nIn this step, we'll write the Vote and Fetch Proposals functions to complete our Voting dApp's frontend components.\n\nGo to the src/HomeDAO.tsx file and scroll to the Step F - Write Vote Yes Logic comment.\n\nReplace the voteYes function with this code snippet:\n\nsrc/HomeDAO.tsx\nconst voteYes = async (index: number) => {\n  //Step F - Write Vote Yes Logic\n  try {\n    const accounts = await provider?.request({\n      method: MethodsBase.ACCOUNTS,\n    });\n\n    if (!accounts) throw new Error(\"No accounts\");\n\n    const account = accounts?.tDVW?.[0];\n\n    if (!account) throw new Error(\"No account\");\n\n    const createVoteInput: IVoteInput = {\n      voter: account,\n      proposalId: index,\n      vote: true,\n    };\n\n    await DAOContract?.callSendMethod(\n      \"VoteOnProposal\",\n      account,\n      createVoteInput\n    );\n    alert(\"Voted on Proposal\");\n    setHasVoted(true);\n  } catch (error) {\n    console.error(error, \"=====error\");\n  }\n};\n\nHere's what the function does:​\n\nTakes an index parameter, representing the proposal ID to vote on.\n\nFetches the wallet address using the Portkey provider.\n\nCreates a createVoteInput parameter with the voter's wallet address, proposal ID, and a true value for a Yes vote..\n\nCalls the VoteOnProposal function from the smart contract.\n\nUpdates the state and shows an alert upon a successful vote.\n\nThe voteNo function works similarly but sets the vote to false.\n\nScroll down to the Step G - Use Effect to Fetch Proposals comment and replace the useEffect hook with this code snippet:\nsrc/HomeDAO.tsx\nuseEffect(() => {\n  // Step G - Use Effect to Fetch Proposals\n  const fetchProposals = async () => {\n    try {\n      const accounts = await provider?.request({\n        method: MethodsBase.ACCOUNTS,\n      });\n\n      if (!accounts) throw new Error(\"No accounts\");\n\n      const account = accounts?.tDVW?.[0];\n\n      if (!account) throw new Error(\"No account\");\n\n      const proposalResponse = await DAOContract?.callViewMethod<IProposals>(\n        \"GetAllProposals\",\n        \"\"\n      );\n\n      setProposals(proposalResponse?.data);\n      alert(\"Fetched Proposals\");\n    } catch (error) {\n      console.error(error);\n    }\n  };\n\n  fetchProposals();\n}, [DAOContract, hasVoted, isConnected, joinedDAO]);\n\nHere's what the function does:​\n\nDefines the fetchProposals function that fetches the wallet address.\n\nCalls the GetAllProposals function from the smart contract, returning a list of proposals.\n\nUpdates the state and shows an alert once the proposals are fetched.\n\nNow that we've written all the necessary frontend functions and components, we're ready to run the Voting dApp application in the next step.\n\nRun Application​\n\nIn this step, we will run the Voting dApp application.\n\nTo begin, run the following command on your terminal.\nTerminal\nnpm run dev\n\n\nYou should observe the following as shown below.\n\nUpon clicking on the localhost URL, you should be directed to the StackUpDAO landing page as shown below.\n\nUsually codespace will automatically forward port, you should see a pop-up message at the bottom right of your codespace browser window as shown in the diagram below:\n\nClick the link to open the Voting dApp in the browser.\n\nCreate Portkey Wallet​\n\nDownload the Chrome extension for Portkey from https://chromewebstore.google.com/detail/portkey-wallet/iglbgmakmggfkoidiagnhknlndljlolb.\n\nOnce you have downloaded the extension, you should see the following on your browser as shown below.\n\nClick on Get Start and you should see the following interface as shown below.\n\nSign up\n\nSwitch to aelf Testnet network by selecting it:\n\nProceed to sign up with a Google Account or your preferred login method and complete the necessary accounts creation prompts and you should observe the following interface once you have signed up.\n\nWith that, you have successfully created your very first Portkey wallet within seconds. How easy was that?\n\nNext, click on ‘Open Portkey’ and you should now observe the following as shown below.\n\nConnect Portkey Wallet\n\nClick on \"Connect Wallet\" to connect your Portkey wallet. The button will change to \"Connected\" when the connection is successful.\n\nNext, click on \"Join DAO\". You will be prompted to sign the \"Initialize\" and \"Join DAO\" methods, as shown below.\n\nOnce you have successfully joined the DAO, you should observe now that the landing page renders the proposal we have defined in our smart contract as shown below.\n\nProposal #1 as defined in smart contract\n\nLet’s test our Vote functionality next.\n\nProceed to click on \"Vote Yes\" and you should observe the following as shown below prompting you to sign the \"Vote Yes\" transaction.\n\nProceed to click on \"Sign\".\n\nUpon a successful vote transaction, you should now observe that the proposal status has been updated to \"PASSED\" as shown below as the Yes vote count has reached the vote threshold.\n\nProposal status updated to \"PASSED\" Lastly, we will be creating a proposal to wrap up our demonstration of our Voting dApp.\n\nClick on \"Create Proposal\" for Proceed and you should be directed to the Create Proposal page as shown below.\n\nProceed to fill in the following fields under the Create Proposal form:\n\nTitle - Proposal #2\n\nDescription - Proposal to onboard Developer DAO\n\nVote Threshold - 10\n\nclick on \"Submit\" and you should observe the following as shown below.\n\nClick on \"Sign\" to Proceed.\n\nUpon a successful proposal creation, you should be directed back to the landing page with the newly created proposal rendered on the landing page as shown below.\n\n🎉 Congratulations Learners! You have successfully built your Voting dApp and this is no mean feat.\n\nPrevious\nLottery Game Contract\nNext\nFor Node Operators\nStep 1 - Setting up your development environment\nStep 2 - Develop Smart Contract\nProject Setup\nAdding Your Smart Contract Code\nDefining Methods and Messages\nDefining Contract State\nImplement Voting Smart Contract Logic\nComplete Implementation\nStep 3 - Deploy Smart Contract\nStep 4 - Interact with Your Deployed Smart Contract\nProject Setup\nConfigure Portkey Provider & Write Connect Wallet Function\nWrite Initialize Smart Contract & Join DAO Functions\nWrite Create Proposal Function\nWrite Vote & Fetch Proposals Function\nRun Application\nPlatform\nTechnology\nAudit Report\nPrivacy\nTerms of Use\nCookie Policy\nDeveloper Resources\nQuick Start\nLearn\nDocs\nTools\nResources\nEcosystem\nOverview\ndApps\naelf Ventures\nBlog\nConnect\nContact Us\nCopyright © 2024 aelf"
    },
    {
      "title": "AELF Docs",
      "url": "https://docs.aelf.com/quick-start/developers/lottery-game-smart-contract/",
      "html": "Skip to main content\nQuick Start\nLearn\nDocs\nTools\nResources\nBlog\nSearch\nQuick Start\nFor Developers\nHello World Contract\nLottery Game Contract\nVote Contract\nFor Node Operators\nQuick StartFor DevelopersLottery Game Contract\nLottery Game Contract\n\nDescription: This contract is moderately complex. It demonstrates the use of state variables, user interactions, and random number generation to create a basic lottery game.\n\nPurpose: To introduce you to more advanced concepts such as state management, event handling, and randomization in smart contracts.\n\nDifficulty Level: Moderate\n\nStep 1 - Setting up your development environment​\nLocal\nCodespaces\nBasic knowledge of terminal commands\nIDE - Install VS Code\n\nInstall Required Packages\n\nInstall dotnet 6.0 SDK\nInstall aelf contract templates\ndotnet new --install AElf.ContractTemplates\n\n\nAELF.ContractTemplates contains various predefined templates for the ease of developing smart contracts on the aelf blockchain.\n\nInstall aelf deploy tool\ndotnet tool install --global aelf.deploy\n\n\naelf.deploy is a utility tool for deploying smart contracts on the aelf blockchain. Please remember to export PATH after installing aelf.deploy.\n\nℹ️ Note: If you have installed aelf.deploy and your terminal says that there is no such command available, please uninstall and install aelf.deploy.\n\nInstall Node.js and Yarn\n\nInstall Node.js\nInstall aelf-command\nsudo npm i -g aelf-command\n\n\naelf-command is a CLI tool for interacting with the aelf blockchain, enabling tasks like creating wallets and managing transactions. Provide required permissions while installing aelf-command globally.\n\nStep 2 - Develop Smart Contract​\nStart Your Smart Contract Project​\n\nOpen your Terminal.\n\nEnter the following command to generate a new project:\n\nmkdir lottery-game\ncd lottery-game\ndotnet new aelf -n LotteryGame\n\nAdding Your Smart Contract Code​\n\nNow that we have a template lottery game project, we can customise the template to incorporate our own contract logic. Lets start by implementing methods to provide basic functionality for updating and reading a message stored persistently in the contract state.\n\ncd src\n\nDefining Methods and Messages​\n\nFirstly, rename Protobuf/contract/hello_world_contract.proto to lottery_game_contract.proto:\n\nmv Protobuf/contract/hello_world_contract.proto Protobuf/contract/lottery_game_contract.proto\n\n\nNext, open the project with your IDE.\n\nThe implementation of file src/Protobuf/contract/lottery_game_contract.proto is as follows:\n\nsyntax = \"proto3\";\n\nimport \"aelf/core.proto\";\nimport \"aelf/options.proto\";\nimport \"google/protobuf/empty.proto\";\nimport \"google/protobuf/wrappers.proto\";\nimport \"Protobuf/reference/acs12.proto\";\n// The namespace of this class\noption csharp_namespace = \"AElf.Contracts.LotteryGame\";\n\nservice LotteryGame {\n  // The name of the state class the smart contract is going to use to access blockchain state\n  option (aelf.csharp_state) = \"AElf.Contracts.LotteryGame.LotteryGameState\";\n  option (aelf.base) = \"Protobuf/reference/acs12.proto\";\n\n  rpc Initialize (google.protobuf.Empty) returns (google.protobuf.Empty) {\n  }\n\n  rpc Play (google.protobuf.Int64Value) returns (google.protobuf.Empty) {\n  }\n\n  rpc Withdraw (google.protobuf.Int64Value) returns (google.protobuf.Empty) {\n  }\n\n  rpc Deposit (google.protobuf.Int64Value) returns (google.protobuf.Empty) {\n  }\n\n  rpc TransferOwnership (aelf.Address) returns (google.protobuf.Empty) {\n  }\n\n  rpc GetPlayAmountLimit (google.protobuf.Empty) returns (PlayAmountLimitMessage) {\n    option (aelf.is_view) = true;\n  }\n\n  rpc GetContractBalance (google.protobuf.Empty) returns (google.protobuf.Int64Value) {\n    option (aelf.is_view) = true;\n  }\n\n  rpc GetOwner (google.protobuf.Empty) returns (google.protobuf.StringValue) {\n    option (aelf.is_view) = true;\n  }\n}\n\n// An event that will be emitted from contract method call when Play is called.\nmessage PlayOutcomeEvent {\n  option (aelf.is_event) = true;\n  int64 amount = 1;\n  int64 won = 2;\n}\n\n// An event that will be emitted from contract method call when Withdraw is called.\nmessage WithdrawEvent {\n  option (aelf.is_event) = true;\n  int64 amount = 1;\n  aelf.Address from = 2;\n  aelf.Address to = 3;\n}\n\n// An event that will be emitted from contract method call when Deposit is called.\nmessage DepositEvent {\n  option (aelf.is_event) = true;\n  int64 amount = 1;\n  aelf.Address from = 2;\n  aelf.Address to = 3;\n}\n\n// The message containing the play amount limits\nmessage PlayAmountLimitMessage {\n  int64 minimumAmount = 1;\n  int64 maximumAmount = 2;\n}\n\nDefine Contract States​\n\nThe implementation of file src/LotteryGameState.cs is as follows:\n\nusing AElf.Sdk.CSharp.State;\nusing AElf.Types;\n\nnamespace AElf.Contracts.LotteryGame\n{\n    // The state class is access the blockchain state\n    public partial class LotteryGameState : ContractState\n    {\n        // A state to check if contract is initialized\n        public BoolState Initialized { get; set; }\n        // A state to store the owner address\n        public SingletonState<Address> Owner { get; set; }\n    }\n}\n\nContract Reference State​\n\nCreate a new file token_contract.proto under src/Protobuf/reference/ The implementation of file token_contract.proto:\n\n/**\n * MultiToken contract.\n */\nsyntax = \"proto3\";\n\npackage token;\n\nimport \"aelf/core.proto\";\nimport \"aelf/options.proto\";\nimport \"google/protobuf/empty.proto\";\nimport \"google/protobuf/wrappers.proto\";\n\noption csharp_namespace = \"AElf.Contracts.MultiToken\";\n\nservice TokenContract {\n  // Create a new token.\n  rpc Create (CreateInput) returns (google.protobuf.Empty) {\n  }\n\n  // Issuing some amount of tokens to an address is the action of increasing that addresses balance\n  // for the given token. The total amount of issued tokens must not exceed the total supply of the token\n  // and only the issuer (creator) of the token can issue tokens.\n  // Issuing tokens effectively increases the circulating supply.\n  rpc Issue (IssueInput) returns (google.protobuf.Empty) {\n  }\n\n  // Transferring tokens simply is the action of transferring a given amount of tokens from one address to another.\n  // The origin or source address is the signer of the transaction.\n  // The balance of the sender must be higher than the amount that is transferred.\n  rpc Transfer (TransferInput) returns (google.protobuf.Empty) {\n  }\n\n  // The TransferFrom action will transfer a specified amount of tokens from one address to another.\n  // For this operation to succeed the from address needs to have approved (see allowances) enough tokens\n  // to Sender of this transaction. If successful the amount will be removed from the allowance.\n  rpc TransferFrom (TransferFromInput) returns (google.protobuf.Empty) {\n  }\n\n  // The approve action increases the allowance from the Sender to the Spender address,\n  // enabling the Spender to call TransferFrom.\n  rpc Approve (ApproveInput) returns (google.protobuf.Empty) {\n  }\n\n  rpc BatchApprove (BatchApproveInput) returns (google.protobuf.Empty) {\n  }\n\n  // This is the reverse operation for Approve, it will decrease the allowance.\n  rpc UnApprove (UnApproveInput) returns (google.protobuf.Empty) {\n  }\n\n  // This method can be used to lock tokens.\n  rpc Lock (LockInput) returns (google.protobuf.Empty) {\n  }\n\n  // This is the reverse operation of locking, it un-locks some previously locked tokens.\n  rpc Unlock (UnlockInput) returns (google.protobuf.Empty) {\n  }\n\n  // This action will burn the specified amount of tokens, removing them from the token’s Supply.\n  rpc Burn (BurnInput) returns (google.protobuf.Empty) {\n  }\n\n  // Set the primary token of side chain.\n  rpc SetPrimaryTokenSymbol (SetPrimaryTokenSymbolInput) returns (google.protobuf.Empty) {\n  }\n\n  // This interface is used for cross-chain transfer.\n  rpc CrossChainTransfer (CrossChainTransferInput) returns (google.protobuf.Empty) {\n  }\n\n  // This method is used to receive cross-chain transfers.\n  rpc CrossChainReceiveToken (CrossChainReceiveTokenInput) returns (google.protobuf.Empty) {\n  }\n\n  // The side chain creates tokens.\n  rpc CrossChainCreateToken(CrossChainCreateTokenInput) returns (google.protobuf.Empty) {\n  }\n\n  // When the side chain is started, the side chain is initialized with the parent chain information.\n  rpc InitializeFromParentChain (InitializeFromParentChainInput) returns (google.protobuf.Empty) {\n  }\n\n  // Handle the transaction fees charged by ChargeTransactionFees.\n  rpc ClaimTransactionFees (TotalTransactionFeesMap) returns (google.protobuf.Empty) {\n  }\n\n  // Used to collect transaction fees.\n  rpc ChargeTransactionFees (ChargeTransactionFeesInput) returns (ChargeTransactionFeesOutput) {\n  }\n\n  rpc ChargeUserContractTransactionFees(ChargeTransactionFeesInput) returns(ChargeTransactionFeesOutput){\n\n  }\n\n  // Check the token threshold.\n  rpc CheckThreshold (CheckThresholdInput) returns (google.protobuf.Empty) {\n  }\n\n  // Initialize coefficients of every type of tokens supporting charging fee.\n  rpc InitialCoefficients (google.protobuf.Empty) returns (google.protobuf.Empty){\n  }\n\n  // Processing resource token received.\n  rpc DonateResourceToken (TotalResourceTokensMaps) returns (google.protobuf.Empty) {\n  }\n\n  // A transaction resource fee is charged to implement the ACS8 standards.\n  rpc ChargeResourceToken (ChargeResourceTokenInput) returns (google.protobuf.Empty) {\n  }\n\n  // Verify that the resource token are sufficient.\n  rpc CheckResourceToken (google.protobuf.Empty) returns (google.protobuf.Empty) {\n  }\n\n  // Set the list of tokens to pay transaction fees.\n  rpc SetSymbolsToPayTxSizeFee (SymbolListToPayTxSizeFee) returns (google.protobuf.Empty){\n  }\n\n  // Update the coefficient of the transaction fee calculation formula.\n  rpc UpdateCoefficientsForSender (UpdateCoefficientsInput) returns (google.protobuf.Empty) {\n  }\n\n  // Update the coefficient of the transaction fee calculation formula.\n  rpc UpdateCoefficientsForContract (UpdateCoefficientsInput) returns (google.protobuf.Empty) {\n  }\n\n  // This method is used to initialize the governance organization for some functions,\n  // including: the coefficient of the user transaction fee calculation formula,\n  // the coefficient of the contract developer resource fee calculation formula, and the side chain rental fee.\n  rpc InitializeAuthorizedController (google.protobuf.Empty) returns (google.protobuf.Empty){\n  }\n\n  rpc AddAddressToCreateTokenWhiteList (aelf.Address) returns (google.protobuf.Empty) {\n  }\n  rpc RemoveAddressFromCreateTokenWhiteList (aelf.Address) returns (google.protobuf.Empty) {\n  }\n\n  rpc SetTransactionFeeDelegations (SetTransactionFeeDelegationsInput) returns (SetTransactionFeeDelegationsOutput){\n  }\n\n  rpc RemoveTransactionFeeDelegator (RemoveTransactionFeeDelegatorInput) returns (google.protobuf.Empty){\n  }\n\n  rpc RemoveTransactionFeeDelegatee (RemoveTransactionFeeDelegateeInput) returns (google.protobuf.Empty){\n  }\n\n  rpc SetSymbolAlias (SetSymbolAliasInput) returns (google.protobuf.Empty){\n  }\n\n  // Get all delegatees' address of delegator from input\n  rpc GetTransactionFeeDelegatees (GetTransactionFeeDelegateesInput) returns (GetTransactionFeeDelegateesOutput) {\n    option (aelf.is_view) = true;\n  }\n\n  // Query token information.\n  rpc GetTokenInfo (GetTokenInfoInput) returns (TokenInfo) {\n    option (aelf.is_view) = true;\n  }\n\n  // Query native token information.\n  rpc GetNativeTokenInfo (google.protobuf.Empty) returns (TokenInfo) {\n    option (aelf.is_view) = true;\n  }\n\n  // Query resource token information.\n  rpc GetResourceTokenInfo (google.protobuf.Empty) returns (TokenInfoList) {\n    option (aelf.is_view) = true;\n  }\n\n  // Query the balance at the specified address.\n  rpc GetBalance (GetBalanceInput) returns (GetBalanceOutput) {\n    option (aelf.is_view) = true;\n  }\n\n  // Query the account's allowance for other addresses\n  rpc GetAllowance (GetAllowanceInput) returns (GetAllowanceOutput) {\n    option (aelf.is_view) = true;\n  }\n\n  // Query the account's available allowance for other addresses\n  rpc GetAvailableAllowance (GetAllowanceInput) returns (GetAllowanceOutput) {\n    option (aelf.is_view) = true;\n  }\n\n  // Check whether the token is in the whitelist of an address,\n  // which can be called TransferFrom to transfer the token under the condition of not being credited.\n  rpc IsInWhiteList (IsInWhiteListInput) returns (google.protobuf.BoolValue) {\n    option (aelf.is_view) = true;\n  }\n\n  // Query the information for a lock.\n  rpc GetLockedAmount (GetLockedAmountInput) returns (GetLockedAmountOutput) {\n    option (aelf.is_view) = true;\n  }\n\n  // Query the address of receiving token in cross-chain transfer.\n  rpc GetCrossChainTransferTokenContractAddress (GetCrossChainTransferTokenContractAddressInput) returns (aelf.Address) {\n    option (aelf.is_view) = true;\n  }\n\n  // Query the name of the primary Token.\n  rpc GetPrimaryTokenSymbol (google.protobuf.Empty) returns (google.protobuf.StringValue) {\n    option (aelf.is_view) = true;\n  }\n\n  // Query the coefficient of the transaction fee calculation formula.\n  rpc GetCalculateFeeCoefficientsForContract (google.protobuf.Int32Value) returns (CalculateFeeCoefficients) {\n    option (aelf.is_view) = true;\n  }\n\n  // Query the coefficient of the transaction fee calculation formula.\n  rpc GetCalculateFeeCoefficientsForSender (google.protobuf.Empty) returns (CalculateFeeCoefficients) {\n    option (aelf.is_view) = true;\n  }\n\n  // Query tokens that can pay transaction fees.\n  rpc GetSymbolsToPayTxSizeFee (google.protobuf.Empty) returns (SymbolListToPayTxSizeFee){\n    option (aelf.is_view) = true;\n  }\n\n  // Query the hash of the last input of ClaimTransactionFees.\n  rpc GetLatestTotalTransactionFeesMapHash (google.protobuf.Empty) returns (aelf.Hash){\n    option (aelf.is_view) = true;\n  }\n\n  // Query the hash of the last input of DonateResourceToken.\n  rpc GetLatestTotalResourceTokensMapsHash (google.protobuf.Empty) returns (aelf.Hash){\n    option (aelf.is_view) = true;\n  }\n  rpc IsTokenAvailableForMethodFee (google.protobuf.StringValue) returns (google.protobuf.BoolValue) {\n    option (aelf.is_view) = true;\n  }\n  rpc GetReservedExternalInfoKeyList (google.protobuf.Empty) returns (StringList) {\n    option (aelf.is_view) = true;\n  }\n\n  rpc GetTransactionFeeDelegationsOfADelegatee(GetTransactionFeeDelegationsOfADelegateeInput) returns(TransactionFeeDelegations){\n    option (aelf.is_view) = true;\n  }\n\n  rpc GetTokenAlias (google.protobuf.StringValue) returns (google.protobuf.StringValue) {\n    option (aelf.is_view) = true;\n  }\n\n  rpc GetSymbolByAlias (google.protobuf.StringValue) returns (google.protobuf.StringValue) {\n    option (aelf.is_view) = true;\n  }\n}\n\nmessage TokenInfo {\n  // The symbol of the token.f\n  string symbol = 1;\n  // The full name of the token.\n  string token_name = 2;\n  // The current supply of the token.\n  int64 supply = 3;\n  // The total supply of the token.\n  int64 total_supply = 4;\n  // The precision of the token.\n  int32 decimals = 5;\n  // The address that has permission to issue the token.\n  aelf.Address issuer = 6;\n  // A flag indicating if this token is burnable.\n  bool is_burnable = 7;\n  // The chain id of the token.\n  int32 issue_chain_id = 8;\n  // The amount of issued tokens.\n  int64 issued = 9;\n  // The external information of the token.\n  ExternalInfo external_info = 10;\n  // The address that owns the token.\n  aelf.Address owner = 11;\n}\n\nmessage ExternalInfo {\n  map<string, string> value = 1;\n}\n\nmessage CreateInput {\n  // The symbol of the token.\n  string symbol = 1;\n  // The full name of the token.\n  string token_name = 2;\n  // The total supply of the token.\n  int64 total_supply = 3;\n  // The precision of the token\n  int32 decimals = 4;\n  // The address that has permission to issue the token.\n  aelf.Address issuer = 5;\n  // A flag indicating if this token is burnable.\n  bool is_burnable = 6;\n  // A whitelist address list used to lock tokens.\n  repeated aelf.Address lock_white_list = 7;\n  // The chain id of the token.\n  int32 issue_chain_id = 8;\n  // The external information of the token.\n  ExternalInfo external_info = 9;\n  // The address that owns the token.\n  aelf.Address owner = 10;\n}\n\nmessage SetPrimaryTokenSymbolInput {\n  // The symbol of the token.\n  string symbol = 1;\n}\n\nmessage IssueInput {\n  // The token symbol to issue.\n  string symbol = 1;\n  // The token amount to issue.\n  int64 amount = 2;\n  // The memo.\n  string memo = 3;\n  // The target address to issue.\n  aelf.Address to = 4;\n}\n\nmessage TransferInput {\n  // The receiver of the token.\n  aelf.Address to = 1;\n  // The token symbol to transfer.\n  string symbol = 2;\n  // The amount to to transfer.\n  int64 amount = 3;\n  // The memo.\n  string memo = 4;\n}\n\nmessage LockInput {\n  // The one want to lock his token.\n  aelf.Address address = 1;\n  // Id of the lock.\n  aelf.Hash lock_id = 2;\n  // The symbol of the token to lock.\n  string symbol = 3;\n  // a memo.\n  string usage = 4;\n  // The amount of tokens to lock.\n  int64 amount = 5;\n}\n\nmessage UnlockInput {\n  // The one want to un-lock his token.\n  aelf.Address address = 1;\n  // Id of the lock.\n  aelf.Hash lock_id = 2;\n  // The symbol of the token to un-lock.\n  string symbol = 3;\n  // a memo.\n  string usage = 4;\n  // The amount of tokens to un-lock.\n  int64 amount = 5;\n}\n\nmessage TransferFromInput {\n  // The source address of the token.\n  aelf.Address from = 1;\n  // The destination address of the token.\n  aelf.Address to = 2;\n  // The symbol of the token to transfer.\n  string symbol = 3;\n  // The amount to transfer.\n  int64 amount = 4;\n  // The memo.\n  string memo = 5;\n}\n\nmessage ApproveInput {\n  // The address that allowance will be increased.\n  aelf.Address spender = 1;\n  // The symbol of token to approve.\n  string symbol = 2;\n  // The amount of token to approve.\n  int64 amount = 3;\n}\nmessage BatchApproveInput {\n  repeated ApproveInput value = 1;\n}\n\nmessage UnApproveInput {\n  // The address that allowance will be decreased.\n  aelf.Address spender = 1;\n  // The symbol of token to un-approve.\n  string symbol = 2;\n  // The amount of token to un-approve.\n  int64 amount = 3;\n}\n\nmessage BurnInput {\n  // The symbol of token to burn.\n  string symbol = 1;\n  // The amount of token to burn.\n  int64 amount = 2;\n}\n\nmessage ChargeResourceTokenInput {\n  // Collection of charge resource token, Symbol->Amount.\n  map<string, int64> cost_dic = 1;\n  // The sender of the transaction.\n  aelf.Address caller = 2;\n}\n\nmessage TransactionFeeBill {\n  // The transaction fee dictionary, Symbol->fee.\n  map<string, int64> fees_map = 1;\n}\n\nmessage TransactionFreeFeeAllowanceBill {\n  // The transaction free fee allowance dictionary, Symbol->fee.\n  map<string, int64> free_fee_allowances_map = 1;\n}\n\nmessage CheckThresholdInput {\n  // The sender of the transaction.\n  aelf.Address sender = 1;\n  // The threshold to set, Symbol->Threshold.\n  map<string, int64> symbol_to_threshold = 2;\n  // Whether to check the allowance.\n  bool is_check_allowance = 3;\n}\n\nmessage GetTokenInfoInput {\n  // The symbol of token.\n  string symbol = 1;\n}\n\nmessage GetBalanceInput {\n  // The symbol of token.\n  string symbol = 1;\n  // The target address of the query.\n  aelf.Address owner = 2;\n}\n\nmessage GetBalanceOutput {\n  // The symbol of token.\n  string symbol = 1;\n  // The target address of the query.\n  aelf.Address owner = 2;\n  // The balance of the owner.\n  int64 balance = 3;\n}\n\nmessage GetAllowanceInput {\n  // The symbol of token.\n  string symbol = 1;\n  // The address of the token owner.\n  aelf.Address owner = 2;\n  // The address of the spender.\n  aelf.Address spender = 3;\n}\n\nmessage GetAllowanceOutput {\n  // The symbol of token.\n  string symbol = 1;\n  // The address of the token owner.\n  aelf.Address owner = 2;\n  // The address of the spender.\n  aelf.Address spender = 3;\n  // The amount of allowance.\n  int64 allowance = 4;\n}\n\nmessage CrossChainTransferInput {\n  // The receiver of transfer.\n  aelf.Address to = 1;\n  // The symbol of token.\n  string symbol = 2;\n  // The amount of token to transfer.\n  int64 amount = 3;\n  // The memo.\n  string memo = 4;\n  // The destination chain id.\n  int32 to_chain_id = 5;\n  // The chain id of the token.\n  int32 issue_chain_id = 6;\n}\n\nmessage CrossChainReceiveTokenInput {\n  // The source chain id.\n  int32 from_chain_id = 1;\n  // The height of the transfer transaction.\n  int64 parent_chain_height = 2;\n  // The raw bytes of the transfer transaction.\n  bytes transfer_transaction_bytes = 3;\n  // The merkle path created from the transfer transaction.\n  aelf.MerklePath merkle_path = 4;\n}\n\nmessage IsInWhiteListInput {\n  // The symbol of token.\n  string symbol = 1;\n  // The address to check.\n  aelf.Address address = 2;\n}\n\nmessage SymbolToPayTxSizeFee{\n  // The symbol of token.\n  string token_symbol = 1;\n  // The charge weight of primary token.\n  int32 base_token_weight = 2;\n  // The new added token charge weight. For example, the charge weight of primary Token is set to 1.\n  // The newly added token charge weight is set to 10. If the transaction requires 1 unit of primary token,\n  // the user can also pay for 10 newly added tokens.\n  int32 added_token_weight = 3;\n}\n\nmessage SymbolListToPayTxSizeFee{\n  // Transaction fee token information.\n  repeated SymbolToPayTxSizeFee symbols_to_pay_tx_size_fee = 1;\n}\n\nmessage ChargeTransactionFeesInput {\n  // The method name of transaction.\n  string method_name = 1;\n  // The contract address of transaction.\n  aelf.Address contract_address = 2;\n  // The amount of transaction size fee.\n  int64 transaction_size_fee = 3;\n  // Transaction fee token information.\n  repeated SymbolToPayTxSizeFee symbols_to_pay_tx_size_fee = 4;\n}\n\nmessage ChargeTransactionFeesOutput {\n  // Whether the charge was successful.\n  bool success = 1;\n  // The charging information.\n  string charging_information = 2;\n}\n\nmessage CallbackInfo {\n  aelf.Address contract_address = 1;\n  string method_name = 2;\n}\n\nmessage ExtraTokenListModified {\n  option (aelf.is_event) = true;\n  // Transaction fee token information.\n  SymbolListToPayTxSizeFee symbol_list_to_pay_tx_size_fee = 1;\n}\n\nmessage GetLockedAmountInput {\n  // The address of the lock.\n  aelf.Address address = 1;\n  // The token symbol.\n  string symbol = 2;\n  // The id of the lock.\n  aelf.Hash lock_id = 3;\n}\n\nmessage GetLockedAmountOutput {\n  // The address of the lock.\n  aelf.Address address = 1;\n  // The token symbol.\n  string symbol = 2;\n  // The id of the lock.\n  aelf.Hash lock_id = 3;\n  // The locked amount.\n  int64 amount = 4;\n}\n\nmessage TokenInfoList {\n  // List of token information.\n  repeated TokenInfo value = 1;\n}\n\nmessage GetCrossChainTransferTokenContractAddressInput {\n  // The chain id.\n  int32 chainId = 1;\n}\n\nmessage CrossChainCreateTokenInput {\n  // The chain id of the chain on which the token was created.\n  int32 from_chain_id = 1;\n  // The height of the transaction that created the token.\n  int64 parent_chain_height = 2;\n  // The transaction that created the token.\n  bytes transaction_bytes = 3;\n  // The merkle path created from the transaction that created the transaction.\n  aelf.MerklePath merkle_path = 4;\n}\n\nmessage InitializeFromParentChainInput {\n  // The amount of resource.\n  map<string, int32> resource_amount = 1;\n  // The token contract addresses.\n  map<int32, aelf.Address> registered_other_token_contract_addresses = 2;\n  // The creator the side chain.\n  aelf.Address creator = 3;\n}\n\nmessage UpdateCoefficientsInput {\n  // The specify pieces gonna update.\n  repeated int32 piece_numbers = 1;\n  // Coefficients of one single type.\n  CalculateFeeCoefficients coefficients = 2;\n}\n\nenum FeeTypeEnum {\n  READ = 0;\n  STORAGE = 1;\n  WRITE = 2;\n  TRAFFIC = 3;\n  TX = 4;\n}\n\nmessage CalculateFeePieceCoefficients {\n  // Coefficients of one single piece.\n  // The first char is its type: liner / power.\n  // The second char is its piece upper bound.\n  repeated int32 value = 1;\n}\n\nmessage CalculateFeeCoefficients {\n  // The resource fee type, like READ, WRITE, etc.\n  int32 fee_token_type = 1;\n  // Coefficients of one single piece.\n  repeated CalculateFeePieceCoefficients piece_coefficients_list = 2;\n}\n\nmessage AllCalculateFeeCoefficients {\n  // The coefficients of fee Calculation.\n  repeated CalculateFeeCoefficients value = 1;\n}\n\nmessage TotalTransactionFeesMap\n{\n  // Token dictionary that charge transaction fee, Symbol->Amount.\n  map<string, int64> value = 1;\n  // The hash of the block processing the transaction.\n  aelf.Hash block_hash = 2;\n  // The height of the block processing the transaction.\n  int64 block_height = 3;\n}\n\nmessage TotalResourceTokensMaps {\n  // Resource tokens to charge.\n  repeated ContractTotalResourceTokens value = 1;\n  // The hash of the block processing the transaction.\n  aelf.Hash block_hash = 2;\n  // The height of the block processing the transaction.\n  int64 block_height = 3;\n}\n\nmessage ContractTotalResourceTokens {\n  // The contract address.\n  aelf.Address contract_address = 1;\n  // Resource tokens to charge.\n  TotalResourceTokensMap tokens_map = 2;\n}\n\nmessage TotalResourceTokensMap\n{\n  // Resource token dictionary, Symbol->Amount.\n  map<string, int64> value = 1;\n}\n\nmessage StringList {\n  repeated string value = 1;\n}\n\nmessage TransactionFeeDelegations{\n  // delegation, symbols and its' amount\n  map<string, int64> delegations = 1;\n  // height when added\n  int64 block_height = 2;\n  //Whether to pay transaction fee continuously\n  bool isUnlimitedDelegate = 3;\n}\n\nmessage TransactionFeeDelegatees{\n  map<string,TransactionFeeDelegations> delegatees = 1;\n}\n\nmessage SetTransactionFeeDelegationsInput {\n  // the delegator address\n  aelf.Address delegator_address = 1;\n  // delegation, symbols and its' amount\n  map<string, int64> delegations = 2;\n}\n\nmessage SetTransactionFeeDelegationsOutput {\n  bool success = 1;\n}\n\nmessage RemoveTransactionFeeDelegatorInput{\n  // the delegator address\n  aelf.Address delegator_address = 1;\n}\n\nmessage RemoveTransactionFeeDelegateeInput {\n  // the delegatee address\n  aelf.Address delegatee_address = 1;\n}\n\nmessage GetTransactionFeeDelegationsOfADelegateeInput {\n  aelf.Address delegatee_address = 1;\n  aelf.Address delegator_address = 2;\n}\n\nmessage GetTransactionFeeDelegateesInput {\n  aelf.Address delegator_address = 1;\n}\n\nmessage GetTransactionFeeDelegateesOutput {\n  repeated aelf.Address delegatee_addresses = 1;\n}\n\nmessage SetSymbolAliasInput {\n  string symbol = 1;\n  string alias = 2;\n}\n\n// Events\n\nmessage Transferred {\n  option (aelf.is_event) = true;\n  // The source address of the transferred token.\n  aelf.Address from = 1 [(aelf.is_indexed) = true];\n  // The destination address of the transferred token.\n  aelf.Address to = 2 [(aelf.is_indexed) = true];\n  // The symbol of the transferred token.\n  string symbol = 3 [(aelf.is_indexed) = true];\n  // The amount of the transferred token.\n  int64 amount = 4;\n  // The memo.\n  string memo = 5;\n}\n\nmessage Approved {\n  option (aelf.is_event) = true;\n  // The address of the token owner.\n  aelf.Address owner = 1 [(aelf.is_indexed) = true];\n  // The address that allowance be increased.\n  aelf.Address spender = 2 [(aelf.is_indexed) = true];\n  // The symbol of approved token.\n  string symbol = 3 [(aelf.is_indexed) = true];\n  // The amount of approved token.\n  int64 amount = 4;\n}\n\nmessage UnApproved {\n  option (aelf.is_event) = true;\n  // The address of the token owner.\n  aelf.Address owner = 1 [(aelf.is_indexed) = true];\n  // The address that allowance be decreased.\n  aelf.Address spender = 2 [(aelf.is_indexed) = true];\n  // The symbol of un-approved token.\n  string symbol = 3 [(aelf.is_indexed) = true];\n  // The amount of un-approved token.\n  int64 amount = 4;\n}\n\nmessage Burned\n{\n  option (aelf.is_event) = true;\n  // The address who wants to burn token.\n  aelf.Address burner = 1 [(aelf.is_indexed) = true];\n  // The symbol of burned token.\n  string symbol = 2 [(aelf.is_indexed) = true];\n  // The amount of burned token.\n  int64 amount = 3;\n}\n\nmessage ChainPrimaryTokenSymbolSet {\n  option (aelf.is_event) = true;\n  // The symbol of token.\n  string token_symbol = 1;\n}\n\nmessage CalculateFeeAlgorithmUpdated {\n  option (aelf.is_event) = true;\n  // All calculate fee coefficients after modification.\n  AllCalculateFeeCoefficients all_type_fee_coefficients = 1;\n}\n\nmessage RentalCharged {\n  option (aelf.is_event) = true;\n  // The symbol of rental fee charged.\n  string symbol = 1;\n  // The amount of rental fee charged.\n  int64 amount = 2;\n  // The payer of rental fee.\n  aelf.Address payer = 3;\n  // The receiver of rental fee.\n  aelf.Address receiver = 4;\n}\n\nmessage RentalAccountBalanceInsufficient {\n  option (aelf.is_event) = true;\n  // The symbol of insufficient rental account balance.\n  string symbol = 1;\n  // The balance of the account.\n  int64 amount = 2;\n}\n\nmessage TokenCreated {\n  option (aelf.is_event) = true;\n  // The symbol of the token.\n  string symbol = 1;\n  // The full name of the token.\n  string token_name = 2;\n  // The total supply of the token.\n  int64 total_supply = 3;\n  // The precision of the token.\n  int32 decimals = 4;\n  // The address that has permission to issue the token.\n  aelf.Address issuer = 5;\n  // A flag indicating if this token is burnable.\n  bool is_burnable = 6;\n  // The chain id of the token.\n  int32 issue_chain_id = 7;\n  // The external information of the token.\n  ExternalInfo external_info = 8;\n  // The address that owns the token.\n  aelf.Address owner = 9;\n}\n\nmessage Issued {\n  option (aelf.is_event) = true;\n  // The symbol of issued token.\n  string symbol = 1;\n  // The amount of issued token.\n  int64 amount = 2;\n  // The memo.\n  string memo = 3;\n  // The issued target address.\n  aelf.Address to = 4;\n}\n\nmessage CrossChainTransferred {\n  option (aelf.is_event) = true;\n  // The source address of the transferred token.\n  aelf.Address from = 1;\n  // The destination address of the transferred token.\n  aelf.Address to = 2;\n  // The symbol of the transferred token.\n  string symbol = 3;\n  // The amount of the transferred token.\n  int64 amount = 4;\n  // The memo.\n  string memo = 5;\n  // The destination chain id.\n  int32 to_chain_id = 6;\n  // The chain id of the token.\n  int32 issue_chain_id = 7;\n}\n\nmessage CrossChainReceived {\n  option (aelf.is_event) = true;\n  // The source address of the transferred token.\n  aelf.Address from = 1;\n  // The destination address of the transferred token.\n  aelf.Address to = 2;\n  // The symbol of the received token.\n  string symbol = 3;\n  // The amount of the received token.\n  int64 amount = 4;\n  // The memo.\n  string memo = 5;\n  // The destination chain id.\n  int32 from_chain_id = 6;\n  // The chain id of the token.\n  int32 issue_chain_id = 7;\n  // The parent chain height of the transfer transaction.\n  int64 parent_chain_height = 8;\n  // The id of transfer transaction.\n  aelf.Hash transfer_transaction_id =9;\n}\n\nmessage TransactionFeeDelegationAdded {\n  option (aelf.is_event) = true;\n  aelf.Address delegator = 1 [(aelf.is_indexed) = true];\n  aelf.Address delegatee = 2 [(aelf.is_indexed) = true];\n  aelf.Address caller = 3 [(aelf.is_indexed) = true];\n}\n\nmessage TransactionFeeDelegationCancelled {\n  option (aelf.is_event) = true;\n  aelf.Address delegator = 1 [(aelf.is_indexed) = true];\n  aelf.Address delegatee = 2 [(aelf.is_indexed) = true];\n  aelf.Address caller = 3 [(aelf.is_indexed) = true];\n}\n\nmessage SymbolAliasAdded {\n  option (aelf.is_event) = true;\n  string symbol = 1 [(aelf.is_indexed) = true];\n  string alias = 2 [(aelf.is_indexed) = true];\n}\n\nmessage SymbolAliasDeleted {\n  option (aelf.is_event) = true;\n  string symbol = 1 [(aelf.is_indexed) = true];\n  string alias = 2 [(aelf.is_indexed) = true];\n}\n\nContract Reference State​\n\nNavigate to src and create a new file ContractReferences.cs The implementation of file src/ContractRefefrence.cs is as follows:\n\nusing AElf.Contracts.MultiToken;\n\nnamespace AElf.Contracts.LotteryGame\n{\n    public partial class LotteryGameState\n    {\n        internal TokenContractContainer.TokenContractReferenceState TokenContract { get; set; }\n    }\n}\n\nImplement Lottery Game Smart Contract​\n\nNavigate to src/LotteryGame.cs\n\nusing AElf.Contracts.MultiToken;\nusing AElf.Sdk.CSharp;\nusing AElf.Types;\nusing Google.Protobuf.WellKnownTypes;\n\nnamespace AElf.Contracts.LotteryGame\n{\n    // Contract class must inherit the base class generated from the proto file\n    public class LotteryGame : LotteryGameContainer.LotteryGameBase\n    {\n        private const string TokenContractAddress = \"ASh2Wt7nSEmYqnGxPPzp4pnVDU4uhj1XW9Se5VeZcX2UDdyjx\"; // tDVW token contract address\n        private const string TokenSymbol = \"ELF\";\n        private const long MinimumPlayAmount = 1_000_000; // 0.01 ELF\n        private const long MaximumPlayAmount = 1_000_000_000; // 10 ELF\n\n        // Initializes the contract\n        public override Empty Initialize(Empty input)\n        {\n            // Check if the contract is already initialized\n            Assert(State.Initialized.Value == false, \"Already initialized.\");\n            // Set the contract state\n            State.Initialized.Value = true;\n            // Set the owner address\n            State.Owner.Value = Context.Sender;\n\n            // Initialize the token contract\n            State.TokenContract.Value = Address.FromBase58(TokenContractAddress);\n\n            return new Empty();\n        }\n\n        // Plays the lottery game with a specified amount of tokens.\n        // The method checks if the play amount is within the limit.\n        // If the player wins, tokens are transferred from the contract to the sender and a PlayOutcomeEvent is fired with the won amount.\n        // If the player loses, tokens are transferred from the sender to the contract and a PlayOutcomeEvent is fired with the lost amount.\n        public override Empty Play(Int64Value input)\n        {\n            var playAmount = input.Value;\n\n            // Check if input amount is within the limit\n            Assert(playAmount is >= MinimumPlayAmount and <= MaximumPlayAmount, \"Invalid play amount.\");\n\n            // Check if the sender has enough tokens\n            var balance = State.TokenContract.GetBalance.Call(new GetBalanceInput\n            {\n                Owner = Context.Sender,\n                Symbol = TokenSymbol\n            }).Balance;\n            Assert(balance >= playAmount, \"Insufficient balance.\");\n\n            // Check if the contract has enough tokens\n            var contractBalance = State.TokenContract.GetBalance.Call(new GetBalanceInput\n            {\n                Owner = Context.Self,\n                Symbol = TokenSymbol\n            }).Balance;\n            Assert(contractBalance >= playAmount, \"Insufficient contract balance.\");\n\n            if(IsWinner())\n            {\n                // Transfer the token from the contract to the sender\n                State.TokenContract.Transfer.Send(new TransferInput\n                {\n                    To = Context.Sender,\n                    Symbol = TokenSymbol,\n                    Amount = playAmount\n                });\n\n                // Emit an event to notify listeners about the outcome\n                Context.Fire(new PlayOutcomeEvent\n                {\n                    Amount = input.Value,\n                    Won = playAmount\n                });\n            }\n            else\n            {\n                // Transfer the token from the sender to the contract\n                State.TokenContract.TransferFrom.Send(new TransferFromInput\n                {\n                    From = Context.Sender,\n                    To = Context.Self,\n                    Symbol = TokenSymbol,\n                    Amount = playAmount\n                });\n\n                // Emit an event to notify listeners about the outcome\n                Context.Fire(new PlayOutcomeEvent\n                {\n                    Amount = input.Value,\n                    Won = -playAmount\n                });\n            }\n\n            return new Empty();\n        }\n\n        // Withdraws a specified amount of tokens from the contract.\n        // This method can only be called by the owner of the contract.\n        // After the tokens are transferred, a WithdrawEvent is fired to notify any listeners about the withdrawal.\n        public override Empty Withdraw(Int64Value input)\n        {\n            AssertIsOwner();\n\n            // Transfer the token from the contract to the sender\n            State.TokenContract.Transfer.Send(new TransferInput\n            {\n                To = Context.Sender,\n                Symbol = TokenSymbol,\n                Amount = input.Value\n            });\n\n            // Emit an event to notify listeners about the withdrawal\n            Context.Fire(new WithdrawEvent\n            {\n                Amount = input.Value,\n                From = Context.Self,\n                To = State.Owner.Value\n            });\n\n            return new Empty();\n        }\n\n        // Deposits a specified amount of tokens into the contract.\n        // This method can only be called by the owner of the contract.\n        // After the tokens are transferred, a DepositEvent is fired to notify any listeners about the deposit.\n       public override Empty Deposit(Int64Value input)\n        {\n            AssertIsOwner();\n\n            // Transfer the token from the sender to the contract\n            State.TokenContract.TransferFrom.Send(new TransferFromInput\n            {\n                From = Context.Sender,\n                To = Context.Self,\n                Symbol = TokenSymbol,\n                Amount = input.Value\n            });\n\n            // Emit an event to notify listeners about the deposit\n            Context.Fire(new DepositEvent\n            {\n                Amount = input.Value,\n                From = Context.Sender,\n                To = Context.Self\n            });\n\n            return new Empty();\n        }\n\n        // Transfers the ownership of the contract to a new owner.\n        // This method can only be called by the current owner of the contract.\n        public override Empty TransferOwnership(Address input)\n        {\n            AssertIsOwner();\n\n            // Set the new owner address\n            State.Owner.Value = input;\n\n            return new Empty();\n        }\n\n        // A method that read the contract's play amount limit\n        public override PlayAmountLimitMessage GetPlayAmountLimit(Empty input)\n        {\n            // Wrap the value in the return type\n            return new PlayAmountLimitMessage\n            {\n                MinimumAmount = MinimumPlayAmount,\n                MaximumAmount = MaximumPlayAmount\n            };\n        }\n\n        // A method that read the contract's current balance\n        public override Int64Value GetContractBalance(Empty input)\n        {\n            // Get the balance of the contract\n            var balance = State.TokenContract.GetBalance.Call(new GetBalanceInput\n            {\n                Owner = Context.Self,\n                Symbol = TokenSymbol\n            }).Balance;\n\n            // Wrap the value in the return type\n            return new Int64Value\n            {\n                Value = balance\n            };\n        }\n\n        // A method that read the contract's owner\n        public override StringValue GetOwner(Empty input)\n        {\n            return State.Owner.Value == null ? new StringValue() : new StringValue {Value = State.Owner.Value.ToBase58()};\n        }\n\n        // Determines if the player is a winner.\n        // This method generates a random number based on the current block height and checks if it's equal to 0.\n        // If the random number is 0, the player is considered a winner.\n        private bool IsWinner()\n        {\n            var randomNumber = Context.CurrentHeight % 2;\n            return randomNumber == 0;\n        }\n\n        // This method is used to ensure that only the owner of the contract can perform certain actions.\n        // If the context sender is not the owner, an exception is thrown with the message \"Unauthorized to perform the action.\"\n        private void AssertIsOwner()\n        {\n            Assert(Context.Sender == State.Owner.Value, \"Unauthorized to perform the action.\");\n        }\n    }\n\n}\n\nBuilding Smart Contract​\n\nBuild the new code with the following commands inside src folder:\n\ndotnet build\n\n\nYou should see LotteryGame.dll.patched in the directory lottery_game/src/bin/Debug/net.6.0\n\nStep 3 - Deploy Smart Contract​\nCreate A Wallet​\n\nTo send transactions on the aelf blockchain, you must have a wallet.\n\nRun this command to create aelf wallet.\n\naelf-command create\n\n\nYou will be prompted to save your account, please do save your account as shown below:\n\n? Save account info into a file? (Y/n) Y\n\n\nNext, enter and confirm your password. Then export your wallet password as shown below:\n\nexport WALLET_PASSWORD=\"YOUR_WALLET_PASSWORD\"\n\nAcquire Testnet Tokens (Faucet) for Development​\n\nTo deploy smart contracts or execute on-chain transactions on aelf, you'll require testnet ELF tokens.\n\nGet ELF Tokens\n\nCLI\nWeb\n\nRun the following command to get testnet ELF tokens from faucet. Remember to either export your wallet address and wallet password or replace \n𝑊\n𝐴\n𝐿\n𝐿\n𝐸\n𝑇\n𝐴\n𝐷\n𝐷\n𝑅\n𝐸\n𝑆\n𝑆\n𝑎\n𝑛\n𝑑\nWALLET\nA\n\t​\n\nDDRESSandWALLET_ADDRESS with your wallet address and wallet password respectively.\n\nexport WALLET_ADDRESS=\"YOUR_WALLET_ADDRESS\"\ncurl -X POST \"https://faucet.aelf.dev/api/claim?walletAddress=$WALLET_ADDRESS\" -H \"accept: application/json\" -d \"\"\n\n\nTo check your wallet's current ELF balance:\n\naelf-command call ASh2Wt7nSEmYqnGxPPzp4pnVDU4uhj1XW9Se5VeZcX2UDdyjx -a $WALLET_ADDRESS -p $WALLET_PASSWORD -e https://tdvw-test-node.aelf.io GetBalance\n\n\nYou will be prompted for the following:\n\nEnter the required param <symbol>: ELF\nEnter the required param <owner>: **$WALLET_ADDRESS**\n\n\nYou should see the result displaying your wallet's ELF balance.\n\nThe smart contract needs to be deployed on the chain before users can interact with it.\n\nRun the following command to deploy a contract. Remember to export the path of LotteryGame.dll.patched to CONTRACT_PATH.\n\nexport CONTRACT_PATH=$(find ~+ . -path \"*patched*\" | head -n 1)\n\naelf-deploy -a $WALLET_ADDRESS -p $WALLET_PASSWORD -c $CONTRACT_PATH -e https://tdvw-test-node.aelf.io/\n\n\nPlease wait for approximately 1 to 2 minutes. If the deployment is successful, it will provide you with the contract address.\n\nExport your smart contract address:\n\nexport CONTRACT_ADDRESS=\"YOUR_SMART_CONTRACT_ADDRESS e.g. 2LUmicHyH4RXrMjG4beDwuDsiWJESyLkgkwPdGTR8kahRzq5XS\"\n\nStep 4 - Interact with Your Deployed Smart Contract​\nApproving Smart Contract Spending​\naelf-command send ASh2Wt7nSEmYqnGxPPzp4pnVDU4uhj1XW9Se5VeZcX2UDdyjx -a $WALLET_ADDRESS -p $WALLET_PASSWORD -e https://tdvw-test-node.aelf.io Approve\n\nTIP\n\nℹ️ Note: ASh2Wt7nSEmYqnGxPPzp4pnVDU4uhj1XW9Se5VeZcX2UDdyjx is the contract address of Multitoken Contract on aelf Testnet Sidechain (tDVW).\n\nWhen prompted, enter the following parameters to approve the spending of 90 ELF tokens:\n\nEnter the params one by one, type `Enter` to skip optional param:\n? Enter the required param <spender>: \"INSERT_YOUR_CONTRACT_ADDRESS_HERE\"\n? Enter the required param <symbol>: ELF\n? Enter the required param <amount>: 9000000000\n\nInitializing Lottery Game Contract​\naelf-command send $CONTRACT_ADDRESS -a $WALLET_ADDRESS -p $WALLET_PASSWORD -e https://tdvw-test-node.aelf.io Initialize\n\nDepositing funds into the Lottery Game Contract​\naelf-command send $CONTRACT_ADDRESS -a $WALLET_ADDRESS -p $WALLET_PASSWORD -e https://tdvw-test-node.aelf.io Deposit\n\nPlaying the Lottery Game​\naelf-command send $CONTRACT_ADDRESS -a $WALLET_ADDRESS -p $WALLET_PASSWORD -e https://tdvw-test-node.aelf.io Play\n\n\nLet's check the balance\n\naelf-command call ASh2Wt7nSEmYqnGxPPzp4pnVDU4uhj1XW9Se5VeZcX2UDdyjx -a $WALLET_ADDRESS -p $WALLET_PASSWORD -e https://tdvw-test-node.aelf.io GetBalance\n\n\nYou will be prompted for the following:\n\nEnter the required param <symbol>: ELF\nEnter the required param <owner>: $WALLET_ADDRESS\n\nPrevious\nHello World Contract\nNext\nVote Contract\nStep 1 - Setting up your development environment\nStep 2 - Develop Smart Contract\nStart Your Smart Contract Project\nAdding Your Smart Contract Code\nBuilding Smart Contract\nStep 3 - Deploy Smart Contract\nStep 4 - Interact with Your Deployed Smart Contract\nApproving Smart Contract Spending\nInitializing Lottery Game Contract\nDepositing funds into the Lottery Game Contract\nPlaying the Lottery Game\nPlatform\nTechnology\nAudit Report\nPrivacy\nTerms of Use\nCookie Policy\nDeveloper Resources\nQuick Start\nLearn\nDocs\nTools\nResources\nEcosystem\nOverview\ndApps\naelf Ventures\nBlog\nConnect\nContact Us\nCopyright © 2024 aelf"
    },
    {
      "title": "AELF Docs",
      "url": "https://docs.aelf.com/quick-start/developers/hello-world-contract/",
      "html": "Skip to main content\nQuick Start\nLearn\nDocs\nTools\nResources\nBlog\nSearch\nQuick Start\nFor Developers\nHello World Contract\nLottery Game Contract\nVote Contract\nFor Node Operators\nQuick StartFor DevelopersHello World Contract\nCreating your first contract\n\nDescription: This is the simplest contract to get you started. It introduces the basic structure of a smart contract and shows how to deploy and interact with it.\n\nPurpose: To familiarize you with the basic syntax and deployment process of smart contracts on aelf blockchain.\n\nDifficulty Level: Easy\n\nStep 1 - Setting up your development environment​\nLocal\nCodespaces\nBasic knowledge of terminal commands\nIDE - Install VS Code\n\nInstall Required Packages\n\nInstall dotnet 6.0 SDK\nInstall aelf contract templates\ndotnet new --install AElf.ContractTemplates\n\n\nAELF.ContractTemplates contains various predefined templates for the ease of developing smart contracts on the aelf blockchain.\n\nInstall aelf deploy tool\ndotnet tool install --global aelf.deploy\n\n\naelf.deploy is a utility tool for deploying smart contracts on the aelf blockchain. Please remember to export PATH after installing aelf.deploy.\n\nℹ️ Note: If you have installed aelf.deploy and your terminal says that there is no such command available, please uninstall and install aelf.deploy.\n\nInstall Node.js and Yarn\n\nInstall Node.js\nInstall aelf-command\nsudo npm i -g aelf-command\n\n\naelf-command is a CLI tool for interacting with the aelf blockchain, enabling tasks like creating wallets and managing transactions. Provide required permissions while installing aelf-command globally.\n\nStep 2 - Develop Smart Contract​\nStart Your Smart Contract Project​\n\nOpen your Terminal.\n\nEnter the following command to generate a new project:\n\nmkdir hello-world\ncd hello-world\ndotnet new aelf -n HelloWorld\n\nAdding Your Smart Contract Code​\n\nNow that we have a template hello world project, we can customise the template to incorporate our own contract logic. Lets start by implementing methods to provide basic functionality for updating and reading a message stored persistently in the contract state.\n\ncd src\n\n\nThe implementation of file src/HelloWorldState.cs is as follows:\n\nusing AElf.Sdk.CSharp.State;\n\nnamespace AElf.Contracts.HelloWorld\n{\n    // The state class is access the blockchain state\n    public class HelloWorldState : ContractState\n    {\n        // A state that holds string value\n\n        public StringState Message { get; set; }\n\n    }\n}\n\n\nThe implementation of file src/HelloWorld.cs is as follows:\n\n// contract implementation starts here\nnamespace AElf.Contracts.HelloWorld\n{\n    public class HelloWorld : HelloWorldContainer.HelloWorldBase\n    {\n        // A method that updates the contract state, Message with a user input\n\n        public override Empty Update(StringValue input)\n\n        {\n\n            State.Message.Value = input.Value;\n\n            Context.Fire(new UpdatedMessage\n\n            {\n\n                Value = input.Value\n\n            });\n\n            return new Empty();\n\n        }\n\n\n\n        // A method that reads the contract state, Message\n\n        public override StringValue Read(Empty input)\n\n        {\n\n            var value = State.Message.Value;\n\n            return new StringValue\n\n            {\n\n                Value = value\n\n            };\n\n        }\n\n    }\n}\n\nBuilding Smart Contract​\n\nBuild the new code with the following commands inside src folder:\n\ndotnet build\n\nStep 3 - Deploy Smart Contract​\nCreate A Wallet​\n\nTo send transactions on the aelf blockchain, you must have a wallet.\n\nRun this command to create aelf wallet.\n\naelf-command create\n\n\nYou will be prompted to save your account, please do save your account as shown below:\n\n? Save account info into a file? (Y/n) Y\n\n\nNext, enter and confirm your password. Then export your wallet password as shown below:\n\nexport WALLET_PASSWORD=\"YOUR_WALLET_PASSWORD\"\n\nAcquire Testnet Tokens (Faucet) for Development​\n\nTo deploy smart contracts or execute on-chain transactions on aelf, you'll require testnet ELF tokens.\n\nGet ELF Tokens\n\nCLI\nWeb\n\nRun the following command to get testnet ELF tokens from faucet. Remember to either export your wallet address and wallet password or replace \n𝑊\n𝐴\n𝐿\n𝐿\n𝐸\n𝑇\n𝐴\n𝐷\n𝐷\n𝑅\n𝐸\n𝑆\n𝑆\n𝑎\n𝑛\n𝑑\nWALLET\nA\n\t​\n\nDDRESSandWALLET_ADDRESS with your wallet address and wallet password respectively.\n\nexport WALLET_ADDRESS=\"YOUR_WALLET_ADDRESS\"\ncurl -X POST \"https://faucet.aelf.dev/api/claim?walletAddress=$WALLET_ADDRESS\" -H \"accept: application/json\" -d \"\"\n\n\nTo check your wallet's current ELF balance:\n\naelf-command call ASh2Wt7nSEmYqnGxPPzp4pnVDU4uhj1XW9Se5VeZcX2UDdyjx -a $WALLET_ADDRESS -p $WALLET_PASSWORD -e https://tdvw-test-node.aelf.io GetBalance\n\n\nYou will be prompted for the following:\n\nEnter the required param <symbol>: ELF\nEnter the required param <owner>: **$WALLET_ADDRESS**\n\n\nYou should see the result displaying your wallet's ELF balance.\n\nThe smart contract needs to be deployed on the chain before users can interact with it.\n\nRun the following command to deploy a contract. Remember to export the path of LotteryGame.dll.patched to CONTRACT_PATH.\n\nexport CONTRACT_PATH=$(find ~+ . -path \"*patched*\" | head -n 1)\n\naelf-deploy -a $WALLET_ADDRESS -p $WALLET_PASSWORD -c $CONTRACT_PATH -e https://tdvw-test-node.aelf.io/\n\n\nPlease wait for approximately 1 to 2 minutes. If the deployment is successful, it will provide you with the contract address.\n\nExport your smart contract address:\n\nexport CONTRACT_ADDRESS=\"YOUR_SMART_CONTRACT_ADDRESS e.g. 2LUmicHyH4RXrMjG4beDwuDsiWJESyLkgkwPdGTR8kahRzq5XS\"\n\nStep 4 - Interact with Your Deployed Smart Contract​\n\nLets try to call methods on your newly-deployed smart contract using aelf-command.\n\nFirstly, we will set a message using the Update method. Run the following command, and enter the message argument as test. This will set test into the Message contract state. Remember to export CONTRACT_ADDRESS equals to your deployed contract address.\n\naelf-command send $CONTRACT_ADDRESS -a $WALLET_ADDRESS -p $WALLET_PASSWORD -e https://tdvw-test-node.aelf.io Update\n\n\nAfter that, we can use Read method to retrieve the value previously set for the Message contract state. Running the following command should yield test.\n\naelf-command call $CONTRACT_ADDRESS -a $WALLET_ADDRESS -p $WALLET_PASSWORD -e https://tdvw-test-node.aelf.io Read\n\nPrevious\nFor Developers\nNext\nLottery Game Contract\nStep 1 - Setting up your development environment\nStep 2 - Develop Smart Contract\nStart Your Smart Contract Project\nAdding Your Smart Contract Code\nBuilding Smart Contract\nStep 3 - Deploy Smart Contract\nStep 4 - Interact with Your Deployed Smart Contract\nPlatform\nTechnology\nAudit Report\nPrivacy\nTerms of Use\nCookie Policy\nDeveloper Resources\nQuick Start\nLearn\nDocs\nTools\nResources\nEcosystem\nOverview\ndApps\naelf Ventures\nBlog\nConnect\nContact Us\nCopyright © 2024 aelf"
    },
    {
      "title": "AELF Docs",
      "url": "https://docs.aelf.com/resources/",
      "html": "Skip to main content\nQuick Start\nLearn\nDocs\nTools\nResources\nBlog\nSearch\nResources\nIntegration Guide\nWallet and Block Explorer\nAetherLink\nBrowser Extension\nDevOps\nProtobuf Extension\nWhitepapers\nResources\nResources\n📄️ Integration Guide\n\nLearn how to integrate with other tools and DApps\n\n📄️ Wallet and Block Explorer\n\nManage your assets and explore aelf's blockchain data\n\n📄️ AetherLink\n\nTransfer tamper-proof data from off-chain to on-chain\n\n📄️ Browser Extension\n\nExplore Portkey wallet and other extensions\n\n📄️ DevOps\n\nTools to build and deploy efficiently\n\n📄️ Protobuf Extension\n\nAn open-source gRPC\n\n📄️ Whitepapers\n\naelf Whitepapers\n\nNext\nIntegration Guide\nPlatform\nTechnology\nAudit Report\nPrivacy\nTerms of Use\nCookie Policy\nDeveloper Resources\nQuick Start\nLearn\nDocs\nTools\nResources\nEcosystem\nOverview\ndApps\naelf Ventures\nBlog\nConnect\nContact Us\nCopyright © 2024 aelf"
    },
    {
      "title": "Tools | AELF Docs",
      "url": "https://docs.aelf.com/tools/",
      "html": "Skip to main content\nQuick Start\nLearn\nDocs\nTools\nResources\nBlog\nSearch\nTools\nChain SDK\naelf Deploy Tool\naelf CLI\nSmart Contract\naelf Testnet Faucet\naelf Design\naelf Playground\nContract SDK\nTools\nTools\n🗃️ Chain SDK\n\nSDKs for working with the blockchain.\n\n📄️ aelf Deploy Tool\n\naelf-deploy simplifies contract updates\n\n🗃️ aelf CLI\n\nCommand-line interface for aelf\n\n🗃️ Smart Contract\n\nUseful contract templates for aelf\n\n📄️ aelf Testnet Faucet\n\nGet your free test aelf tokens.\n\n📄️ aelf Design\n\nUI component library based on Antd.\n\n📄️ aelf Playground\n\nPlay with aelf in your browser.\n\n🗃️ Contract SDK\n\nC# SDKs for smart contracts\n\nNext\nChain SDK\nPlatform\nTechnology\nAudit Report\nPrivacy\nTerms of Use\nCookie Policy\nDeveloper Resources\nQuick Start\nLearn\nDocs\nTools\nResources\nEcosystem\nOverview\ndApps\naelf Ventures\nBlog\nConnect\nContact Us\nCopyright © 2024 aelf"
    },
    {
      "title": "Docs Reference | AELF Docs",
      "url": "https://docs.aelf.com/docs/",
      "html": "Skip to main content\nQuick Start\nLearn\nDocs\nTools\nResources\nBlog\nSearch\nDocs Reference\nSmart Contract API\nWeb API\nDocs Reference\nDocs Reference\n🗃️ Smart Contract API\n\nUseful references for smart contract.\n\n🗃️ Web API\n\nUseful references for web.\n\nNext\nSmart Contract API\nPlatform\nTechnology\nAudit Report\nPrivacy\nTerms of Use\nCookie Policy\nDeveloper Resources\nQuick Start\nLearn\nDocs\nTools\nResources\nEcosystem\nOverview\ndApps\naelf Ventures\nBlog\nConnect\nContact Us\nCopyright © 2024 aelf"
    },
    {
      "title": "Understanding aelf | AELF Docs",
      "url": "https://docs.aelf.com/learn/",
      "html": "Skip to main content\nQuick Start\nLearn\nDocs\nTools\nResources\nBlog\nSearch\nUnderstanding aelf\nCore\nCross Chain\nConsensus\nNetwork\nBoot Sequence\nAddresses\nTransactions\nSmart Contract\nACS\nTutorials\nNode Operator\nUnderstanding aelf\nUnderstanding aelf\n🗃️ Core\n\nArchitecture of aelf\n\n🗃️ Cross Chain\n\nCross Chain mechanics\n\n📄️ Consensus\n\naelf consensus mechanism\n\n📄️ Network\n\naelf's network layer\n\n📄️ Boot Sequence\n\naelf's node startup process\n\n📄️ Addresses\n\nHow aelf addresses work\n\n📄️ Transactions\n\nHow transactions modify state\n\n🗃️ Smart Contract\n\nHow aelf smart contracts work\n\n🗃️ ACS\n\naelf Contract Standards\n\nNext\nCore\nPlatform\nTechnology\nAudit Report\nPrivacy\nTerms of Use\nCookie Policy\nDeveloper Resources\nQuick Start\nLearn\nDocs\nTools\nResources\nEcosystem\nOverview\ndApps\naelf Ventures\nBlog\nConnect\nContact Us\nCopyright © 2024 aelf"
    },
    {
      "title": "AELF Docs",
      "url": "https://docs.aelf.com/quick-start/",
      "html": "Skip to main content\nQuick Start\nLearn\nDocs\nTools\nResources\nBlog\nSearch\nQuick Start\nFor Developers\nFor Node Operators\nQuick Start\nQuick Start\n🗃️ For Developers\n\nLearn to build DApps on aelf\n\n🗃️ For Node Operators\n\nLearn to set up and operate an aelf Node\n\nNext\nFor Developers\nPlatform\nTechnology\nAudit Report\nPrivacy\nTerms of Use\nCookie Policy\nDeveloper Resources\nQuick Start\nLearn\nDocs\nTools\nResources\nEcosystem\nOverview\ndApps\naelf Ventures\nBlog\nConnect\nContact Us\nCopyright © 2024 aelf"
    },
    {
      "title": "AELF Docs",
      "url": "https://docs.aelf.com/",
      "html": "Skip to main content\nQuick Start\nLearn\nDocs\nTools\nResources\nBlog\nSearch\n\naelf Documentation\n\naelf is a high-performance, cloud-native, layer-1 blockchain with Mainnet nodes in cloud data centers. It supports parallel smart contract execution, microservices, and scalable MainChain and multi-SideChains architecture. The cross-chain design enables fast data interaction, and its hybrid SideChain model reduces costs and boosts network performance.\n\n🏁 Quick Start​\nFor developers\nHello World contract\nLottery Game contract\nVote contract\nFor node operators\nOperations\nRun a mainnet node\nSimulate in your local environment\nCreate a side chain\n📚 Understanding aelf​\nCore - aelf's core architecture\nCross-chain - aelf's cross-chain architecture\nConsensus - Understanding aelf's consensus mechanism\nNetwork - Exploring aelf's network architecture\nBoot Sequence - Learn about aelf's boot sequence\nAddresses - Managing aelf's blockchain addresses\nTransactions - Handling transaction processes\nSmart Contract - aelf's smart contract architecture\nACS Introduction - An introduction to aelf contract system\n📖 Tutorials​\nOperate a Node\nRun a Testnet Node\nRun a Mainnet Node\nRun aelf on Cloud\nRun a Side Chain\n🛠️ Tools​\nChain SDK - Develop blockchain specific applications using ChainSDK\naelf-deploy - Deploy your smart contract using this CLI\naelf CLI - Execute blockchain operations via CLI\nSmart Contract Templates - Templates to quickly build your smart contract\nFaucet - Test your dApp with aelf test tokens\nDesign - Explore aelf design library\nPlayground - Play with aelf in your browser\nContract SDK - C# SDKs\n⭐️ References​\nSmart Contract API - Access smart contract functionalities using API\nWeb API - Interact with the aelf blockchain through the web\n🔖 Resources​\nIntegration Guide - Learn how to integrate with other tools and DApps\nWallet and Block Explorer - Manage your assets and explore aelf's blockchain data\nAetherLink - Transfer tamper-proof data from off-chain to on-chain\nBrowser Extension - Explore Portkey wallet and other extensions\nDevOps - Tools to build and deploy efficiently\nProtobuf Extension - An open-source gRPC\nWhitepapers - aelf Whitepapers\nPlatform\nTechnology\nAudit Report\nPrivacy\nTerms of Use\nCookie Policy\nDeveloper Resources\nQuick Start\nLearn\nDocs\nTools\nResources\nEcosystem\nOverview\ndApps\naelf Ventures\nBlog\nConnect\nContact Us\nCopyright © 2024 aelf"
    }
  ]